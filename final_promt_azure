You are helping me standardize and regenerate Operation Registry + Adjacency graphs for ALL Azure services in my Azure SDK database, for a C7N-style operation dependency engine.

INPUT:
- Each Azure service has a service-specific JSON spec in its own folder.
- Each operation entry includes: operation name, python_method (Azure SDK style), required_params, optional_params, and output fields/paths.
- Azure SDK uses azure.mgmt.* clients and common patterns: list*, get, create_or_update/begin_create_or_update, update/begin_update, delete/begin_delete.

OUTPUTS (per service folder):
- overrides.json (persistent config; merged + canonical)
- operation_registry.json (FINAL)
- adjacency.json (FINAL)
- validation_report.json (FINAL)
- manual_review.json (ONLY remaining unresolved / conflicts after auto-apply)

GLOBAL OUTPUT:
- manual_review_global_summary.json (aggregate stats + which services still need review)

GOAL:
1) Avoid generic entities like "<service>.id", "<service>.name", "<service>.status".
2) Resolve alias cases deterministically at scale using overrides + entity_aliases.
3) Produce stable canonical entity names across services.
4) Auto-apply safe suggestions and shrink manual_review to only truly ambiguous cases.

--------------------------------------------------------------------
TASKS (implement in generator/refactor)
--------------------------------------------------------------------

1) KIND AUTO-ASSIGN (Azure-aware; global rule)
Assign kind using python_method first (strip "begin_" prefix before matching):
- write_delete: method startswith delete OR contains ".delete" OR endswith "_delete"
- write_update: method contains update OR patch OR modify OR set
- write_create: method contains create OR "create_or_update" OR put OR provision OR enable OR register OR import
- write_apply: method contains attach/associate/add/grant/revoke/tag/authorize/unauthorize
- read_list: method startswith list OR contains "list_by_" OR contains "list_" OR returns an array/plural root
- read_get: method startswith get OR contains "get_" OR returns a single object
- else other
Write kind into operation_registry for every operation.

2) ENTITY NAMING (Normalization that avoids generic tokens)
Create a deterministic entity naming function for consumes/produces.

2.1 Global ARM identity exceptions (DO NOT service-prefix these):
Map these always to global entities:
- subscriptionId / subscription_id => azure.subscription_id
- tenantId / tenant_id => azure.tenant_id
- resourceGroupName / resource_group_name => azure.resource_group_name
- resourceId / id that is an ARM resource id => azure.resource_id
- location => azure.location

2.2 For CONSUMES (input params)
- If param is generic token: id/name/status (case-insensitive):
  * Derive the resource noun from operation group or operation name:
    - Prefer operation group/class (e.g., VirtualMachinesOperations -> virtual_machine)
    - Else derive from output root object name
    - Else derive from operation name by stripping verbs (create/update/delete/get/list)
  * Map to: <service>.<resource>_<token>
  Examples:
  - compute.VirtualMachines.get(resource_group_name, vm_name) => consumes: azure.resource_group_name, compute.virtual_machine_name
  - storage.StorageAccounts.get(..., account_name) => consumes: storage.storage_account_name
- For compound params:
  - xxxName => <service>.<xxx>_name (unless it is resourceGroupName -> azure.resource_group_name)
  - xxxId => <service>.<xxx>_id (unless it is subscriptionId/tenantId/resourceId)
  - If param contains “*Arn” (rare in Azure) treat as <service>.<noun>_arn.

2.3 For PRODUCES (output fields/paths)
- Use output path context (nearest meaningful parent token) to scope:
  - virtualMachines[].id => compute.virtual_machine_id (or azure.resource_id if it is a full ARM id)
  - storageAccounts[].properties.statusOfPrimary => storage.storage_account_status_of_primary
- Never produce: <service>.id, <service>.name, <service>.status
- Use stopwords list ONLY: details, info, data, result (do not remove meaningful nouns)
- Fix obvious truncation/typos in generated names.

3) OPERATION REGISTRY SCHEMA (required)
Ensure operation_registry.json always contains:
{
  "service": "<service>",
  "version": "1.0",
  "kind_rules": {...},
  "entity_aliases": { "alias_entity": "canonical_entity", ... },
  "overrides": {
    "param_aliases": { "<evidence_key>": "<canonical_entity>", ... },
    "consumes": { "<operation>.<param>": "<entity>", ... },
    "produces": { "<operation>.<output_path>": "<entity>", ... }
  },
  "operations": {
     "<operation>": {
        "python_method": "...",
        "kind": "...",
        "required_params": [...],
        "optional_params": [...],
        "consumes": { "<param>": "<entity>" },
        "produces": { "<output_path>": "<entity>" }
     }
  }
}

4) ALIAS SUPPORT (the key change)
Implement BOTH:
- entity_aliases: alias_entity -> canonical_entity
- overrides.param_aliases: evidence_key -> canonical_entity

Evidence key format MUST be stable:
- For params: "<OperationGroup>.<python_method>:param:<param_name>"
- For outputs: "<OperationGroup>.<python_method>:out:<output_path>"

Canonical selection rule:
i) Prefer entities that appear in CONSUMES as canonical.
ii) Else most frequent entity name across operations.
iii) Tie-breaker: shortest meaningful name.
Safety:
- Never auto-alias across different parent resources for generic tokens (status/name) unless evidence key matches exactly.

5) TWO-PASS GENERATION (auto-apply safe fixes)
Pass 1:
- Generate operation_registry.json + adjacency.json + validation_report.json + manual_review.json
- manual_review contains only:
  - remaining generic entities
  - ambiguous evidence keys
  - alias candidates NOT applied
  - conflicts

Auto-apply rules (promote into overrides.json):
- Accept HIGH confidence suggestions automatically.
- Accept MEDIUM only if it reduces (generic_entities OR ambiguous_keys OR suspicious_paths) and does not increase unsatisfiable_ops.
- Record accepted_suggestions.json and rejected_suggestions.json (optional, but recommended).

Pass 2:
- Re-run generator using overrides.json and entity_aliases applied everywhere.
- manual_review.json must shrink (remove items resolved by overrides).

6) ADJACENCY (final)
Generate adjacency.json from registry after applying:
- overrides.param_aliases
- overrides.consumes/produces
- entity_aliases canonicalization
Adjacency must include:
- op_consumes, op_produces
- entity_producers, entity_consumers
- external_entities (global azure.* and other missing producers)

7) VALIDATION REPORT (final)
validation_report.json must include:
- total_ops, satisfiable_ops_percent, unsatisfiable_ops_count
- generic_entities_count
- ambiguous_evidence_keys (count + list)
- aliases_applied_count
- overrides_applied_count
- suspicious_paths_count

8) FIX APPLICATION BUG (must fix)
Known issue: fixes recorded but unresolved_items not removed.
Required:
- After applying overrides, remove corresponding items from unresolved_items by matching evidence_key.
- If conflicts exist, keep them in manual_review.json under conflicts[].

9) PROCESS ALL SERVICES MODE
Add a CLI/tool that:
- iterates all service folders under a root
- runs two-pass generation
- writes manual_review_global_summary.json with:
  - services_with_conflicts
  - services_with_remaining_unresolved
  - top ambiguous evidence keys

SAFETY:
- Before overwriting outputs, write a .bak copy.
- Output JSON must be stable sorted + pretty-printed for clean diffs.

DELIVERABLE:
Commit refactor + show example run log for 2–3 services proving:
- overrides.json is populated
- manual_review.json shrank after pass 2
- adjacency regenerated with fewer ambiguous/generic entities
