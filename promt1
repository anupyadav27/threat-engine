use this for all services under aws folder 

You are helping me build a dependency graph for AWS service operations (c7n-style). 
In this folder there is one service JSON file (service-specific spec). 

INPUT:
- Read the service spec JSON in this folder. It has keys like:
  service, independent[], dependent[].
- Each operation object contains:
  operation, python_method, yaml_action, required_params[], optional_params[],
  output_fields{}, main_output_field, item_fields{} (or []).
- Treat required_params as inputs. Treat output_fields AND item_fields as outputs (item_fields under main_output_field).

TASK:
Generate TWO files in this same folder:

(1) operation_registry.json
A normalized registry of operations for this service.

Schema:
{
  "service": "<service_name>",
  "version": "1.0",
  "operations": {
    "<OperationName>": {
      "kind": "read_list|read_get|write_create|write_apply|write_update|write_delete|other",
      "side_effect": true|false,
      "sdk": {"client":"<service_name>", "method":"<python_method>"},
      "consumes": [
        {"entity":"<service>.<entity_name>", "param":"<required_param>", "required":true, "source":"internal|external|either"}
      ],
      "produces": [
        {"entity":"<service>.<entity_name>", "source":"output|item", "path":"<response_path>"}
      ],
      "notes":""
    }
  },
  "entity_aliases": { "<key>": "<service>.<entity_name>" },
  "kind_rules": { ... include rules exactly as below ... }
}

Rules to build consumes:
- For each required_param -> add consumes item with entity derived by entity mapping rules (below).
- Set source temporarily to "either". We will finalize source after building adjacency.

Rules to build produces:
- For each output_fields key k -> produces item:
  source="output", path=k.
- If main_output_field exists and item_fields is present:
  for each item_fields key f -> produces item:
  source="item", path="<main_output_field>[].<f>"

(2) adjacency.json
Derived from operation_registry.json:

{
  "service":"<service_name>",
  "op_consumes": { "Op": ["service.entity", ...] },
  "op_produces": { "Op": ["service.entity", ...] },
  "entity_producers": { "service.entity": ["Op1","Op2"] },
  "entity_consumers": { "service.entity": ["OpA","OpB"] },
  "external_entities": ["service.entity", ...]
}

How to finalize consumes.source and external_entities:
- After building entity_producers, for each consumes entity:
  if entity exists in entity_producers -> source="internal"
  else source="external" and add to external_entities (dedup).

AUTO-ASSIGN KIND (first match wins, in this exact order):
1) If op starts with any of: Delete, Remove, Terminate, Destroy, Purge, Detach, Disassociate, Untag -> kind="write_delete"
2) Else if op starts with any of: Update, Modify, Put, Set, Replace, Patch, Change, Reset -> kind="write_update"
3) Else if op starts with any of: Create, Start, Run, Launch, Provision, Register, Enable, Generate, Import -> kind="write_create"
4) Else if op starts with any of: Apply, Attach, Associate, Add, Grant, Revoke, Tag, Authorize, Unauthorize -> kind="write_apply"
5) Else if op starts with "List" -> kind="read_list"
6) Else if op starts with "Get" -> kind="read_get"
7) Else if op starts with Describe, Search, Scan, Query -> decide by plural heuristic:
   - kind="read_list" if operation name endswith "s" OR contains any of:
     Summaries, Statistics, Results, Items, Resources, Findings, Policies, Rules, Jobs, Previews
   - otherwise kind="read_get"
8) Else kind="other"

SIDE EFFECT RULE:
- side_effect=false if kind starts with "read_"
- else side_effect=true

ENTITY MAPPING (IMPORTANT):
We need a canonical entity name per param/field so dependencies connect.

Default mapping:
- entity = "<service>." + snake_case(param_or_field_name)
Examples: analyzerArn -> accessanalyzer.analyzer_arn, jobId -> accessanalyzer.job_id

But for item_fields under lists, include the list context if field is generic like arn/id/name/status:
- If path matches "<main_output_field>[].arn" -> entity="<service>.<main_output_field_singular>_arn" (best effort singular by removing trailing 's')
- If path matches "<main_output_field>[].id" -> entity="<service>.<main_output_field_singular>_id"
- If path matches "<main_output_field>[].name" -> entity="<service>.<main_output_field_singular>_name"
- If path matches "<main_output_field>[].status" -> entity="<service>.<main_output_field_singular>_status"
Otherwise use default snake_case(field).

ENTITY ALIASES / OVERRIDES:
If you detect a produced field that is too generic (id/arn/name) and there is a required_param in another op that clearly refers to it with a different name, add an alias entry mapping both to the same canonical entity.
Example pattern:
- CreateX outputs "id" and another operation requires "xId" or "xArn"
Add:
  "CreateX.output.id": "<service>.x_id"
  "GetX.required.xId": "<service>.x_id"
Do this conservatively only for high-confidence matches.

OUTPUT:
- Create operation_registry.json and adjacency.json.
- Ensure both JSON files are valid, formatted, and saved.
- Do NOT change the original service spec file.
