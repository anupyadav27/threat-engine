You are helping me standardize and regenerate Operation Registry + Adjacency for ALL AWS services for my C7N-style operation dependency engine.

Context:
- Each service has a service-specific JSON spec in its own folder.
- Current deliverables: operation_registry.json + adjacency.json + validation_report.json.
- Current issue: we solved generic tokens (arn/status/id/name) via overrides/entity_normalizations, but entity_aliases is still empty and we want proper alias handling so canonical entity names stay stable across services.
- Goal: one global pass that produces consistent output for every service, and also produces a “manual_review.json” file listing only the remaining uncertain mappings.

TASKS (implement in generator/refactor):
1) KIND AUTO-ASSIGN (global rule)
   Implement a single clean rule to assign kind from operation name:
   - write_delete if name starts with any of: Delete|Remove|Terminate|Destroy|Purge|Detach|Disassociate|Untag
   - write_update if starts with: Update|Modify|Put|Set|Replace|Patch|Change|Reset
   - write_create if starts with: Create|Start|Run|Launch|Provision|Register|Enable|Generate|Import
   - write_apply if starts with: Apply|Attach|Associate|Add|Grant|Revoke|Tag|Authorize|Unauthorize
   - read_list if starts with: List OR Describe/Search/Scan/Query and the output path indicates plural (array like [] or plural root)
   - read_get for Get OR Describe/Search/Scan/Query and output is singular object
   - else other
   Ensure kind is written into operation_registry for every operation.

2) ENTITY NAMING (global normalization logic)
   Add a deterministic entity naming function so we avoid generic entities:
   - Always prefix with "<service>."
   - CRITICAL: Never create generic entities: <service>.name, <service>.id, <service>.status, <service>.arn
   
   For CONSUMES (input params):
   - If param is exactly "name", "id", "arn", or "status" (case-insensitive):
     * Extract noun from operation name by removing verb prefixes (Put, Create, Update, Delete, etc.)
     * Map to: <service>.<noun_snake>_<token>
     * Example: PutAlternateContact.Name -> account.alternate_contact_name (NOT account.name)
     * Example: CreateInvestigationGroup.name -> aiops.investigation_group_name (NOT aiops.name)
   - For compound params (e.g., analyzerArn, jobId): extract base and map to <service>.<base>_<token>
   
   For PRODUCES (output paths):
   - Use output path context: use the nearest parent object token as scope
     Examples:
     - analyzers[].arn => analyzer_arn
     - findings[].status => finding_status
     - jobDetails.jobId => job_detail_job_id (but see alias rules below)
   - Apply a small stopword list (details, info, data) but DO NOT remove meaningful object tokens.
   - Fix obvious truncation/typos in generated names (e.g., "analyzed_resourc_resource_arn" should become "analyzed_resource_arn").

3) ALIAS SUPPORT (THIS IS THE KEY CHANGE)
   Implement entity_aliases in operation_registry:
   - entity_aliases should map: alias_entity -> canonical_entity
   - Canonical selection rule (safe + stable):
     i) Prefer entities that appear in consumes (inputs) as canonical.
     ii) If multiple, choose the most frequent entity name across operations.
     iii) Tie-breaker: shortest meaningful name.
   - Build alias candidates automatically when:
     a) Same param name appears in multiple operations but entity names differ
        (e.g., jobId mapped to job_id vs job_detail_job_id vs policy_generation_job_id)
     b) Same “real id” appears in both output and input with different names
   - IMPORTANT SAFETY:
     Only auto-alias when the type/meaning is highly likely identical:
       - Arn/Id that is consistently tied to same param name (analyzerArn, jobId, accessPreviewId, findingId)
     Never auto-alias generic “status”, “created_at”, “name” across different parent objects.
   - After aliasing, do NOT force-renormalize canonicals via entity_normalizations unless still necessary.

4) OVERRIDES vs ALIASES
   Refactor so:
   - overrides.entity_normalizations is used only for truly generic leftovers (service.arn -> service.specific_arn), not for canonical drift.
   - If you previously normalized accessanalyzer.job_id -> accessanalyzer.job_detail_job_id, revert that and instead make:
       entity_aliases["accessanalyzer.job_detail_job_id"] = "accessanalyzer.job_id"
       entity_aliases["accessanalyzer.policy_generation_job_id"] = "accessanalyzer.job_id"
     (Same concept for access_preview_analyzer_arn if it exists.)

5) REGENERATION PIPELINE (all services)
   - Apply the above globally (no per-service manual edits).
   - Regenerate for every service folder:
       operation_registry.json
       adjacency.json
       validation_report.json

6) MANUAL REVIEW FILE (auto-generated)
   Generate manual_review.json per service with only unresolved issues:
   - remaining generic entities (arn/status/id/name count > 0)
   - ambiguous tokens that map to multiple entity types
   - alias candidates that were NOT auto-applied due to safety rules
   Include suggested mappings + confidence score + evidence (operation + path/param).
   This file is what I will review manually later.

7) VALIDATION UPDATES
   Update validation so it:
   - resolves aliases when computing dependency chains
   - reports:
     - generic entity counts
     - ambiguous tokens list
     - overrides applied
     - aliases applied
   Ensure AccessAnalyzer still passes and entity_aliases is no longer empty.

ACCEPTANCE CRITERIA:
- entity_aliases is populated when appropriate (jobId/analyzerArn-like cases).
- generic_entities arn/status/id/name are 0 in validation_report for ALL services.
- Generic params (name/id/arn/status) are mapped to semantic entities using operation noun context.
- No unsafe aliasing of status/created_at/name across different parent objects.
- manual_review.json is created and contains only remaining uncertainties.
- All services regenerated with consistent entity naming.

IMPLEMENTATION STATUS:
✓ Generic param context rule implemented - extracts noun from operation name
✓ Entity aliases implemented and populated (e.g., accessanalyzer has 7 aliases)
✓ Generic entities eliminated across all 411 services (0 services with generic entities)
✓ Stopword removal and truncation fixes applied
✓ Manual review files generated for services needing attention
✓ Global summary generated with aggregated statistics

8) MANUAL REVIEW AUTO-FIXER (NEW - Post-Implementation Tool)
   Created comprehensive auto-fixer tool to reduce manual_review.json issues to near-zero:
   
   Location: tools/manual_review_fixer/
   - fix_manual_review.py - Main CLI tool
   - llm_client.py - Optional LLM assistance
   - README.md - Complete documentation
   
   Features Implemented:
   ✓ Direct Variables Generation (Part 1)
     - Auto-generates direct_vars.json from operation_registry.json
     - Extracts read-only variables from List/Get/Describe/Search/Lookup operations
     - Excludes pagination tokens (nextToken, maxResults)
   
   ✓ Derived Catalog Management (Part 2)
     - Ensures derived_catalog.yaml exists at repo root
     - Seed catalog with 10 common derived variables:
       * is_public, has_findings, is_encrypted, logging_enabled
       * versioning_enabled, mfa_enabled, has_wildcards
       * tls_required, public_access_block_enabled, has_admin_permissions
   
   ✓ Deterministic Auto-Fix Rules (Part 3)
     - Missing/unknown variable fixes (direct vars + fuzzy matching)
     - Derived variable mapping by keywords (public, encryption, logging, etc.)
     - Alias suggestions for entity mismatches
     - Generates overrides.json for entity aliases
   
   ✓ Optional LLM Assistance (Part 4)
     - Batch processing of unresolved items (max 50 per service)
     - Confidence threshold (>= 0.80) for applying fixes
     - Validates fixes before applying (checks var exists)
     - Preserves existing fixes (merges instead of overwriting)
   
   Outputs:
   - Per service: direct_vars.json, updated manual_review.json, fixes_applied.json, overrides.json
   - Global: manual_review_global_summary.json
   
   Usage:
   - Deterministic only: python tools/manual_review_fixer/fix_manual_review.py --root pythonsdk-database/aws
   - With LLM: python tools/manual_review_fixer/fix_manual_review.py --root pythonsdk-database/aws --use-llm --model gpt-4o-mini
   
   Current Status:
   ✓ Tool fully implemented and tested
   ✓ Processing 411 services successfully
   ✓ Applied 2,000+ fixes across 296 services
   ⚠️  Known issue: Fix application logic needs improvement (fixes recorded but items not removed from unresolved_items)
   ⚠️  Next: Improve fix application to actually remove resolved items from manual_review.json
