version: '1.0'
provider: aws
service: ecs
services:
  client: ecs
  module: boto3.client
discovery:
- discovery_id: aws.ecs.create_cluster
  calls:
  - action: create_cluster
    save_as: response
  emit:
    item:
      clusterArn: '{{ response.cluster.clusterArn }}'
      clusterName: '{{ response.cluster.clusterName }}'
      configuration: '{{ response.cluster.configuration }}'
      status: '{{ response.cluster.status }}'
      registeredContainerInstancesCount: '{{ response.cluster.registeredContainerInstancesCount
        }}'
      runningTasksCount: '{{ response.cluster.runningTasksCount }}'
      pendingTasksCount: '{{ response.cluster.pendingTasksCount }}'
      activeServicesCount: '{{ response.cluster.activeServicesCount }}'
      statistics: '{{ response.cluster.statistics }}'
      tags: '{{ response.cluster.tags }}'
      settings: '{{ response.cluster.settings }}'
      capacityProviders: '{{ response.cluster.capacityProviders }}'
      defaultCapacityProviderStrategy: '{{ response.cluster.defaultCapacityProviderStrategy
        }}'
      attachments: '{{ response.cluster.attachments }}'
      attachmentsStatus: '{{ response.cluster.attachmentsStatus }}'
      serviceConnectDefaults: '{{ response.cluster.serviceConnectDefaults }}'
- discovery_id: aws.ecs.register_container_instance
  calls:
  - action: register_container_instance
    save_as: response
  emit:
    item:
      containerInstanceArn: '{{ response.containerInstance.containerInstanceArn }}'
      ec2InstanceId: '{{ response.containerInstance.ec2InstanceId }}'
      capacityProviderName: '{{ response.containerInstance.capacityProviderName }}'
      version: '{{ response.containerInstance.version }}'
      versionInfo: '{{ response.containerInstance.versionInfo }}'
      remainingResources: '{{ response.containerInstance.remainingResources }}'
      registeredResources: '{{ response.containerInstance.registeredResources }}'
      status: '{{ response.containerInstance.status }}'
      statusReason: '{{ response.containerInstance.statusReason }}'
      agentConnected: '{{ response.containerInstance.agentConnected }}'
      runningTasksCount: '{{ response.containerInstance.runningTasksCount }}'
      pendingTasksCount: '{{ response.containerInstance.pendingTasksCount }}'
      agentUpdateStatus: '{{ response.containerInstance.agentUpdateStatus }}'
      attributes: '{{ response.containerInstance.attributes }}'
      registeredAt: '{{ response.containerInstance.registeredAt }}'
      attachments: '{{ response.containerInstance.attachments }}'
      tags: '{{ response.containerInstance.tags }}'
      healthStatus: '{{ response.containerInstance.healthStatus }}'
- discovery_id: aws.ecs.create_service
  calls:
  - action: create_service
    save_as: response
    params:
      serviceName: '{{ item.serviceName }}'
  on_error: continue
  for_each: aws.ecs.update_express_gateway_service
  emit:
    item:
      serviceArn: '{{ response.service.serviceArn }}'
      serviceName: '{{ response.service.serviceName }}'
      clusterArn: '{{ response.service.clusterArn }}'
      loadBalancers: '{{ response.service.loadBalancers }}'
      serviceRegistries: '{{ response.service.serviceRegistries }}'
      status: '{{ response.service.status }}'
      desiredCount: '{{ response.service.desiredCount }}'
      runningCount: '{{ response.service.runningCount }}'
      pendingCount: '{{ response.service.pendingCount }}'
      launchType: '{{ response.service.launchType }}'
      capacityProviderStrategy: '{{ response.service.capacityProviderStrategy }}'
      platformVersion: '{{ response.service.platformVersion }}'
      platformFamily: '{{ response.service.platformFamily }}'
      taskDefinition: '{{ response.service.taskDefinition }}'
      deploymentConfiguration: '{{ response.service.deploymentConfiguration }}'
      taskSets: '{{ response.service.taskSets }}'
      deployments: '{{ response.service.deployments }}'
      roleArn: '{{ response.service.roleArn }}'
      events: '{{ response.service.events }}'
      createdAt: '{{ response.service.createdAt }}'
      currentServiceDeployment: '{{ response.service.currentServiceDeployment }}'
      currentServiceRevisions: '{{ response.service.currentServiceRevisions }}'
      placementConstraints: '{{ response.service.placementConstraints }}'
      placementStrategy: '{{ response.service.placementStrategy }}'
      networkConfiguration: '{{ response.service.networkConfiguration }}'
      healthCheckGracePeriodSeconds: '{{ response.service.healthCheckGracePeriodSeconds
        }}'
      schedulingStrategy: '{{ response.service.schedulingStrategy }}'
      deploymentController: '{{ response.service.deploymentController }}'
      tags: '{{ response.service.tags }}'
      createdBy: '{{ response.service.createdBy }}'
      enableECSManagedTags: '{{ response.service.enableECSManagedTags }}'
      propagateTags: '{{ response.service.propagateTags }}'
      enableExecuteCommand: '{{ response.service.enableExecuteCommand }}'
      availabilityZoneRebalancing: '{{ response.service.availabilityZoneRebalancing
        }}'
      resourceManagementType: '{{ response.service.resourceManagementType }}'
- discovery_id: aws.ecs.update_express_gateway_service
  calls:
  - action: update_express_gateway_service
    save_as: response
    params:
      serviceArn: '{{ item.serviceArn }}'
  on_error: continue
  for_each: aws.ecs.list_service_deployments
  emit:
    item:
      serviceArn: '{{ response.service.serviceArn }}'
      cluster: '{{ response.service.cluster }}'
      serviceName: '{{ response.service.serviceName }}'
      status: '{{ response.service.status }}'
      targetConfiguration: '{{ response.service.targetConfiguration }}'
      createdAt: '{{ response.service.createdAt }}'
      updatedAt: '{{ response.service.updatedAt }}'
checks:
- rule_id: aws.ecs.container_instance.container_read_only_root_filesystem_configured
  for_each: aws.ecs.register_container_instance
  conditions:
    var: item.attributes
    op: contains
    value:
      name: ecs.capability.docker.readonlyRootFilesystem
      value: 'true'
- rule_id: aws.ecs.container_instance.no_privileged_containers_configured
  for_each: aws.ecs.register_container_instance
  conditions:
    var: item.attributes
    op: contains
    value:
      name: ecs.capability.privileged-container
      value: 'false'
- rule_id: aws.ecs.task_definition_image_source_verification.task_ecs_task_definition_image_source_verification_configured
  for_each: aws.ecs.create_cluster
  conditions:
    var: item.status
    op: equals
    value: ACTIVE
- rule_id: aws.ecs.resource.task_sets_assign_public_ip_disabled
  for_each: aws.ecs.create_service
  conditions:
    var: item.launchType
    op: equals
    value: FARGATE
- rule_id: aws.ecs.resource.task_definition_logging_enabled
  for_each: aws.ecs.create_service
  conditions:
    var: item.enableExecuteCommand
    op: equals
    value: true
- rule_id: aws.ecs.container_instance.container_env_no_plaintext_secrets_configured
  for_each: aws.ecs.register_container_instance
  conditions:
    var: item.attributes
    op: exists
- rule_id: aws.ecs.task_definitions_logging_block_mode.task_definitions_logging_block_mode_configured
  for_each: aws.ecs.create_cluster
  conditions:
    var: item.status
    op: equals
    value: ACTIVE
- rule_id: aws.ecs.resource.task_definitions_logging_enabled
  for_each: aws.ecs.create_service
  conditions:
    var: item.enableExecuteCommand
    op: equals
    value: true
