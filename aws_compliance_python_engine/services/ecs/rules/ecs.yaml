version: '1.0'
provider: aws
service: ecs
services:
  client: ecs
  module: boto3.client
discovery:
- discovery_id: aws.ecs.describe_clusters
  calls:
  - action: describe_clusters
    save_as: response
  emit:
    item:
      clusterArn: '{{ response.clusters.clusterArn }}'
      clusterName: '{{ response.clusters.clusterName }}'
      configuration: '{{ response.clusters.configuration }}'
      status: '{{ response.clusters.status }}'
      registeredContainerInstancesCount: '{{ response.clusters.registeredContainerInstancesCount
        }}'
      runningTasksCount: '{{ response.clusters.runningTasksCount }}'
      pendingTasksCount: '{{ response.clusters.pendingTasksCount }}'
      activeServicesCount: '{{ response.clusters.activeServicesCount }}'
      statistics: '{{ response.clusters.statistics }}'
      tags: '{{ response.clusters.tags }}'
      settings: '{{ response.clusters.settings }}'
      capacityProviders: '{{ response.clusters.capacityProviders }}'
      defaultCapacityProviderStrategy: '{{ response.clusters.defaultCapacityProviderStrategy
        }}'
      attachments: '{{ response.clusters.attachments }}'
      attachmentsStatus: '{{ response.clusters.attachmentsStatus }}'
      serviceConnectDefaults: '{{ response.clusters.serviceConnectDefaults }}'
- discovery_id: aws.ecs.describe_tasks
  calls:
  - action: describe_tasks
    save_as: response
  emit:
    item:
      attachments: '{{ response.tasks.attachments }}'
      attributes: '{{ response.tasks.attributes }}'
      availabilityZone: '{{ response.tasks.availabilityZone }}'
      capacityProviderName: '{{ response.tasks.capacityProviderName }}'
      clusterArn: '{{ response.tasks.clusterArn }}'
      connectivity: '{{ response.tasks.connectivity }}'
      connectivityAt: '{{ response.tasks.connectivityAt }}'
      containerInstanceArn: '{{ response.tasks.containerInstanceArn }}'
      containers: '{{ response.tasks.containers }}'
      cpu: '{{ response.tasks.cpu }}'
      createdAt: '{{ response.tasks.createdAt }}'
      desiredStatus: '{{ response.tasks.desiredStatus }}'
      enableExecuteCommand: '{{ response.tasks.enableExecuteCommand }}'
      executionStoppedAt: '{{ response.tasks.executionStoppedAt }}'
      group: '{{ response.tasks.group }}'
      healthStatus: '{{ response.tasks.healthStatus }}'
      inferenceAccelerators: '{{ response.tasks.inferenceAccelerators }}'
      lastStatus: '{{ response.tasks.lastStatus }}'
      launchType: '{{ response.tasks.launchType }}'
      memory: '{{ response.tasks.memory }}'
      overrides: '{{ response.tasks.overrides }}'
      platformVersion: '{{ response.tasks.platformVersion }}'
      platformFamily: '{{ response.tasks.platformFamily }}'
      pullStartedAt: '{{ response.tasks.pullStartedAt }}'
      pullStoppedAt: '{{ response.tasks.pullStoppedAt }}'
      startedAt: '{{ response.tasks.startedAt }}'
      startedBy: '{{ response.tasks.startedBy }}'
      stopCode: '{{ response.tasks.stopCode }}'
      stoppedAt: '{{ response.tasks.stoppedAt }}'
      stoppedReason: '{{ response.tasks.stoppedReason }}'
      stoppingAt: '{{ response.tasks.stoppingAt }}'
      tags: '{{ response.tasks.tags }}'
      taskArn: '{{ response.tasks.taskArn }}'
      taskDefinitionArn: '{{ response.tasks.taskDefinitionArn }}'
      version: '{{ response.tasks.version }}'
      ephemeralStorage: '{{ response.tasks.ephemeralStorage }}'
      fargateEphemeralStorage: '{{ response.tasks.fargateEphemeralStorage }}'
- discovery_id: aws.ecs.create_service
  calls:
  - action: create_service
    save_as: response
  emit:
    item:
      serviceArn: '{{ response.service.serviceArn }}'
      serviceName: '{{ response.service.serviceName }}'
      clusterArn: '{{ response.service.clusterArn }}'
      loadBalancers: '{{ response.service.loadBalancers }}'
      serviceRegistries: '{{ response.service.serviceRegistries }}'
      status: '{{ response.service.status }}'
      desiredCount: '{{ response.service.desiredCount }}'
      runningCount: '{{ response.service.runningCount }}'
      pendingCount: '{{ response.service.pendingCount }}'
      launchType: '{{ response.service.launchType }}'
      capacityProviderStrategy: '{{ response.service.capacityProviderStrategy }}'
      platformVersion: '{{ response.service.platformVersion }}'
      platformFamily: '{{ response.service.platformFamily }}'
      taskDefinition: '{{ response.service.taskDefinition }}'
      deploymentConfiguration: '{{ response.service.deploymentConfiguration }}'
      taskSets: '{{ response.service.taskSets }}'
      deployments: '{{ response.service.deployments }}'
      roleArn: '{{ response.service.roleArn }}'
      events: '{{ response.service.events }}'
      createdAt: '{{ response.service.createdAt }}'
      currentServiceDeployment: '{{ response.service.currentServiceDeployment }}'
      currentServiceRevisions: '{{ response.service.currentServiceRevisions }}'
      placementConstraints: '{{ response.service.placementConstraints }}'
      placementStrategy: '{{ response.service.placementStrategy }}'
      networkConfiguration: '{{ response.service.networkConfiguration }}'
      healthCheckGracePeriodSeconds: '{{ response.service.healthCheckGracePeriodSeconds
        }}'
      schedulingStrategy: '{{ response.service.schedulingStrategy }}'
      deploymentController: '{{ response.service.deploymentController }}'
      tags: '{{ response.service.tags }}'
      createdBy: '{{ response.service.createdBy }}'
      enableECSManagedTags: '{{ response.service.enableECSManagedTags }}'
      propagateTags: '{{ response.service.propagateTags }}'
      enableExecuteCommand: '{{ response.service.enableExecuteCommand }}'
      availabilityZoneRebalancing: '{{ response.service.availabilityZoneRebalancing
        }}'
      resourceManagementType: '{{ response.service.resourceManagementType }}'
- discovery_id: aws.ecs.describe_capacity_providers
  calls:
  - action: describe_capacity_providers
    save_as: response
  emit:
    item:
      capacityProviderArn: '{{ response.capacityProviders.capacityProviderArn }}'
      name: '{{ response.capacityProviders.name }}'
      cluster: '{{ response.capacityProviders.cluster }}'
      status: '{{ response.capacityProviders.status }}'
      autoScalingGroupProvider: '{{ response.capacityProviders.autoScalingGroupProvider
        }}'
      managedInstancesProvider: '{{ response.capacityProviders.managedInstancesProvider
        }}'
      updateStatus: '{{ response.capacityProviders.updateStatus }}'
      updateStatusReason: '{{ response.capacityProviders.updateStatusReason }}'
      tags: '{{ response.capacityProviders.tags }}'
      type: '{{ response.capacityProviders.type }}'
checks:
- rule_id: aws.ecs.container_instance.container_read_only_root_filesystem_configured
  for_each: aws.ecs.describe_clusters
  conditions:
    var: item.configuration
    op: not_equals
    value: 'null'
- rule_id: aws.ecs.container_instance.no_privileged_containers_configured
  for_each: aws.ecs.describe_tasks
  conditions:
    var: item.containers
    op: not_equals
    value: 'null'
- rule_id: aws.ecs.task_definition_image_source_verification.task_ecs_task_definition_image_source_verification_configured
  for_each: aws.ecs.describe_clusters
  conditions:
    var: item.configuration
    op: not_equals
    value: 'null'
- rule_id: aws.ecs.resource.task_sets_assign_public_ip_disabled
  for_each: aws.ecs.create_service
  conditions:
    var: item.taskSets
    op: not_equals
    value: 'null'
- rule_id: aws.ecs.resource.task_definition_logging_enabled
  for_each: aws.ecs.describe_capacity_providers
  conditions:
    var: item.name
    op: equals
    value: defaultLogDriverMode
- rule_id: aws.ecs.container_instance.container_env_no_plaintext_secrets_configured
  for_each: aws.ecs.describe_clusters
  conditions:
    var: item.configuration
    op: not_equals
    value: 'null'
- rule_id: aws.ecs.task_definitions_logging_block_mode.task_definitions_logging_block_mode_configured
  for_each: aws.ecs.describe_capacity_providers
  conditions:
    var: item.name
    op: equals
    value: defaultLogDriverMode
- rule_id: aws.ecs.resource.task_definitions_logging_enabled
  for_each: aws.ecs.describe_tasks
  conditions:
    var: item.containers
    op: exists
