You are helping me standardize and regenerate dependency artifacts for OCI services for my C7N-style operation dependency engine.

PROVIDER: oci

INPUT (per service folder)
- A service-specific JSON spec with operations containing:
  - operation (string)
  - python_method (string, optional)
  - required_params (list)
  - optional_params (list)
  - output_fields (object)
  - main_output_field (string|null)
  - item_fields (object|list)  // when main_output_field is list-like

OUTPUTS (per service folder) â€” FINAL ONLY
1) operation_registry.json
2) adjacency.json
3) validation_report.json
4) overrides.json (applied overrides + persisted decisions)
5) manual_review.json (ONLY unresolved/conflicts after auto-fix)
6) fixes_applied.json (audit log)

Optional global output:
7) manual_review_global_summary.json

CORE MODELING RULES
A) PRODUCERS:
   - output_fields keys are produced values
   - item_fields keys are produced values too
   - If list-like output container is missing, assume "items" is the list container for List* operations.

B) CONSUMERS:
   - required_params are consumed inputs

C) Many-to-many allowed.

------------------------------------------------------------
1) KIND AUTO-ASSIGN (OCI-aware; single deterministic rule)
------------------------------------------------------------
Prefer python_method if present; else use operation name.

Let name = (python_method or operation). Case-insensitive.
Assign kind by FIRST match:

write_delete if startswith any:
  delete|remove|terminate|destroy|purge|detach|disassociate|revoke|cancel|disable
write_update if startswith any:
  update|modify|set|change|patch|replace|add|attach|associate|enable|move
write_create if startswith any:
  create|launch|start|run|provision|register|generate|import|enable
read_list if startswith any:
  list|search|query|enumerate
read_get if startswith any:
  get|describe|read|fetch
else:
  other

Write kind for every operation.

------------------------------------------------------------
2) GLOBAL IDENTITY EXCEPTIONS (OCI specific)
------------------------------------------------------------
These MUST map to global canonical entities (never service-prefix):
- compartmentId / compartment_id => oci.compartment_id
- tenancyId / tenancy_id => oci.tenancy_id
- region => oci.region
- availabilityDomain / availability_domain => oci.availability_domain
- ocid / id when it clearly represents an OCID (string, often begins with "ocid1.") => oci.ocid
- pagination: page|limit|opc-next-page|nextPage => oci.pagination_token (NOT security identity)

------------------------------------------------------------
3) CANONICAL ENTITY NAMING (avoid generic leftovers)
------------------------------------------------------------
Canonical format:
  oci.<service>.<resource>.<field>

Never keep:
  oci.<service>.id
  oci.<service>.name
  oci.<service>.status

OCI-specific field normalization:
- displayName => name
- lifecycleState => status

3.1 Derive <resource> using best available signal:
a) If main_output_field exists and item_fields exist:
   infer resource from main_output_field container name (singularize)
b) Else if operation starts with List and output has "items":
   infer resource from operation name after stripping "List"
c) Else derive from operation name by stripping verbs:
   list|get|describe|create|update|delete|change|set|patch|add|remove
d) Else fallback "resource"

3.2 CONSUMES mapping (required_params)
For each param:
- If matches GLOBAL exceptions -> map using section 2.
- If endswith Id or equals id:
    map to oci.<service>.<resource>.<resource>_id (unless it's compartmentId/tenancyId)
- If endswith Name or is displayName:
    map to oci.<service>.<resource>.name
- If generic token (id|name|status):
    ALWAYS namespace to resource:
    oci.<service>.<resource>.<resource>_<token>

3.3 PRODUCES mapping (output_fields + item_fields)
- Include output_fields + item_fields.
- If produced key is generic id/name/status:
  scope using nearest parent path:
    items[].id -> oci.<service>.<resource>.<resource>_id
    items[].displayName -> oci.<service>.<resource>.name
    items[].lifecycleState -> oci.<service>.<resource>.status
- If produced key looks like a global identity (compartmentId, tenancyId) -> section 2.

------------------------------------------------------------
4) OVERRIDES + ALIASES (two layers)
------------------------------------------------------------
Evidence keys:
Params:
  "<operation>:param:<param_name>"
Outputs:
  "<operation>:out:<output_path>"

overrides.json supports:
- param_aliases: evidence_key -> canonical_entity
- entity_aliases: alias_entity -> canonical_entity
- consumes_overrides: "<operation>.<param>" -> canonical_entity
- produces_overrides: "<operation>.<output_path>" -> canonical_entity

Resolution priority:
1) consumes_overrides / produces_overrides (exact)
2) param_aliases (evidence_key)
3) inferred mapping rules (section 2 + 3)
4) canonicalize via entity_aliases

------------------------------------------------------------
5) TWO-PASS + AUTO-APPLY suggested_overrides
------------------------------------------------------------
PASS 1:
Generate registry+adjacency+validation+manual_review.

manual_review should include:
- unresolved consumers
- ambiguous evidence keys
- remaining generic_token_hits
- suggested_overrides candidates:
  { operation, type: consumes|produces, key, suggested_entity, confidence, reason }

AUTO-APPLY:
- HIGH -> accept into overrides.json
- MEDIUM -> accept only if it reduces:
    generic_token_hits OR ambiguous_count OR unresolved_consumers_count
  and does NOT increase unsatisfiable_ops_count
- LOW -> do not auto apply
Write decisions to fixes_applied.json

PASS 2:
Regenerate artifacts using overrides.json
manual_review MUST shrink by removing resolved evidence keys.

BUG FIX:
If fixes_applied marks accepted suggestion, remove it from manual_review unresolved list.

------------------------------------------------------------
6) ADJACENCY GRAPH
------------------------------------------------------------
Create edges where:
producer produces an entity that satisfies consumer required param.

Edge includes:
- from_operation_id
- to_operation_id
- entity
- from_key
- to_param
- confidence + reason

Also include:
- independent_ops
- root_seeds (best list/get ops)

------------------------------------------------------------
7) VALIDATION REPORT
------------------------------------------------------------
Include:
- totals ops/edges
- satisfiable_ops_percent
- unresolved_consumers list
- ambiguous evidence keys list
- generic_token_hits count + examples
- overrides_applied_count
- aliases_applied_count
- cycles

------------------------------------------------------------
8) FINAL OUTPUT HYGIENE
------------------------------------------------------------
Keep ONLY final files listed above.
Write .bak backups before overwriting.
Stable sorted pretty JSON.

Now implement/refactor generator to run all OCI services under oci/** in one run with the two-pass auto-fix pipeline.
Prefer deterministic logic; log reasons for heuristics.
