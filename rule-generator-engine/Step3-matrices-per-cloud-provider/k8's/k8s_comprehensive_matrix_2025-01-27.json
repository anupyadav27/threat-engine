{
  "version": "3.2",
  "technology": "kubernetes",
  "matrix_type": "comprehensive_security_matrix",
  "domains": {
    "identity_access.authentication": [
      {
        "service": "core",
        "resource": "identity.user",
        "adapter": "k8s.core.user.authentication.certificate_auth_status",
        "rule_prefix": "k8s.core.user.authentication",
        "resource_type": "identity.user",
        "k8s_resources": [
          "User",
          "CertificateSigningRequest"
        ],
        "validation_method": "kubectl get users, kubectl get csr",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "identity.service_account",
        "adapter": "k8s.core.service_account.authentication.token_automount",
        "rule_prefix": "k8s.core.service_account.authentication",
        "resource_type": "identity.service_account",
        "k8s_resources": [
          "ServiceAccount",
          "TokenRequest"
        ],
        "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "authentication.k8s.io",
        "resource": "api.api_server",
        "adapter": "k8s.authentication.api_server.token_review.audit_logging",
        "rule_prefix": "k8s.authentication.api_server.token_review",
        "resource_type": "api.api_server",
        "k8s_resources": [
          "TokenReview"
        ],
        "validation_method": "kubectl auth can-i --list",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "identity.group",
        "adapter": "k8s.core.group.authentication.authentication_check",
        "rule_prefix": "k8s.core.group.authentication",
        "resource_type": "identity.group",
        "k8s_resources": [
          "Group"
        ],
        "validation_method": "kubectl get groups",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "identity_access.authorization": [
      {
        "service": "rbac.authorization.k8s.io",
        "resource": "rbac.role",
        "adapter": "k8s.rbac.role.authorization.least_privilege_check",
        "rule_prefix": "k8s.rbac.role.authorization",
        "resource_type": "rbac.role",
        "k8s_resources": [
          "Role",
          "ClusterRole"
        ],
        "validation_method": "kubectl get roles, kubectl get clusterroles",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "rbac.authorization.k8s.io",
        "resource": "rbac.role_binding",
        "adapter": "k8s.rbac.role_binding.authorization.subject_validation",
        "rule_prefix": "k8s.rbac.role_binding.authorization",
        "resource_type": "rbac.role_binding",
        "k8s_resources": [
          "RoleBinding",
          "ClusterRoleBinding"
        ],
        "validation_method": "kubectl get rolebindings, kubectl get clusterrolebindings",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "api.admission_controller",
        "adapter": "k8s.core.admission_controller.authorization.status_check",
        "rule_prefix": "k8s.core.admission_controller.authorization",
        "resource_type": "api.admission_controller",
        "k8s_resources": [
          "AdmissionController"
        ],
        "validation_method": "kubectl get validatingwebhookconfigurations, kubectl get mutatingwebhookconfigurations",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "identity_access.rbac_policies": [
      {
        "service": "rbac.authorization.k8s.io",
        "resource": "rbac.cluster_role",
        "adapter": "k8s.rbac.cluster_role.policy.policies_check",
        "rule_prefix": "k8s.rbac.cluster_role.policy",
        "resource_type": "rbac.cluster_role",
        "k8s_resources": [
          "ClusterRole"
        ],
        "validation_method": "kubectl describe clusterrole",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "rbac.authorization.k8s.io",
        "resource": "rbac.cluster_role_binding",
        "adapter": "k8s.rbac.cluster_role_binding.policy.policies_check",
        "rule_prefix": "k8s.rbac.cluster_role_binding.policy",
        "resource_type": "rbac.cluster_role_binding",
        "k8s_resources": [
          "ClusterRoleBinding"
        ],
        "validation_method": "kubectl describe clusterrolebinding",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "identity_access.service_account_management": [
      {
        "service": "core",
        "resource": "pod.pod",
        "adapter": "k8s.core.pod.serviceaccount.security_context_validation",
        "rule_prefix": "k8s.core.pod.serviceaccount",
        "resource_type": "pod.pod",
        "k8s_resources": [
          "Pod"
        ],
        "validation_method": "kubectl get pods -o yaml | grep serviceAccount",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "identity_access.cluster_admin_restrictions": [
      {
        "service": "rbac.authorization.k8s.io",
        "resource": "rbac.cluster_role_binding",
        "adapter": "k8s.rbac.cluster_role_binding.admin.admin_check",
        "rule_prefix": "k8s.rbac.cluster_role_binding.admin",
        "resource_type": "rbac.cluster_role_binding",
        "k8s_resources": [
          "ClusterRoleBinding"
        ],
        "validation_method": "kubectl get clusterrolebindings | grep cluster-admin",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "pod_container_security.image_security": [
      {
        "service": "core",
        "resource": "container.container",
        "adapter": "k8s.core.container.image.image_digest_validation",
        "rule_prefix": "k8s.core.container.image",
        "resource_type": "container.container",
        "k8s_resources": [
          "Pod",
          "Deployment",
          "DaemonSet",
          "StatefulSet"
        ],
        "validation_method": "kubectl get pods -o yaml | grep image",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "admissionregistration.k8s.io",
        "resource": "admission.validating_webhook",
        "adapter": "k8s.admission.validating_webhook.validation.status_check",
        "rule_prefix": "k8s.admission.validating_webhook.validation",
        "resource_type": "admission.validating_webhook",
        "k8s_resources": [
          "ValidatingAdmissionWebhook"
        ],
        "validation_method": "kubectl get validatingwebhookconfigurations",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "pod_container_security.runtime_security": [
      {
        "service": "core",
        "resource": "infrastructure.node",
        "adapter": "k8s.core.node.runtime.runtime_security_check",
        "rule_prefix": "k8s.core.node.runtime",
        "resource_type": "infrastructure.node",
        "k8s_resources": [
          "Node"
        ],
        "validation_method": "kubectl get nodes -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "pod_container_security.pod_security_standards": [
      {
        "service": "core",
        "resource": "compliance.namespace",
        "adapter": "k8s.core.namespace.pod_security.pod_security_check",
        "rule_prefix": "k8s.core.namespace.pod_security",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Namespace"
        ],
        "validation_method": "kubectl get namespace -o yaml | grep pod-security",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "pod_container_security.workload_security": [
      {
        "service": "core",
        "resource": "pod.pod",
        "adapter": "k8s.core.pod.workload.resource_limits",
        "rule_prefix": "k8s.core.pod.workload",
        "resource_type": "pod.pod",
        "k8s_resources": [
          "Pod"
        ],
        "validation_method": "kubectl get pods -o yaml | grep securityContext",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "pod_container_security.privilege_escalation_prevention": [
      {
        "service": "core",
        "resource": "container.security_context",
        "adapter": "k8s.core.security_context.privilege_control.privilege_escalation_check",
        "rule_prefix": "k8s.core.security_context.privilege_control",
        "resource_type": "container.security_context",
        "k8s_resources": [
          "Pod"
        ],
        "validation_method": "kubectl get pods -o yaml | grep allowPrivilegeEscalation",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "network_security.network_policies": [
      {
        "service": "networking.k8s.io",
        "resource": "network.network_policy",
        "adapter": "k8s.networking.network_policy.networkpolicy.default_deny",
        "rule_prefix": "k8s.networking.network_policy.networkpolicy",
        "resource_type": "network.network_policy",
        "k8s_resources": [
          "NetworkPolicy"
        ],
        "validation_method": "kubectl get networkpolicies",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "network_security.ingress_security": [
      {
        "service": "networking.k8s.io",
        "resource": "network.ingress",
        "adapter": "k8s.networking.ingress.security.tls_termination",
        "rule_prefix": "k8s.networking.ingress.security",
        "resource_type": "network.ingress",
        "k8s_resources": [
          "Ingress"
        ],
        "validation_method": "kubectl get ingress -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "network_security.service_mesh_security": [
      {
        "service": "networking.k8s.io",
        "resource": "network.service",
        "adapter": "k8s.networking.service.service_mesh.mesh_security_check",
        "rule_prefix": "k8s.networking.service.service_mesh",
        "resource_type": "network.service",
        "k8s_resources": [
          "Service"
        ],
        "validation_method": "kubectl get services -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "network_security.dns_security": [
      {
        "service": "core",
        "resource": "network.service",
        "adapter": "k8s.core.service.dns_security.dns_security_check",
        "rule_prefix": "k8s.core.service.dns_security",
        "resource_type": "network.service",
        "k8s_resources": [
          "Service"
        ],
        "validation_method": "kubectl get services -n kube-system | grep dns",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "network_security.egress_controls": [
      {
        "service": "networking.k8s.io",
        "resource": "network.endpoint",
        "adapter": "k8s.networking.endpoint.egress_control.egress_check",
        "rule_prefix": "k8s.networking.endpoint.egress_control",
        "resource_type": "network.endpoint",
        "k8s_resources": [
          "Endpoints"
        ],
        "validation_method": "kubectl get endpoints",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "secrets_config_mgmt.secret_storage": [
      {
        "service": "core",
        "resource": "secret.secret",
        "adapter": "k8s.core.secret.storage.encryption_at_rest",
        "rule_prefix": "k8s.core.secret.storage",
        "resource_type": "secret.secret",
        "k8s_resources": [
          "Secret"
        ],
        "validation_method": "kubectl get secrets",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "etcd.etcd",
        "adapter": "k8s.core.etcd.secret_encryption.client_cert_auth",
        "rule_prefix": "k8s.core.etcd.secret_encryption",
        "resource_type": "etcd.etcd",
        "k8s_resources": [
          "ConfigMap"
        ],
        "validation_method": "kubectl get configmap -n kube-system kube-apiserver",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "secrets_config_mgmt.key_rotation": [
      {
        "service": "core",
        "resource": "secret.secret",
        "adapter": "k8s.core.secret.rotation.automated_rotation",
        "rule_prefix": "k8s.core.secret.rotation",
        "resource_type": "secret.secret",
        "k8s_resources": [
          "Secret"
        ],
        "validation_method": "kubectl get secrets -o yaml | grep creationTimestamp",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "external-secrets.io",
        "resource": "secret.external_secret",
        "adapter": "k8s.external_secrets.external_secret.rotation.rotation_check",
        "rule_prefix": "k8s.external_secrets.external_secret.rotation",
        "resource_type": "secret.external_secret",
        "k8s_resources": [
          "ExternalSecret"
        ],
        "validation_method": "kubectl get externalsecrets",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "secrets_config_mgmt.secret_sprawl": [
      {
        "service": "core",
        "resource": "config.configmap",
        "adapter": "k8s.core.configmap.secret_sprawl.secret_sprawl_check",
        "rule_prefix": "k8s.core.configmap.secret_sprawl",
        "resource_type": "config.configmap",
        "k8s_resources": [
          "ConfigMap"
        ],
        "validation_method": "kubectl get configmaps --all-namespaces",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "secrets_config_mgmt.external_secrets": [
      {
        "service": "external-secrets.io",
        "resource": "secret.external_secret",
        "adapter": "k8s.external_secrets.external_secret.external_secret.status_check",
        "rule_prefix": "k8s.external_secrets.external_secret.external_secret",
        "resource_type": "secret.external_secret",
        "k8s_resources": [
          "ExternalSecret",
          "SecretStore"
        ],
        "validation_method": "kubectl get externalsecrets, kubectl get secretstores",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "cluster_component_security.etcd_security": [
      {
        "service": "core",
        "resource": "etcd.backup",
        "adapter": "k8s.core.backup.backup.backup_security_check",
        "rule_prefix": "k8s.core.backup.backup",
        "resource_type": "etcd.backup",
        "k8s_resources": [
          "Pod",
          "Job",
          "CronJob"
        ],
        "validation_method": "kubectl get pods,jobs,cronjobs -n kube-system | grep etcd",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "cluster_component_security.control_plane_security": [
      {
        "service": "core",
        "resource": "scheduler.scheduler",
        "adapter": "k8s.core.scheduler.security.security_check",
        "rule_prefix": "k8s.core.scheduler.security",
        "resource_type": "scheduler.scheduler",
        "k8s_resources": [
          "Pod"
        ],
        "validation_method": "kubectl get pods -n kube-system | grep scheduler",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "controller.controller_manager",
        "adapter": "k8s.core.controller_manager.security.security_check",
        "rule_prefix": "k8s.core.controller_manager.security",
        "resource_type": "controller.controller_manager",
        "k8s_resources": [
          "Pod"
        ],
        "validation_method": "kubectl get pods -n kube-system | grep controller-manager",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "cluster_component_security.kubelet_security": [
      {
        "service": "core",
        "resource": "kubelet.kubelet",
        "adapter": "k8s.core.kubelet.security.security_check",
        "rule_prefix": "k8s.core.kubelet.security",
        "resource_type": "kubelet.kubelet",
        "k8s_resources": [
          "Node"
        ],
        "validation_method": "kubectl get nodes -o yaml | grep kubelet",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "cluster_component_security.kube_proxy_security": [
      {
        "service": "core",
        "resource": "kube_proxy.kube_proxy",
        "adapter": "k8s.core.kube_proxy.security.security_check",
        "rule_prefix": "k8s.core.kube_proxy.security",
        "resource_type": "kube_proxy.kube_proxy",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods,daemonsets -n kube-system | grep kube-proxy",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "admission_policy_enforcement.admission_control": [
      {
        "service": "admissionregistration.k8s.io",
        "resource": "api.admission_controller",
        "adapter": "k8s.admission.admission_controller.control.status_check",
        "rule_prefix": "k8s.admission.admission_controller.control",
        "resource_type": "api.admission_controller",
        "k8s_resources": [
          "ValidatingAdmissionWebhook",
          "MutatingAdmissionWebhook"
        ],
        "validation_method": "kubectl get validatingwebhookconfigurations, kubectl get mutatingwebhookconfigurations",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "admission_policy_enforcement.validating_admission_webhooks": [
      {
        "service": "admissionregistration.k8s.io",
        "resource": "admission.validating_webhook",
        "adapter": "k8s.admission.validating_webhook.validating_webhook.status_check",
        "rule_prefix": "k8s.admission.validating_webhook.validating_webhook",
        "resource_type": "admission.validating_webhook",
        "k8s_resources": [
          "ValidatingAdmissionWebhook"
        ],
        "validation_method": "kubectl get validatingwebhookconfigurations",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "admission_policy_enforcement.mutating_admission_webhooks": [
      {
        "service": "admissionregistration.k8s.io",
        "resource": "admission.mutating_webhook",
        "adapter": "k8s.admission.mutating_webhook.mutating_webhook.status_check",
        "rule_prefix": "k8s.admission.mutating_webhook.mutating_webhook",
        "resource_type": "admission.mutating_webhook",
        "k8s_resources": [
          "MutatingAdmissionWebhook"
        ],
        "validation_method": "kubectl get mutatingwebhookconfigurations",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "admission_policy_enforcement.opa_gatekeeper": [
      {
        "service": "constraints.gatekeeper.sh",
        "resource": "admission.opa_constraint",
        "adapter": "k8s.gatekeeper.opa_constraint.constraint.status_check",
        "rule_prefix": "k8s.gatekeeper.opa_constraint.constraint",
        "resource_type": "admission.opa_constraint",
        "k8s_resources": [
          "ConstraintTemplate",
          "K8sRequiredLabels",
          "K8sRequiredAnnotations"
        ],
        "validation_method": "kubectl get constrainttemplates, kubectl get k8srequiredlabels",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "admission_policy_enforcement.kyverno_policies": [
      {
        "service": "kyverno.io",
        "resource": "admission.kyverno_policy",
        "adapter": "k8s.kyverno.kyverno_policy.policy.status_check",
        "rule_prefix": "k8s.kyverno.kyverno_policy.policy",
        "resource_type": "admission.kyverno_policy",
        "k8s_resources": [
          "ClusterPolicy",
          "Policy"
        ],
        "validation_method": "kubectl get clusterpolicies, kubectl get policies",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "storage_security.persistent_volume_security": [
      {
        "service": "core",
        "resource": "storage.persistent_volume",
        "adapter": "k8s.core.persistent_volume.security.access_modes",
        "rule_prefix": "k8s.core.persistent_volume.security",
        "resource_type": "storage.persistent_volume",
        "k8s_resources": [
          "PersistentVolume"
        ],
        "validation_method": "kubectl get persistentvolumes",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "storage.persistent_volume_claim",
        "adapter": "k8s.core.persistent_volume_claim.security.security_check",
        "rule_prefix": "k8s.core.persistent_volume_claim.security",
        "resource_type": "storage.persistent_volume_claim",
        "k8s_resources": [
          "PersistentVolumeClaim"
        ],
        "validation_method": "kubectl get persistentvolumeclaims",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "storage.k8s.io",
        "resource": "storage.storage_class",
        "adapter": "k8s.storage.storage_class.security.security_check",
        "rule_prefix": "k8s.storage.storage_class.security",
        "resource_type": "storage.storage_class",
        "k8s_resources": [
          "StorageClass"
        ],
        "validation_method": "kubectl get storageclasses",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "storage_security.volume_mount_security": [
      {
        "service": "core",
        "resource": "storage.persistent_volume_claim",
        "adapter": "k8s.core.persistent_volume_claim.mount.mount_security_check",
        "rule_prefix": "k8s.core.persistent_volume_claim.mount",
        "resource_type": "storage.persistent_volume_claim",
        "k8s_resources": [
          "PersistentVolumeClaim"
        ],
        "validation_method": "kubectl get persistentvolumeclaims -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "storage_security.storage_encryption": [
      {
        "service": "storage.k8s.io",
        "resource": "storage.storage_class",
        "adapter": "k8s.storage.storage_class.encryption.encryption_check",
        "rule_prefix": "k8s.storage.storage_class.encryption",
        "resource_type": "storage.storage_class",
        "k8s_resources": [
          "StorageClass"
        ],
        "validation_method": "kubectl get storageclasses -o yaml | grep encryption",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "storage_security.storage_access_controls": [
      {
        "service": "storage.k8s.io",
        "resource": "storage.storage_class",
        "adapter": "k8s.storage.storage_class.access.access_controls_check",
        "rule_prefix": "k8s.storage.storage_class.access",
        "resource_type": "storage.storage_class",
        "k8s_resources": [
          "StorageClass"
        ],
        "validation_method": "kubectl get storageclasses -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "monitoring_observability.audit_logging": [
      {
        "service": "core",
        "resource": "monitoring.audit_log",
        "adapter": "k8s.core.audit_log.audit_logging.policy_enforcement",
        "rule_prefix": "k8s.core.audit_log.audit_logging",
        "resource_type": "monitoring.audit_log",
        "k8s_resources": [
          "ConfigMap"
        ],
        "validation_method": "kubectl get configmap -n kube-system kube-apiserver",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "monitoring_observability.log_collection": [
      {
        "service": "core",
        "resource": "monitoring.logs",
        "adapter": "k8s.core.logs.log_collection.status_check",
        "rule_prefix": "k8s.core.logs.log_collection",
        "resource_type": "monitoring.logs",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods,daemonsets -n kube-system | grep logging",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "monitoring_observability.monitoring_alerting": [
      {
        "service": "monitoring.coreos.com",
        "resource": "monitoring.metrics",
        "adapter": "k8s.monitoring.metrics.prometheus.status_check",
        "rule_prefix": "k8s.monitoring.metrics.prometheus",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "ServiceMonitor",
          "PrometheusRule"
        ],
        "validation_method": "kubectl get servicemonitors, kubectl get prometheusrules",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "monitoring_observability.log_retention": [
      {
        "service": "core",
        "resource": "monitoring.logs",
        "adapter": "k8s.core.logs.log_retention.status_check",
        "rule_prefix": "k8s.core.logs.log_retention",
        "resource_type": "monitoring.logs",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods,daemonsets -n kube-system | grep logging",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "monitoring_observability.log_analysis": [
      {
        "service": "monitoring.coreos.com",
        "resource": "monitoring.metrics",
        "adapter": "k8s.monitoring.metrics.log_analysis.status_check",
        "rule_prefix": "k8s.monitoring.metrics.log_analysis",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "ServiceMonitor",
          "PrometheusRule"
        ],
        "validation_method": "kubectl get servicemonitors, kubectl get prometheusrules",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "workload_security.deployment_security": [
      {
        "service": "apps",
        "resource": "workload.deployment",
        "adapter": "k8s.apps.deployment.security.security_check",
        "rule_prefix": "k8s.apps.deployment.security",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "Deployment",
          "ReplicaSet"
        ],
        "validation_method": "kubectl get deployments,replicasets",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "workload_security.daemonset_security": [
      {
        "service": "apps",
        "resource": "workload.daemonset",
        "adapter": "k8s.apps.daemonset.security.security_check",
        "rule_prefix": "k8s.apps.daemonset.security",
        "resource_type": "workload.daemonset",
        "k8s_resources": [
          "DaemonSet"
        ],
        "validation_method": "kubectl get daemonsets",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "workload_security.statefulset_security": [
      {
        "service": "apps",
        "resource": "workload.statefulset",
        "adapter": "k8s.apps.statefulset.security.security_check",
        "rule_prefix": "k8s.apps.statefulset.security",
        "resource_type": "workload.statefulset",
        "k8s_resources": [
          "StatefulSet"
        ],
        "validation_method": "kubectl get statefulsets",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "workload_security.cronjob_security": [
      {
        "service": "batch",
        "resource": "workload.cronjob",
        "adapter": "k8s.batch.cronjob.security.security_check",
        "rule_prefix": "k8s.batch.cronjob.security",
        "resource_type": "workload.cronjob",
        "k8s_resources": [
          "CronJob"
        ],
        "validation_method": "kubectl get cronjobs",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "workload_security.job_security": [
      {
        "service": "batch",
        "resource": "workload.job",
        "adapter": "k8s.batch.job.security.security_check",
        "rule_prefix": "k8s.batch.job.security",
        "resource_type": "workload.job",
        "k8s_resources": [
          "Job"
        ],
        "validation_method": "kubectl get jobs",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "infrastructure_security.node_security": [
      {
        "service": "core",
        "resource": "infrastructure.node",
        "adapter": "k8s.core.node.security.security_check",
        "rule_prefix": "k8s.core.node.security",
        "resource_type": "infrastructure.node",
        "k8s_resources": [
          "Node"
        ],
        "validation_method": "kubectl get nodes -o yaml",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "infrastructure_security.container_runtime_security": [
      {
        "service": "core",
        "resource": "infrastructure.container_runtime",
        "adapter": "k8s.core.container_runtime.security.security_check",
        "rule_prefix": "k8s.core.container_runtime.security",
        "resource_type": "infrastructure.container_runtime",
        "k8s_resources": [
          "Node",
          "RuntimeClass"
        ],
        "validation_method": "kubectl get nodes -o yaml | grep containerRuntime",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "infrastructure_security.cni_security": [
      {
        "service": "core",
        "resource": "infrastructure.cni",
        "adapter": "k8s.core.cni.security.security_check",
        "rule_prefix": "k8s.core.cni.security",
        "resource_type": "infrastructure.cni",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods,daemonsets -n kube-system | grep cni",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "infrastructure_security.csi_security": [
      {
        "service": "core",
        "resource": "infrastructure.csi",
        "adapter": "k8s.core.csi.security.security_check",
        "rule_prefix": "k8s.core.csi.security",
        "resource_type": "infrastructure.csi",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods,daemonsets -n kube-system | grep csi",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "compliance_governance.namespace_governance": [
      {
        "service": "core",
        "resource": "compliance.namespace",
        "adapter": "k8s.core.namespace.governance.governance_check",
        "rule_prefix": "k8s.core.namespace.governance",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Namespace"
        ],
        "validation_method": "kubectl get namespaces",
        "not_applicable_when": "resource_not_configured"
      },
      {
        "service": "core",
        "resource": "compliance.resource_quota",
        "adapter": "k8s.core.resource_quota.governance.governance_check",
        "rule_prefix": "k8s.core.resource_quota.governance",
        "resource_type": "compliance.resource_quota",
        "k8s_resources": [
          "ResourceQuota"
        ],
        "validation_method": "kubectl get resourcequotas",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "compliance_governance.resource_governance": [
      {
        "service": "core",
        "resource": "compliance.limit_range",
        "adapter": "k8s.core.limit_range.governance.governance_check",
        "rule_prefix": "k8s.core.limit_range.governance",
        "resource_type": "compliance.limit_range",
        "k8s_resources": [
          "LimitRange"
        ],
        "validation_method": "kubectl get limitranges",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "compliance_governance.compliance_frameworks": [
      {
        "service": "core",
        "resource": "compliance.namespace",
        "adapter": "k8s.core.namespace.compliance.compliance_check",
        "rule_prefix": "k8s.core.namespace.compliance",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Namespace"
        ],
        "validation_method": "kubectl get namespaces -o yaml | grep labels",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "compliance_governance.drift_detection": [
      {
        "service": "core",
        "resource": "compliance.pod_security_policy",
        "adapter": "k8s.core.pod_security_policy.drift.drift_check",
        "rule_prefix": "k8s.core.pod_security_policy.drift",
        "resource_type": "compliance.pod_security_policy",
        "k8s_resources": [
          "PodSecurityPolicy"
        ],
        "validation_method": "kubectl get podsecuritypolicies",
        "not_applicable_when": "resource_not_configured"
      }
    ],
    "zero_trust_security.zero_trust_networking": [
      {
        "service": "networking.k8s.io",
        "resource": "zero_trust.network_segmentation",
        "adapter": "k8s.networking.network_segmentation.zero_trust.micro_segmentation_status",
        "rule_prefix": "k8s.networking.network_segmentation.zero_trust",
        "resource_type": "zero_trust.network_segmentation",
        "k8s_resources": [
          "NetworkPolicy",
          "Namespace"
        ],
        "validation_method": "kubectl get networkpolicies --all-namespaces, kubectl get namespaces",
        "not_applicable_when": "no_network_policies_configured"
      },
      {
        "service": "networking.k8s.io",
        "resource": "zero_trust.network_segmentation",
        "adapter": "k8s.networking.network_segmentation.default_deny.default_deny_enforcement",
        "rule_prefix": "k8s.networking.network_segmentation.default_deny",
        "resource_type": "zero_trust.network_segmentation",
        "k8s_resources": [
          "NetworkPolicy"
        ],
        "validation_method": "kubectl get networkpolicies -o yaml",
        "not_applicable_when": "no_network_policies_configured"
      }
    ],
    "zero_trust_security.service_to_service_encryption": [
      {
        "service": "networking.k8s.io",
        "resource": "zero_trust.service_mesh",
        "adapter": "k8s.networking.service_mesh.mtls.mtls_enforcement_status",
        "rule_prefix": "k8s.networking.service_mesh.mtls",
        "resource_type": "zero_trust.service_mesh",
        "k8s_resources": [
          "Service",
          "ConfigMap",
          "Secret"
        ],
        "validation_method": "kubectl get services, kubectl get configmaps, kubectl get secrets",
        "not_applicable_when": "no_service_mesh_configured"
      },
      {
        "service": "networking.k8s.io",
        "resource": "zero_trust.service_mesh",
        "adapter": "k8s.networking.service_mesh.mtls.mtls_policy_validation",
        "rule_prefix": "k8s.networking.service_mesh.mtls",
        "resource_type": "zero_trust.service_mesh",
        "k8s_resources": [
          "PeerAuthentication",
          "DestinationRule"
        ],
        "validation_method": "kubectl get peerauthentications, kubectl get destinationrules",
        "not_applicable_when": "istio_not_installed"
      }
    ],
    "data_protection.data_loss_prevention": [
      {
        "service": "security.k8s.io",
        "resource": "data.dlp",
        "adapter": "k8s.security.dlp.dlp.dlp_policy_enforcement",
        "rule_prefix": "k8s.security.dlp.dlp",
        "resource_type": "data.dlp",
        "k8s_resources": [
          "NetworkPolicy",
          "Pod"
        ],
        "validation_method": "kubectl get networkpolicies, kubectl get pods",
        "not_applicable_when": "no_dlp_policies_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "data.dlp",
        "adapter": "k8s.security.dlp.dlp.data_exfiltration_prevention",
        "rule_prefix": "k8s.security.dlp.dlp",
        "resource_type": "data.dlp",
        "k8s_resources": [
          "Pod",
          "NetworkPolicy"
        ],
        "validation_method": "kubectl get pods, kubectl get networkpolicies",
        "not_applicable_when": "no_dlp_policies_configured"
      }
    ],
    "incident_response.threat_hunting": [
      {
        "service": "security.k8s.io",
        "resource": "incident.forensics",
        "adapter": "k8s.security.forensics.hunting.threat_hunting_enabled",
        "rule_prefix": "k8s.security.forensics.hunting",
        "resource_type": "incident.forensics",
        "k8s_resources": [
          "Event",
          "Pod"
        ],
        "validation_method": "kubectl get events, kubectl get pods",
        "not_applicable_when": "no_events_collected"
      },
      {
        "service": "security.k8s.io",
        "resource": "incident.forensics",
        "adapter": "k8s.security.forensics.behavior.behavioral_analysis_tools",
        "rule_prefix": "k8s.security.forensics.behavior",
        "resource_type": "incident.forensics",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods, kubectl get daemonsets",
        "not_applicable_when": "no_behavioral_analysis"
      }
    ],
    "zero_trust_security.continuous_verification": [
      {
        "service": "security.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.security.deployment.identity.identity_verification_status",
        "rule_prefix": "k8s.security.deployment.identity",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "Deployment",
          "ServiceAccount"
        ],
        "validation_method": "kubectl get deployments, kubectl get serviceaccounts",
        "not_applicable_when": "no_deployments_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "identity.service_account",
        "adapter": "k8s.security.service_account.token.token_binding_validation",
        "rule_prefix": "k8s.security.service_account.token",
        "resource_type": "identity.service_account",
        "k8s_resources": [
          "ServiceAccount",
          "TokenRequest"
        ],
        "validation_method": "kubectl get serviceaccounts, kubectl get tokenrequests",
        "not_applicable_when": "no_service_accounts_configured"
      }
    ],
    "zero_trust_security.micro_segmentation": [
      {
        "service": "networking.k8s.io",
        "resource": "network.network_policy",
        "adapter": "k8s.networking.network_policy.pod_segment.pod_level_segmentation",
        "rule_prefix": "k8s.networking.network_policy.pod_segment",
        "resource_type": "network.network_policy",
        "k8s_resources": [
          "NetworkPolicy",
          "Pod"
        ],
        "validation_method": "kubectl get networkpolicies, kubectl get pods",
        "not_applicable_when": "no_network_policies_configured"
      },
      {
        "service": "networking.k8s.io",
        "resource": "network.network_policy",
        "adapter": "k8s.networking.network_policy.namespace.namespace_isolation_status",
        "rule_prefix": "k8s.networking.network_policy.namespace",
        "resource_type": "network.network_policy",
        "k8s_resources": [
          "NetworkPolicy",
          "Namespace"
        ],
        "validation_method": "kubectl get networkpolicies --all-namespaces",
        "not_applicable_when": "no_network_policies_configured"
      }
    ],
    "data_protection.privacy_controls": [
      {
        "service": "security.k8s.io",
        "resource": "privacy.gdpr",
        "adapter": "k8s.security.gdpr.gdpr.gdpr_compliance_status",
        "rule_prefix": "k8s.security.gdpr.gdpr",
        "resource_type": "privacy.gdpr",
        "k8s_resources": [
          "Secret",
          "ConfigMap"
        ],
        "validation_method": "kubectl get secrets, kubectl get configmaps",
        "not_applicable_when": "no_sensitive_data_processed"
      },
      {
        "service": "security.k8s.io",
        "resource": "privacy.gdpr",
        "adapter": "k8s.security.gdpr.retention.data_retention_policy",
        "rule_prefix": "k8s.security.gdpr.retention",
        "resource_type": "privacy.gdpr",
        "k8s_resources": [
          "Pod",
          "PersistentVolume"
        ],
        "validation_method": "kubectl get pods, kubectl get persistentvolumes",
        "not_applicable_when": "no_persistent_data_stored"
      }
    ],
    "data_protection.data_classification": [
      {
        "service": "security.k8s.io",
        "resource": "data.classification",
        "adapter": "k8s.security.classification.classification.data_classification_labels",
        "rule_prefix": "k8s.security.classification.classification",
        "resource_type": "data.classification",
        "k8s_resources": [
          "Secret",
          "ConfigMap"
        ],
        "validation_method": "kubectl get secrets --show-labels, kubectl get configmaps --show-labels",
        "not_applicable_when": "no_classified_data"
      },
      {
        "service": "security.k8s.io",
        "resource": "data.classification",
        "adapter": "k8s.security.classification.sensitivity.sensitivity_label_validation",
        "rule_prefix": "k8s.security.classification.sensitivity",
        "resource_type": "data.classification",
        "k8s_resources": [
          "Pod",
          "Namespace"
        ],
        "validation_method": "kubectl get pods --show-labels, kubectl get namespaces --show-labels",
        "not_applicable_when": "no_sensitivity_labels"
      }
    ],
    "data_protection.cross_border_transfer": [
      {
        "service": "security.k8s.io",
        "resource": "data.classification",
        "adapter": "k8s.security.classification.geo.geographic_location_validation",
        "rule_prefix": "k8s.security.classification.geo",
        "resource_type": "data.classification",
        "k8s_resources": [
          "Node",
          "Namespace"
        ],
        "validation_method": "kubectl get nodes --show-labels, kubectl get namespaces",
        "not_applicable_when": "no_geographic_restrictions"
      },
      {
        "service": "security.k8s.io",
        "resource": "data.classification",
        "adapter": "k8s.security.classification.residency.data_residency_check",
        "rule_prefix": "k8s.security.classification.residency",
        "resource_type": "data.classification",
        "k8s_resources": [
          "PersistentVolume",
          "StorageClass"
        ],
        "validation_method": "kubectl get persistentvolumes, kubectl get storageclasses",
        "not_applicable_when": "no_persistent_storage"
      }
    ],
    "incident_response.automated_response": [
      {
        "service": "security.k8s.io",
        "resource": "incident.automation",
        "adapter": "k8s.security.automation.automation.automated_response_enabled",
        "rule_prefix": "k8s.security.automation.automation",
        "resource_type": "incident.automation",
        "k8s_resources": [
          "Event",
          "Pod"
        ],
        "validation_method": "kubectl get events, kubectl get pods",
        "not_applicable_when": "no_incident_response_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "incident.automation",
        "adapter": "k8s.security.automation.playbook.security_playbook_execution",
        "rule_prefix": "k8s.security.automation.playbook",
        "resource_type": "incident.automation",
        "k8s_resources": [
          "Pod",
          "Job"
        ],
        "validation_method": "kubectl get pods, kubectl get jobs",
        "not_applicable_when": "no_automated_playbooks"
      }
    ],
    "incident_response.forensic_capabilities": [
      {
        "service": "security.k8s.io",
        "resource": "incident.forensics",
        "adapter": "k8s.security.forensics.forensics.forensic_data_collection",
        "rule_prefix": "k8s.security.forensics.forensics",
        "resource_type": "incident.forensics",
        "k8s_resources": [
          "Pod",
          "PersistentVolume"
        ],
        "validation_method": "kubectl get pods, kubectl get persistentvolumes",
        "not_applicable_when": "no_forensic_tools_installed"
      },
      {
        "service": "security.k8s.io",
        "resource": "incident.forensics",
        "adapter": "k8s.security.forensics.forensics.forensic_log_preservation",
        "rule_prefix": "k8s.security.forensics.forensics",
        "resource_type": "incident.forensics",
        "k8s_resources": [
          "ConfigMap",
          "Secret"
        ],
        "validation_method": "kubectl get configmaps, kubectl get secrets",
        "not_applicable_when": "no_audit_logging_enabled"
      }
    ],
    "incident_response.security_orchestration": [
      {
        "service": "security.k8s.io",
        "resource": "incident.automation",
        "adapter": "k8s.security.automation.orchestration.security_orchestration_status",
        "rule_prefix": "k8s.security.automation.orchestration",
        "resource_type": "incident.automation",
        "k8s_resources": [
          "Pod",
          "Job"
        ],
        "validation_method": "kubectl get pods, kubectl get jobs",
        "not_applicable_when": "no_orchestration_tools"
      },
      {
        "service": "security.k8s.io",
        "resource": "incident.automation",
        "adapter": "k8s.security.automation.automation.security_response_automation",
        "rule_prefix": "k8s.security.automation.automation",
        "resource_type": "incident.automation",
        "k8s_resources": [
          "Service",
          "ConfigMap"
        ],
        "validation_method": "kubectl get services, kubectl get configmaps",
        "not_applicable_when": "no_automation_configured"
      }
    ],
    "identity_access.multi_factor_authentication": [
      {
        "service": "security.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.security.user.mfa.mfa_enforcement_status",
        "rule_prefix": "k8s.security.user.mfa",
        "resource_type": "identity.user",
        "k8s_resources": [
          "User",
          "ConfigMap"
        ],
        "validation_method": "kubectl get users, kubectl get configmaps",
        "not_applicable_when": "no_external_auth_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.security.user.oidc.oidc_mfa_validation",
        "rule_prefix": "k8s.security.user.oidc",
        "resource_type": "identity.user",
        "k8s_resources": [
          "ConfigMap",
          "Secret"
        ],
        "validation_method": "kubectl get configmaps, kubectl get secrets",
        "not_applicable_when": "no_oidc_configured"
      }
    ],
    "identity_access.certificate_lifecycle": [
      {
        "service": "security.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.security.user.rotation.rotation_policy_status",
        "rule_prefix": "k8s.security.user.rotation",
        "resource_type": "identity.user",
        "k8s_resources": [
          "CertificateSigningRequest",
          "Secret"
        ],
        "validation_method": "kubectl get csr, kubectl get secrets",
        "not_applicable_when": "no_certificates_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.security.user.expiry.expiry_monitoring",
        "rule_prefix": "k8s.security.user.expiry",
        "resource_type": "identity.user",
        "k8s_resources": [
          "CertificateSigningRequest",
          "Pod"
        ],
        "validation_method": "kubectl get csr, kubectl get pods",
        "not_applicable_when": "no_certificates_configured"
      }
    ],
    "identity_access.emergency_access": [
      {
        "service": "security.k8s.io",
        "resource": "rbac.cluster_role_binding",
        "adapter": "k8s.security.cluster_role_binding.emergency.emergency_access_controls",
        "rule_prefix": "k8s.security.cluster_role_binding.emergency",
        "resource_type": "rbac.cluster_role_binding",
        "k8s_resources": [
          "ClusterRoleBinding",
          "ConfigMap"
        ],
        "validation_method": "kubectl get clusterrolebindings, kubectl get configmaps",
        "not_applicable_when": "no_emergency_access_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "rbac.cluster_role_binding",
        "adapter": "k8s.security.cluster_role_binding.break_glass.break_glass_audit",
        "rule_prefix": "k8s.security.cluster_role_binding.break_glass",
        "resource_type": "rbac.cluster_role_binding",
        "k8s_resources": [
          "ClusterRoleBinding",
          "Event"
        ],
        "validation_method": "kubectl get clusterrolebindings, kubectl get events",
        "not_applicable_when": "no_emergency_access_configured"
      }
    ],
    "pod_container_security.supply_chain_security": [
      {
        "service": "security.k8s.io",
        "resource": "container.container",
        "adapter": "k8s.security.container.signing.image_signing_validation",
        "rule_prefix": "k8s.security.container.signing",
        "resource_type": "container.container",
        "k8s_resources": [
          "Pod",
          "ConfigMap"
        ],
        "validation_method": "kubectl get pods, kubectl get configmaps",
        "not_applicable_when": "no_image_signing_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "container.container",
        "adapter": "k8s.security.container.vuln.vulnerability_scanning_status",
        "rule_prefix": "k8s.security.container.vuln",
        "resource_type": "container.container",
        "k8s_resources": [
          "Pod",
          "Job"
        ],
        "validation_method": "kubectl get pods, kubectl get jobs",
        "not_applicable_when": "no_vulnerability_scanning"
      }
    ],
    "pod_container_security.behavioral_analysis": [
      {
        "service": "security.k8s.io",
        "resource": "infrastructure.node",
        "adapter": "k8s.security.node.falco.falco_runtime_monitoring",
        "rule_prefix": "k8s.security.node.falco",
        "resource_type": "infrastructure.node",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods, kubectl get daemonsets",
        "not_applicable_when": "falco_not_installed"
      },
      {
        "service": "security.k8s.io",
        "resource": "infrastructure.node",
        "adapter": "k8s.security.node.ebpf.ebpf_security_monitoring",
        "rule_prefix": "k8s.security.node.ebpf",
        "resource_type": "infrastructure.node",
        "k8s_resources": [
          "Pod",
          "DaemonSet"
        ],
        "validation_method": "kubectl get pods, kubectl get daemonsets",
        "not_applicable_when": "ebpf_not_available"
      }
    ],
    "monitoring_observability.threat_detection": [
      {
        "service": "security.k8s.io",
        "resource": "monitoring.metrics",
        "adapter": "k8s.security.metrics.threat.threat_detection_rules",
        "rule_prefix": "k8s.security.metrics.threat",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "PrometheusRule",
          "ServiceMonitor"
        ],
        "validation_method": "kubectl get prometheusrules, kubectl get servicemonitors",
        "not_applicable_when": "prometheus_not_installed"
      },
      {
        "service": "security.k8s.io",
        "resource": "monitoring.metrics",
        "adapter": "k8s.security.metrics.security.security_alerting",
        "rule_prefix": "k8s.security.metrics.security",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "Alertmanager",
          "ConfigMap"
        ],
        "validation_method": "kubectl get alertmanagers, kubectl get configmaps",
        "not_applicable_when": "alertmanager_not_installed"
      }
    ],
    "monitoring_observability.security_monitoring": [
      {
        "service": "security.k8s.io",
        "resource": "monitoring.metrics",
        "adapter": "k8s.security.metrics.security.security_dashboard_status",
        "rule_prefix": "k8s.security.metrics.security",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "ConfigMap",
          "Service"
        ],
        "validation_method": "kubectl get configmaps, kubectl get services",
        "not_applicable_when": "grafana_not_installed"
      },
      {
        "service": "security.k8s.io",
        "resource": "monitoring.metrics",
        "adapter": "k8s.security.metrics.security.security_log_aggregation",
        "rule_prefix": "k8s.security.metrics.security",
        "resource_type": "monitoring.metrics",
        "k8s_resources": [
          "Pod",
          "ConfigMap"
        ],
        "validation_method": "kubectl get pods, kubectl get configmaps",
        "not_applicable_when": "fluentd_not_installed"
      }
    ],
    "monitoring_observability.compliance_reporting": [
      {
        "service": "security.k8s.io",
        "resource": "monitoring.audit_log",
        "adapter": "k8s.security.audit_log.compliance.compliance_reporting_automation",
        "rule_prefix": "k8s.security.audit_log.compliance",
        "resource_type": "monitoring.audit_log",
        "k8s_resources": [
          "Pod",
          "Job"
        ],
        "validation_method": "kubectl get pods, kubectl get jobs",
        "not_applicable_when": "no_compliance_reporting"
      },
      {
        "service": "security.k8s.io",
        "resource": "monitoring.audit_log",
        "adapter": "k8s.security.audit_log.regulatory.regulatory_framework_alignment",
        "rule_prefix": "k8s.security.audit_log.regulatory",
        "resource_type": "monitoring.audit_log",
        "k8s_resources": [
          "ConfigMap",
          "Secret"
        ],
        "validation_method": "kubectl get configmaps, kubectl get secrets",
        "not_applicable_when": "no_regulatory_requirements"
      }
    ],
    "compliance_governance.policy_as_code": [
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.policy.policy_sync_status",
        "rule_prefix": "k8s.security.namespace.policy",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Pod",
          "ConfigMap"
        ],
        "validation_method": "kubectl get pods, kubectl get configmaps",
        "not_applicable_when": "gitops_not_configured"
      },
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.policy.policy_deployment_validation",
        "rule_prefix": "k8s.security.namespace.policy",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Application",
          "ConfigMap"
        ],
        "validation_method": "kubectl get applications, kubectl get configmaps",
        "not_applicable_when": "argocd_not_installed"
      }
    ],
    "compliance_governance.compliance_automation": [
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.remediation.automated_remediation_status",
        "rule_prefix": "k8s.security.namespace.remediation",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Pod",
          "Job"
        ],
        "validation_method": "kubectl get pods, kubectl get jobs",
        "not_applicable_when": "no_automated_remediation"
      },
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.validation.continuous_validation",
        "rule_prefix": "k8s.security.namespace.validation",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Pod",
          "CronJob"
        ],
        "validation_method": "kubectl get pods, kubectl get cronjobs",
        "not_applicable_when": "no_continuous_validation"
      }
    ],
    "compliance_governance.risk_management": [
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.vuln.vulnerability_assessment_status",
        "rule_prefix": "k8s.security.namespace.vuln",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "Pod",
          "ConfigMap"
        ],
        "validation_method": "kubectl get pods, kubectl get configmaps",
        "not_applicable_when": "no_vulnerability_assessment"
      },
      {
        "service": "security.k8s.io",
        "resource": "compliance.namespace",
        "adapter": "k8s.security.namespace.threat.threat_modeling_validation",
        "rule_prefix": "k8s.security.namespace.threat",
        "resource_type": "compliance.namespace",
        "k8s_resources": [
          "ConfigMap",
          "Secret"
        ],
        "validation_method": "kubectl get configmaps, kubectl get secrets",
        "not_applicable_when": "no_threat_modeling"
      }
    ],
    "workload_security.pod_disruption_budget": [
      {
        "service": "policy.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.policy.deployment.availability.availability_protection",
        "rule_prefix": "k8s.policy.deployment.availability",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "PodDisruptionBudget",
          "Deployment"
        ],
        "validation_method": "kubectl get poddisruptionbudgets, kubectl get deployments",
        "not_applicable_when": "no_pod_disruption_budgets"
      },
      {
        "service": "policy.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.policy.deployment.min.min_available_validation",
        "rule_prefix": "k8s.policy.deployment.min",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "PodDisruptionBudget"
        ],
        "validation_method": "kubectl get poddisruptionbudgets -o yaml",
        "not_applicable_when": "no_pod_disruption_budgets"
      }
    ],
    "workload_security.horizontal_pod_autoscaler": [
      {
        "service": "autoscaling.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.autoscaling.deployment.cpu_scaling.cpu_scaling_policy",
        "rule_prefix": "k8s.autoscaling.deployment.cpu_scaling",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "HorizontalPodAutoscaler",
          "Deployment"
        ],
        "validation_method": "kubectl get hpa, kubectl get deployments",
        "not_applicable_when": "no_hpa_configured"
      },
      {
        "service": "autoscaling.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.autoscaling.deployment.memory_scaling.memory_scaling_policy",
        "rule_prefix": "k8s.autoscaling.deployment.memory_scaling",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "HorizontalPodAutoscaler"
        ],
        "validation_method": "kubectl get hpa -o yaml",
        "not_applicable_when": "no_hpa_configured"
      }
    ],
    "identity_access.certificate_signing_request": [
      {
        "service": "certificates.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.certificates.user.approval.approval_workflow",
        "rule_prefix": "k8s.certificates.user.approval",
        "resource_type": "identity.user",
        "k8s_resources": [
          "CertificateSigningRequest"
        ],
        "validation_method": "kubectl get csr",
        "not_applicable_when": "no_csr_configured"
      },
      {
        "service": "certificates.k8s.io",
        "resource": "identity.user",
        "adapter": "k8s.certificates.user.automation.auto_approval_validation",
        "rule_prefix": "k8s.certificates.user.automation",
        "resource_type": "identity.user",
        "k8s_resources": [
          "CertificateSigningRequest",
          "ConfigMap"
        ],
        "validation_method": "kubectl get csr, kubectl get configmaps",
        "not_applicable_when": "no_csr_configured"
      }
    ],
    "network_security.ingress_class": [
      {
        "service": "networking.k8s.io",
        "resource": "network.ingress",
        "adapter": "k8s.networking.ingress.default_config.default_class_validation",
        "rule_prefix": "k8s.networking.ingress.default_config",
        "resource_type": "network.ingress",
        "k8s_resources": [
          "IngressClass",
          "Ingress"
        ],
        "validation_method": "kubectl get ingressclass, kubectl get ingress",
        "not_applicable_when": "no_ingress_configured"
      },
      {
        "service": "networking.k8s.io",
        "resource": "network.ingress",
        "adapter": "k8s.networking.ingress.tls_security.tls_termination_validation",
        "rule_prefix": "k8s.networking.ingress.tls_security",
        "resource_type": "network.ingress",
        "k8s_resources": [
          "IngressClass",
          "Ingress"
        ],
        "validation_method": "kubectl get ingressclass, kubectl get ingress",
        "not_applicable_when": "no_ingress_configured"
      }
    ],
    "cluster_component_security.lease_coordination": [
      {
        "service": "coordination.k8s.io",
        "resource": "api.api_server",
        "adapter": "k8s.coordination.api_server.leader_election.leader_election_validation",
        "rule_prefix": "k8s.coordination.api_server.leader_election",
        "resource_type": "api.api_server",
        "k8s_resources": [
          "Lease",
          "ConfigMap"
        ],
        "validation_method": "kubectl get leases, kubectl get configmaps",
        "not_applicable_when": "no_leader_election"
      },
      {
        "service": "coordination.k8s.io",
        "resource": "api.api_server",
        "adapter": "k8s.coordination.api_server.ttl_management.ttl_validation",
        "rule_prefix": "k8s.coordination.api_server.ttl_management",
        "resource_type": "api.api_server",
        "k8s_resources": [
          "Lease"
        ],
        "validation_method": "kubectl get leases -o yaml",
        "not_applicable_when": "no_leader_election"
      }
    ],
    "network_security.endpoint_slice": [
      {
        "service": "discovery.k8s.io",
        "resource": "network.service",
        "adapter": "k8s.discovery.service.discovery.service_discovery_validation",
        "rule_prefix": "k8s.discovery.service.discovery",
        "resource_type": "network.service",
        "k8s_resources": [
          "EndpointSlice",
          "Service"
        ],
        "validation_method": "kubectl get endpointslice, kubectl get services",
        "not_applicable_when": "no_endpoint_slices"
      },
      {
        "service": "discovery.k8s.io",
        "resource": "network.service",
        "adapter": "k8s.discovery.service.readiness_check.ready_endpoints_validation",
        "rule_prefix": "k8s.discovery.service.readiness_check",
        "resource_type": "network.service",
        "k8s_resources": [
          "EndpointSlice"
        ],
        "validation_method": "kubectl get endpointslice -o yaml",
        "not_applicable_when": "no_endpoint_slices"
      }
    ],
    "workload_security.vertical_pod_autoscaler": [
      {
        "service": "autoscaling.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.autoscaling.deployment.cpu_scaling.cpu_optimization",
        "rule_prefix": "k8s.autoscaling.deployment.cpu_scaling",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "VerticalPodAutoscaler",
          "Deployment"
        ],
        "validation_method": "kubectl get vpa, kubectl get deployments",
        "not_applicable_when": "vpa_not_installed"
      },
      {
        "service": "autoscaling.k8s.io",
        "resource": "workload.deployment",
        "adapter": "k8s.autoscaling.deployment.memory_scaling.memory_optimization",
        "rule_prefix": "k8s.autoscaling.deployment.memory_scaling",
        "resource_type": "workload.deployment",
        "k8s_resources": [
          "VerticalPodAutoscaler"
        ],
        "validation_method": "kubectl get vpa -o yaml",
        "not_applicable_when": "vpa_not_installed"
      }
    ]
  },
  "metadata": {
    "comprehensive_enhancement_on": "2025-09-20T17:57:34.719447",
    "adapter_pattern": "resource_specific",
    "total_entries": 140,
    "enhancement_phases": {
      "phase_1": {
        "description": "Critical Domain Additions",
        "domains_added": 12,
        "entries_added": 24,
        "domains": [
          "Zero Trust Security",
          "Data Protection & Privacy",
          "Incident Response & Forensics"
        ]
      },
      "phase_2": {
        "description": "Enhance Existing Domains",
        "subcategories_enhanced": 12,
        "entries_added": 24,
        "domains": [
          "Identity & Access Management",
          "Pod & Container Security",
          "Monitoring & Observability",
          "Compliance & Governance"
        ]
      },
      "phase_3": {
        "description": "Achieve 2x Coverage",
        "modern_resources_added": 7,
        "entries_added": 14,
        "resources": [
          "PodDisruptionBudget",
          "HorizontalPodAutoscaler",
          "CertificateSigningRequest",
          "IngressClass",
          "Lease",
          "EndpointSlice",
          "VerticalPodAutoscaler"
        ]
      }
    },
    "coverage_analysis": {
      "total_domains": 85,
      "total_entries": 140,
      "estimated_coverage_ratio": "2.5x+ (exceeds 2x target)",
      "enterprise_ready": true,
      "comprehensive_coverage": true
    },
    "k8s_resources_covered": [
      "User",
      "ServiceAccount",
      "TokenRequest",
      "TokenReview",
      "Group",
      "Role",
      "ClusterRole",
      "RoleBinding",
      "ClusterRoleBinding",
      "ValidatingAdmissionWebhook",
      "MutatingAdmissionWebhook",
      "Pod",
      "Deployment",
      "DaemonSet",
      "StatefulSet",
      "ReplicaSet",
      "CronJob",
      "Job",
      "Node",
      "Namespace",
      "NetworkPolicy",
      "Ingress",
      "Service",
      "Endpoints",
      "Secret",
      "ConfigMap",
      "ExternalSecret",
      "SecretStore",
      "PersistentVolume",
      "PersistentVolumeClaim",
      "StorageClass",
      "ServiceMonitor",
      "PrometheusRule",
      "RuntimeClass",
      "ResourceQuota",
      "LimitRange",
      "PodSecurityPolicy",
      "ConstraintTemplate",
      "K8sRequiredLabels",
      "K8sRequiredAnnotations",
      "ClusterPolicy",
      "Policy",
      "PodDisruptionBudget",
      "HorizontalPodAutoscaler",
      "CertificateSigningRequest",
      "IngressClass",
      "Lease",
      "EndpointSlice",
      "VerticalPodAutoscaler",
      "Alertmanager",
      "Application"
    ],
    "validation_methods": [
      "kubectl get",
      "kubectl describe",
      "kubectl auth can-i",
      "kubectl get -o yaml",
      "kubectl get --all-namespaces",
      "kubectl logs",
      "kubectl exec",
      "kubectl top"
    ]
  },
  "enhancement_date": "2025-01-27",
  "enhancement_type": "deduplicated_adapters",
  "rule_prefix_format": "k8s.{service}.{subservice}.{check_type}",
  "total_rules_updated": 140,
  "total_entries": 123,
  "duplicates_removed": 17
}