{
  "version": "4.1",
  "technology": "kubernetes",
  "database_type": "security_rules",
  "generation_date": "2025-01-27",
  "source_matrix": "k8s_comprehensive_matrix_updated_2025-01-27.json",
  "source_assertions": "assertions_pack_k8s_enhanced_2025-01-27.json",
  "rule_id_pattern": "adapter.assertion_tail",
  "adapter_format": "rule_prefix.adapter_tail",
  "total_rules": 146,
  "unique_rule_ids": 146,
  "rules": [
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.certificate_auth_configured",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.certificate_auth_configured",
      "title": "Certificate-based authentication is configured for API server",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Certificate-based authentication provides strong identity verification for API server access.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_prevent_user_cert_spoofing"
    },
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.token_auth_secure",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.token_auth_secure",
      "title": "Service account token authentication is securely configured",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "identity.service_account",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Secure token authentication prevents unauthorized service account access.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_prevent_service_token_theft"
    },
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.oidc_integration_enabled",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.oidc_integration_enabled",
      "title": "OpenID Connect integration is enabled for external identity providers",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "OIDC integration enables centralized identity management and single sign-on.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_prevent_user_identity_spoofing"
    },
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.mfa_enforced",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "MFA provides additional security layer for administrative access to prevent unauthorized cluster access.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_prevent_user_credential_compromise"
    },
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.certificate_lifecycle_managed",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.certificate_lifecycle_managed",
      "title": "Certificate lifecycle management is automated",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Automated certificate rotation prevents service disruptions and maintains security posture.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_user_cert_lifecycle_managed"
    },
    {
      "rule_id": "k8s.core.user.authentication.certificate_auth_status.break_glass_access_controlled",
      "adapter": "k8s.core.user.authentication.certificate_auth_status",
      "assertion_id": "identity_access.authentication.break_glass_access_controlled",
      "title": "Break-glass emergency access is properly controlled and monitored",
      "service": "core",
      "resource_type": "identity.user",
      "scope": "rbac.cluster_role_binding",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Break-glass access provides emergency cluster access while maintaining audit trails and time limits.",
      "validation_method": "kubectl get users, kubectl get csr",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "User",
        "CertificateSigningRequest"
      ],
      "rule_name": "core_prevent_user_emergency_abuse"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.certificate_auth_configured",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.certificate_auth_configured",
      "title": "Certificate-based authentication is configured for API server",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Certificate-based authentication provides strong identity verification for API server access.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_prevent_service_cert_spoofing"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.token_auth_secure",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.token_auth_secure",
      "title": "Service account token authentication is securely configured",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "identity.service_account",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Secure token authentication prevents unauthorized service account access.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_prevent_service_token_theft"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.oidc_integration_enabled",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.oidc_integration_enabled",
      "title": "OpenID Connect integration is enabled for external identity providers",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "OIDC integration enables centralized identity management and single sign-on.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_prevent_service_identity_spoofing"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.mfa_enforced",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "MFA provides additional security layer for administrative access to prevent unauthorized cluster access.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_prevent_service_credential_compromise"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.certificate_lifecycle_managed",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.certificate_lifecycle_managed",
      "title": "Certificate lifecycle management is automated",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Automated certificate rotation prevents service disruptions and maintains security posture.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_service_account_cert_lifecycle_managed"
    },
    {
      "rule_id": "k8s.core.service_account.authentication.token_automount.break_glass_access_controlled",
      "adapter": "k8s.core.service_account.authentication.token_automount",
      "assertion_id": "identity_access.authentication.break_glass_access_controlled",
      "title": "Break-glass emergency access is properly controlled and monitored",
      "service": "core",
      "resource_type": "identity.service_account",
      "scope": "rbac.cluster_role_binding",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Break-glass access provides emergency cluster access while maintaining audit trails and time limits.",
      "validation_method": "kubectl get serviceaccounts, kubectl auth can-i",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "core_prevent_service_emergency_abuse"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.certificate_auth_configured",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.certificate_auth_configured",
      "title": "Certificate-based authentication is configured for API server",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Certificate-based authentication provides strong identity verification for API server access.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_prevent_cert_spoofing"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.token_auth_secure",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.token_auth_secure",
      "title": "Service account token authentication is securely configured",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "identity.service_account",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Secure token authentication prevents unauthorized service account access.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_prevent_token_theft"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.oidc_integration_enabled",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.oidc_integration_enabled",
      "title": "OpenID Connect integration is enabled for external identity providers",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "OIDC integration enables centralized identity management and single sign-on.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_prevent_identity_spoofing"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.mfa_enforced",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "MFA provides additional security layer for administrative access to prevent unauthorized cluster access.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_prevent_credential_compromise"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.certificate_lifecycle_managed",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.certificate_lifecycle_managed",
      "title": "Certificate lifecycle management is automated",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Automated certificate rotation prevents service disruptions and maintains security posture.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_api_server_cert_lifecycle_managed"
    },
    {
      "rule_id": "k8s.authentication.api_server.token_review.audit_logging.break_glass_access_controlled",
      "adapter": "k8s.authentication.api_server.token_review.audit_logging",
      "assertion_id": "identity_access.authentication.break_glass_access_controlled",
      "title": "Break-glass emergency access is properly controlled and monitored",
      "service": "authentication.k8s.io",
      "resource_type": "api.api_server",
      "scope": "rbac.cluster_role_binding",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Break-glass access provides emergency cluster access while maintaining audit trails and time limits.",
      "validation_method": "kubectl auth can-i --list",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "TokenReview"
      ],
      "rule_name": "auth_prevent_emergency_abuse"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.certificate_auth_configured",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.certificate_auth_configured",
      "title": "Certificate-based authentication is configured for API server",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Certificate-based authentication provides strong identity verification for API server access.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_prevent_group_cert_spoofing"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.token_auth_secure",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.token_auth_secure",
      "title": "Service account token authentication is securely configured",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "identity.service_account",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Secure token authentication prevents unauthorized service account access.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_prevent_group_token_theft"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.oidc_integration_enabled",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.oidc_integration_enabled",
      "title": "OpenID Connect integration is enabled for external identity providers",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "OIDC integration enables centralized identity management and single sign-on.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_prevent_group_identity_spoofing"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.mfa_enforced",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "MFA provides additional security layer for administrative access to prevent unauthorized cluster access.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_prevent_group_credential_compromise"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.certificate_lifecycle_managed",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.certificate_lifecycle_managed",
      "title": "Certificate lifecycle management is automated",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Automated certificate rotation prevents service disruptions and maintains security posture.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_group_cert_lifecycle_managed"
    },
    {
      "rule_id": "k8s.core.group.authentication.authentication_check.break_glass_access_controlled",
      "adapter": "k8s.core.group.authentication.authentication_check",
      "assertion_id": "identity_access.authentication.break_glass_access_controlled",
      "title": "Break-glass emergency access is properly controlled and monitored",
      "service": "core",
      "resource_type": "identity.group",
      "scope": "rbac.cluster_role_binding",
      "severity": "high",
      "domain_subcategory": "identity_access.authentication",
      "rationale": "Break-glass access provides emergency cluster access while maintaining audit trails and time limits.",
      "validation_method": "kubectl get groups",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Group"
      ],
      "rule_name": "core_prevent_group_emergency_abuse"
    },
    {
      "rule_id": "k8s.rbac.role.authorization.least_privilege_check.rbac_enabled",
      "adapter": "k8s.rbac.role.authorization.least_privilege_check",
      "assertion_id": "identity_access.authorization.rbac_enabled",
      "title": "RBAC authorization mode is enabled on API server",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.role",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "RBAC provides fine-grained access control for Kubernetes resources.",
      "validation_method": "kubectl get roles, kubectl get clusterroles",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Role",
        "ClusterRole"
      ],
      "rule_name": "rbac_prevent_role_privilege_creep"
    },
    {
      "rule_id": "k8s.rbac.role.authorization.least_privilege_check.admission_controller_enabled",
      "adapter": "k8s.rbac.role.authorization.least_privilege_check",
      "assertion_id": "identity_access.authorization.admission_controller_enabled",
      "title": "Admission controllers are enabled for authorization decisions",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.role",
      "scope": "api.admission_controller",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "Admission controllers enforce policies at API request time.",
      "validation_method": "kubectl get roles, kubectl get clusterroles",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Role",
        "ClusterRole"
      ],
      "rule_name": "rbac_prevent_role_admission_bypass"
    },
    {
      "rule_id": "k8s.rbac.role_binding.authorization.subject_validation.rbac_enabled",
      "adapter": "k8s.rbac.role_binding.authorization.subject_validation",
      "assertion_id": "identity_access.authorization.rbac_enabled",
      "title": "RBAC authorization mode is enabled on API server",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.role_binding",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "RBAC provides fine-grained access control for Kubernetes resources.",
      "validation_method": "kubectl get rolebindings, kubectl get clusterrolebindings",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "RoleBinding",
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_unauthorized_bindings_via_subject_validation"
    },
    {
      "rule_id": "k8s.rbac.role_binding.authorization.subject_validation.admission_controller_enabled",
      "adapter": "k8s.rbac.role_binding.authorization.subject_validation",
      "assertion_id": "identity_access.authorization.admission_controller_enabled",
      "title": "Admission controllers are enabled for authorization decisions",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.role_binding",
      "scope": "api.admission_controller",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "Admission controllers enforce policies at API request time.",
      "validation_method": "kubectl get rolebindings, kubectl get clusterrolebindings",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "RoleBinding",
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_admission_bypass_via_controller_enforcement"
    },
    {
      "rule_id": "k8s.core.admission_controller.authorization.status_check.rbac_enabled",
      "adapter": "k8s.core.admission_controller.authorization.status_check",
      "assertion_id": "identity_access.authorization.rbac_enabled",
      "title": "RBAC authorization mode is enabled on API server",
      "service": "core",
      "resource_type": "api.admission_controller",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "RBAC provides fine-grained access control for Kubernetes resources.",
      "validation_method": "kubectl get validatingwebhookconfigurations, kubectl get mutatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "AdmissionController"
      ],
      "rule_name": "core_admission_controller_rbac_enabled"
    },
    {
      "rule_id": "k8s.core.admission_controller.authorization.status_check.admission_controller_enabled",
      "adapter": "k8s.core.admission_controller.authorization.status_check",
      "assertion_id": "identity_access.authorization.admission_controller_enabled",
      "title": "Admission controllers are enabled for authorization decisions",
      "service": "core",
      "resource_type": "api.admission_controller",
      "scope": "api.admission_controller",
      "severity": "high",
      "domain_subcategory": "identity_access.authorization",
      "rationale": "Admission controllers enforce policies at API request time.",
      "validation_method": "kubectl get validatingwebhookconfigurations, kubectl get mutatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "AdmissionController"
      ],
      "rule_name": "core_admission_controller_enabled"
    },
    {
      "rule_id": "k8s.rbac.cluster_role.policy.policies_check.least_privilege_enforced",
      "adapter": "k8s.rbac.cluster_role.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.least_privilege_enforced",
      "title": "RBAC policies enforce least privilege access",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role",
      "scope": "rbac.role",
      "severity": "high",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Least privilege RBAC policies minimize attack surface and prevent privilege escalation.",
      "validation_method": "kubectl describe clusterrole",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRole"
      ],
      "rule_name": "rbac_cluster_role_least_privilege_enforced"
    },
    {
      "rule_id": "k8s.rbac.cluster_role.policy.policies_check.cluster_admin_restricted",
      "adapter": "k8s.rbac.cluster_role.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.cluster_admin_restricted",
      "title": "Cluster-admin role bindings are restricted and audited",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role",
      "scope": "rbac.cluster_role_binding",
      "severity": "critical",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Restricting cluster-admin access prevents unauthorized cluster-wide privilege escalation.",
      "validation_method": "kubectl describe clusterrole",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRole"
      ],
      "rule_name": "rbac_prevent_privilege_escalation_via_admin_restrictions"
    },
    {
      "rule_id": "k8s.rbac.cluster_role.policy.policies_check.wildcard_permissions_prohibited",
      "adapter": "k8s.rbac.cluster_role.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.wildcard_permissions_prohibited",
      "title": "Wildcard (*) permissions are prohibited in RBAC policies",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role",
      "scope": "rbac.role",
      "severity": "high",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Wildcard permissions violate least privilege and create excessive access rights.",
      "validation_method": "kubectl describe clusterrole",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRole"
      ],
      "rule_name": "rbac_prevent_overprivileged_access_via_wildcard_restrictions"
    },
    {
      "rule_id": "k8s.rbac.cluster_role_binding.policy.policies_check.least_privilege_enforced",
      "adapter": "k8s.rbac.cluster_role_binding.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.least_privilege_enforced",
      "title": "RBAC policies enforce least privilege access",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.role",
      "severity": "high",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Least privilege RBAC policies minimize attack surface and prevent privilege escalation.",
      "validation_method": "kubectl describe clusterrolebinding",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_privilege_creep_via_least_privilege_policies"
    },
    {
      "rule_id": "k8s.rbac.cluster_role_binding.policy.policies_check.cluster_admin_restricted",
      "adapter": "k8s.rbac.cluster_role_binding.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.cluster_admin_restricted",
      "title": "Cluster-admin role bindings are restricted and audited",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.cluster_role_binding",
      "severity": "critical",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Restricting cluster-admin access prevents unauthorized cluster-wide privilege escalation.",
      "validation_method": "kubectl describe clusterrolebinding",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_admin_abuse_via_admin_restrictions"
    },
    {
      "rule_id": "k8s.rbac.cluster_role_binding.policy.policies_check.wildcard_permissions_prohibited",
      "adapter": "k8s.rbac.cluster_role_binding.policy.policies_check",
      "assertion_id": "identity_access.rbac_policies.wildcard_permissions_prohibited",
      "title": "Wildcard (*) permissions are prohibited in RBAC policies",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.role",
      "severity": "high",
      "domain_subcategory": "identity_access.rbac_policies",
      "rationale": "Wildcard permissions violate least privilege and create excessive access rights.",
      "validation_method": "kubectl describe clusterrolebinding",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_wildcard_abuse_via_wildcard_restrictions"
    },
    {
      "rule_id": "k8s.core.pod.serviceaccount.security_context_validation.automount_disabled",
      "adapter": "k8s.core.pod.serviceaccount.security_context_validation",
      "assertion_id": "identity_access.service_account_management.automount_disabled",
      "title": "Automatic mounting of service account tokens is disabled",
      "service": "core",
      "resource_type": "pod.pod",
      "scope": "identity.service_account",
      "severity": "medium",
      "domain_subcategory": "identity_access.service_account_management",
      "rationale": "Disabling automount prevents unnecessary service account token exposure.",
      "validation_method": "kubectl get pods -o yaml | grep serviceAccount",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod"
      ],
      "rule_name": "core_prevent_token_automount"
    },
    {
      "rule_id": "k8s.rbac.cluster_role_binding.admin.admin_check.admin_bindings_audited",
      "adapter": "k8s.rbac.cluster_role_binding.admin.admin_check",
      "assertion_id": "identity_access.cluster_admin_restrictions.admin_bindings_audited",
      "title": "Cluster admin role bindings are audited and restricted",
      "service": "rbac.authorization.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.cluster_role_binding",
      "severity": "high",
      "domain_subcategory": "identity_access.cluster_admin_restrictions",
      "rationale": "Restricting and auditing cluster admin bindings prevents privilege escalation.",
      "validation_method": "kubectl get clusterrolebindings | grep cluster-admin",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterRoleBinding"
      ],
      "rule_name": "rbac_prevent_admin_abuse_via_admin_restrictions"
    },
    {
      "rule_id": "k8s.core.container.image.image_digest_validation.signed_images_required",
      "adapter": "k8s.core.container.image.image_digest_validation",
      "assertion_id": "pod_container_security.image_security.signed_images_required",
      "title": "Only signed container images are allowed",
      "service": "core",
      "resource_type": "container.container",
      "scope": "container.container",
      "severity": "high",
      "domain_subcategory": "pod_container_security.image_security",
      "rationale": "Image signing ensures image integrity and prevents supply chain attacks.",
      "validation_method": "kubectl get pods -o yaml | grep image",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "Deployment",
        "DaemonSet",
        "StatefulSet"
      ],
      "rule_name": "core_prevent_unsigned_images"
    },
    {
      "rule_id": "k8s.core.container.image.image_digest_validation.image_provenance_verified",
      "adapter": "k8s.core.container.image.image_digest_validation",
      "assertion_id": "pod_container_security.image_security.image_provenance_verified",
      "title": "Container image provenance is verified",
      "service": "core",
      "resource_type": "container.container",
      "scope": "container.container",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.image_security",
      "rationale": "Provenance verification ensures image authenticity and supply chain integrity.",
      "validation_method": "kubectl get pods -o yaml | grep image",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "Deployment",
        "DaemonSet",
        "StatefulSet"
      ],
      "rule_name": "core_prevent_image_tampering"
    },
    {
      "rule_id": "k8s.admission.validating_webhook.validation.status_check.signed_images_required",
      "adapter": "k8s.admission.validating_webhook.validation.status_check",
      "assertion_id": "pod_container_security.image_security.signed_images_required",
      "title": "Only signed container images are allowed",
      "service": "admissionregistration.k8s.io",
      "resource_type": "admission.validating_webhook",
      "scope": "container.container",
      "severity": "high",
      "domain_subcategory": "pod_container_security.image_security",
      "rationale": "Image signing ensures image integrity and prevents supply chain attacks.",
      "validation_method": "kubectl get validatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ValidatingAdmissionWebhook"
      ],
      "rule_name": "admission_prevent_unsigned_deployments_via_image_signing"
    },
    {
      "rule_id": "k8s.admission.validating_webhook.validation.status_check.image_provenance_verified",
      "adapter": "k8s.admission.validating_webhook.validation.status_check",
      "assertion_id": "pod_container_security.image_security.image_provenance_verified",
      "title": "Container image provenance is verified",
      "service": "admissionregistration.k8s.io",
      "resource_type": "admission.validating_webhook",
      "scope": "container.container",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.image_security",
      "rationale": "Provenance verification ensures image authenticity and supply chain integrity.",
      "validation_method": "kubectl get validatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ValidatingAdmissionWebhook"
      ],
      "rule_name": "admission_prevent_image_spoofing_via_provenance_verification"
    },
    {
      "rule_id": "k8s.core.node.runtime.runtime_security_check.falco_enabled",
      "adapter": "k8s.core.node.runtime.runtime_security_check",
      "assertion_id": "pod_container_security.runtime_security.falco_enabled",
      "title": "Falco runtime security monitoring is enabled",
      "service": "core",
      "resource_type": "infrastructure.node",
      "scope": "infrastructure.node",
      "severity": "high",
      "domain_subcategory": "pod_container_security.runtime_security",
      "rationale": "Falco provides real-time threat detection and behavioral analysis.",
      "validation_method": "kubectl get nodes -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Node"
      ],
      "rule_name": "core_prevent_node_compromise"
    },
    {
      "rule_id": "k8s.core.namespace.pod_security.pod_security_check.psa_enforced",
      "adapter": "k8s.core.namespace.pod_security.pod_security_check",
      "assertion_id": "pod_container_security.pod_security_standards.psa_enforced",
      "title": "Pod Security Admission (PSA) is enforced at namespace level",
      "service": "core",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "high",
      "domain_subcategory": "pod_container_security.pod_security_standards",
      "rationale": "PSA enforcement ensures consistent pod security standards across namespaces.",
      "validation_method": "kubectl get namespace -o yaml | grep pod-security",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Namespace"
      ],
      "rule_name": "core_prevent_pod_security_bypass"
    },
    {
      "rule_id": "k8s.core.namespace.pod_security.pod_security_check.psp_enabled",
      "adapter": "k8s.core.namespace.pod_security.pod_security_check",
      "assertion_id": "pod_container_security.pod_security_standards.psp_enabled",
      "title": "Pod Security Policies are enabled and configured",
      "service": "core",
      "resource_type": "compliance.namespace",
      "scope": "compliance.pod_security_policy",
      "severity": "high",
      "domain_subcategory": "pod_container_security.pod_security_standards",
      "rationale": "Pod Security Policies enforce security constraints on pod specifications.",
      "validation_method": "kubectl get namespace -o yaml | grep pod-security",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Namespace"
      ],
      "rule_name": "core_prevent_pod_policy_bypass"
    },
    {
      "rule_id": "k8s.core.security_context.privilege_control.privilege_escalation_check.capabilities_restricted",
      "adapter": "k8s.core.security_context.privilege_control.privilege_escalation_check",
      "assertion_id": "pod_container_security.privilege_escalation_prevention.capabilities_restricted",
      "title": "Container capabilities are restricted to prevent privilege escalation",
      "service": "core",
      "resource_type": "container.security_context",
      "scope": "container.security_context",
      "severity": "high",
      "domain_subcategory": "pod_container_security.privilege_escalation_prevention",
      "rationale": "Restricting capabilities prevents privilege escalation attacks.",
      "validation_method": "kubectl get pods -o yaml | grep allowPrivilegeEscalation",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod"
      ],
      "rule_name": "core_security_context_privilege_control_privilege_escalation_capabilities_restricted"
    },
    {
      "rule_id": "k8s.networking.network_policy.networkpolicy.default_deny.namespace_isolation_enforced",
      "adapter": "k8s.networking.network_policy.networkpolicy.default_deny",
      "assertion_id": "network_security.network_policies.namespace_isolation_enforced",
      "title": "Network policies enforce namespace isolation",
      "service": "networking.k8s.io",
      "resource_type": "network.network_policy",
      "scope": "network.network_policy",
      "severity": "high",
      "domain_subcategory": "network_security.network_policies",
      "rationale": "Network policies prevent lateral movement and enforce micro-segmentation.",
      "validation_method": "kubectl get networkpolicies",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "NetworkPolicy"
      ],
      "rule_name": "networking_prevent_lateral_movement_via_namespace_isolation"
    },
    {
      "rule_id": "k8s.networking.network_policy.networkpolicy.default_deny.egress_traffic_controlled",
      "adapter": "k8s.networking.network_policy.networkpolicy.default_deny",
      "assertion_id": "network_security.network_policies.egress_traffic_controlled",
      "title": "Egress traffic is controlled by network policies",
      "service": "networking.k8s.io",
      "resource_type": "network.network_policy",
      "scope": "network.network_policy",
      "severity": "medium",
      "domain_subcategory": "network_security.network_policies",
      "rationale": "Egress controls prevent data exfiltration and unauthorized external communication.",
      "validation_method": "kubectl get networkpolicies",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "NetworkPolicy"
      ],
      "rule_name": "networking_prevent_data_exfiltration_via_egress_control"
    },
    {
      "rule_id": "k8s.networking.ingress.security.tls_termination.tls_termination_enabled",
      "adapter": "k8s.networking.ingress.security.tls_termination",
      "assertion_id": "network_security.ingress_security.tls_termination_enabled",
      "title": "TLS termination is enabled on ingress resources",
      "service": "networking.k8s.io",
      "resource_type": "network.ingress",
      "scope": "network.ingress",
      "severity": "high",
      "domain_subcategory": "network_security.ingress_security",
      "rationale": "TLS termination encrypts traffic between clients and ingress controllers.",
      "validation_method": "kubectl get ingress -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Ingress"
      ],
      "rule_name": "networking_prevent_plaintext_exposure_via_tls_termination"
    },
    {
      "rule_id": "k8s.networking.ingress.security.tls_termination.ingress_controller_secure",
      "adapter": "k8s.networking.ingress.security.tls_termination",
      "assertion_id": "network_security.ingress_security.ingress_controller_secure",
      "title": "Ingress controller is configured with security best practices",
      "service": "networking.k8s.io",
      "resource_type": "network.ingress",
      "scope": "network.ingress",
      "severity": "medium",
      "domain_subcategory": "network_security.ingress_security",
      "rationale": "Secure ingress controller configuration prevents common web attacks.",
      "validation_method": "kubectl get ingress -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Ingress"
      ],
      "rule_name": "networking_prevent_ingress_attacks_via_controller_security"
    },
    {
      "rule_id": "k8s.networking.service.service_mesh.mesh_security_check.mtls_enabled",
      "adapter": "k8s.networking.service.service_mesh.mesh_security_check",
      "assertion_id": "network_security.service_mesh_security.mtls_enabled",
      "title": "Mutual TLS is enabled in service mesh",
      "service": "networking.k8s.io",
      "resource_type": "network.service",
      "scope": "network.service",
      "severity": "high",
      "domain_subcategory": "network_security.service_mesh_security",
      "rationale": "mTLS provides service-to-service authentication and encryption.",
      "validation_method": "kubectl get services -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Service"
      ],
      "rule_name": "networking_prevent_man_in_middle_via_mtls"
    },
    {
      "rule_id": "k8s.networking.service.service_mesh.mesh_security_check.authorization_policies_enforced",
      "adapter": "k8s.networking.service.service_mesh.mesh_security_check",
      "assertion_id": "network_security.service_mesh_security.authorization_policies_enforced",
      "title": "Service mesh authorization policies are enforced",
      "service": "networking.k8s.io",
      "resource_type": "network.service",
      "scope": "network.service",
      "severity": "high",
      "domain_subcategory": "network_security.service_mesh_security",
      "rationale": "Service mesh authorization policies enforce zero-trust networking principles.",
      "validation_method": "kubectl get services -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Service"
      ],
      "rule_name": "networking_prevent_unauthorized_communication_via_auth_policies"
    },
    {
      "rule_id": "k8s.core.service.dns_security.dns_security_check.dns_policies_enforced",
      "adapter": "k8s.core.service.dns_security.dns_security_check",
      "assertion_id": "network_security.dns_security.dns_policies_enforced",
      "title": "DNS policies are enforced for pod resolution",
      "service": "core",
      "resource_type": "network.service",
      "scope": "network.service",
      "severity": "low",
      "domain_subcategory": "network_security.dns_security",
      "rationale": "DNS policies control name resolution and prevent DNS-based attacks.",
      "validation_method": "kubectl get services -n kube-system | grep dns",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Service"
      ],
      "rule_name": "core_service_dns_security_dns_dns_policies_enforced"
    },
    {
      "rule_id": "k8s.networking.endpoint.egress_control.egress_check.dns_filtering_enabled",
      "adapter": "k8s.networking.endpoint.egress_control.egress_check",
      "assertion_id": "network_security.egress_controls.dns_filtering_enabled",
      "title": "DNS filtering and egress controls are implemented",
      "service": "networking.k8s.io",
      "resource_type": "network.endpoint",
      "scope": "network.service",
      "severity": "medium",
      "domain_subcategory": "network_security.egress_controls",
      "rationale": "DNS filtering prevents data exfiltration and blocks malicious domain resolution.",
      "validation_method": "kubectl get endpoints",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Endpoints"
      ],
      "rule_name": "networking_prevent_dns_exfiltration_via_dns_filtering"
    },
    {
      "rule_id": "k8s.core.secret.storage.encryption_at_rest.encryption_at_rest_enabled",
      "adapter": "k8s.core.secret.storage.encryption_at_rest",
      "assertion_id": "secrets_config_mgmt.secret_storage.encryption_at_rest_enabled",
      "title": "Secrets are encrypted at rest in etcd",
      "service": "core",
      "resource_type": "secret.secret",
      "scope": "secret.secret",
      "severity": "high",
      "domain_subcategory": "secrets_config_mgmt.secret_storage",
      "rationale": "Encryption at rest protects secrets from unauthorized access.",
      "validation_method": "kubectl get secrets",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Secret"
      ],
      "rule_name": "core_secret_storage_encryption_at_rest_encryption_at_rest_enabled"
    },
    {
      "rule_id": "k8s.core.etcd.secret_encryption.client_cert_auth.encryption_at_rest_enabled",
      "adapter": "k8s.core.etcd.secret_encryption.client_cert_auth",
      "assertion_id": "secrets_config_mgmt.secret_storage.encryption_at_rest_enabled",
      "title": "Secrets are encrypted at rest in etcd",
      "service": "core",
      "resource_type": "etcd.etcd",
      "scope": "secret.secret",
      "severity": "high",
      "domain_subcategory": "secrets_config_mgmt.secret_storage",
      "rationale": "Encryption at rest protects secrets from unauthorized access.",
      "validation_method": "kubectl get configmap -n kube-system kube-apiserver",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ConfigMap"
      ],
      "rule_name": "core_prevent_etcd_data_theft"
    },
    {
      "rule_id": "k8s.core.secret.rotation.automated_rotation.automated_rotation_enabled",
      "adapter": "k8s.core.secret.rotation.automated_rotation",
      "assertion_id": "secrets_config_mgmt.key_rotation.automated_rotation_enabled",
      "title": "Automated key rotation is enabled for secrets",
      "service": "core",
      "resource_type": "secret.secret",
      "scope": "secret.secret",
      "severity": "high",
      "domain_subcategory": "secrets_config_mgmt.key_rotation",
      "rationale": "Automated rotation reduces exposure window for compromised keys.",
      "validation_method": "kubectl get secrets -o yaml | grep creationTimestamp",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Secret"
      ],
      "rule_name": "core_secret_rotation_automated_rotation_automated_rotation_enabled"
    },
    {
      "rule_id": "k8s.external_secrets.external_secret.rotation.rotation_check.automated_rotation_enabled",
      "adapter": "k8s.external_secrets.external_secret.rotation.rotation_check",
      "assertion_id": "secrets_config_mgmt.key_rotation.automated_rotation_enabled",
      "title": "Automated key rotation is enabled for secrets",
      "service": "external-secrets.io",
      "resource_type": "secret.external_secret",
      "scope": "secret.secret",
      "severity": "high",
      "domain_subcategory": "secrets_config_mgmt.key_rotation",
      "rationale": "Automated rotation reduces exposure window for compromised keys.",
      "validation_method": "kubectl get externalsecrets",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ExternalSecret"
      ],
      "rule_name": "external_secrets_prevent_rotation_failure_via_automation"
    },
    {
      "rule_id": "k8s.core.configmap.secret_sprawl.secret_sprawl_check.unused_secrets_cleaned",
      "adapter": "k8s.core.configmap.secret_sprawl.secret_sprawl_check",
      "assertion_id": "secrets_config_mgmt.secret_sprawl.unused_secrets_cleaned",
      "title": "Unused and stale secrets are automatically cleaned up",
      "service": "core",
      "resource_type": "config.configmap",
      "scope": "secret.secret",
      "severity": "medium",
      "domain_subcategory": "secrets_config_mgmt.secret_sprawl",
      "rationale": "Cleaning up unused secrets reduces attack surface.",
      "validation_method": "kubectl get configmaps --all-namespaces",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ConfigMap"
      ],
      "rule_name": "core_prevent_secret_sprawl"
    },
    {
      "rule_id": "k8s.external_secrets.external_secret.external_secret.status_check.external_secret_operator_enabled",
      "adapter": "k8s.external_secrets.external_secret.external_secret.status_check",
      "assertion_id": "secrets_config_mgmt.external_secrets.external_secret_operator_enabled",
      "title": "External secret management is integrated",
      "service": "external-secrets.io",
      "resource_type": "secret.external_secret",
      "scope": "secret.external_secret",
      "severity": "medium",
      "domain_subcategory": "secrets_config_mgmt.external_secrets",
      "rationale": "External secret management provides centralized, secure secret lifecycle management.",
      "validation_method": "kubectl get externalsecrets, kubectl get secretstores",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ExternalSecret",
        "SecretStore"
      ],
      "rule_name": "external_secrets_prevent_manual_rotation_via_operator"
    },
    {
      "rule_id": "k8s.core.backup.backup.backup_security_check.etcd_peer_tls_enabled",
      "adapter": "k8s.core.backup.backup.backup_security_check",
      "assertion_id": "cluster_component_security.etcd_security.etcd_peer_tls_enabled",
      "title": "etcd peer communication uses TLS",
      "service": "core",
      "resource_type": "etcd.backup",
      "scope": "etcd.etcd",
      "severity": "high",
      "domain_subcategory": "cluster_component_security.etcd_security",
      "rationale": "etcd peer TLS prevents man-in-the-middle attacks on cluster state.",
      "validation_method": "kubectl get pods,jobs,cronjobs -n kube-system | grep etcd",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "Job",
        "CronJob"
      ],
      "rule_name": "core_prevent_etcd_peer_interception"
    },
    {
      "rule_id": "k8s.core.backup.backup.backup_security_check.etcd_client_tls_enabled",
      "adapter": "k8s.core.backup.backup.backup_security_check",
      "assertion_id": "cluster_component_security.etcd_security.etcd_client_tls_enabled",
      "title": "etcd client communication uses TLS",
      "service": "core",
      "resource_type": "etcd.backup",
      "scope": "etcd.etcd",
      "severity": "high",
      "domain_subcategory": "cluster_component_security.etcd_security",
      "rationale": "etcd client TLS protects API server to etcd communication.",
      "validation_method": "kubectl get pods,jobs,cronjobs -n kube-system | grep etcd",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "Job",
        "CronJob"
      ],
      "rule_name": "core_prevent_etcd_interception"
    },
    {
      "rule_id": "k8s.core.backup.backup.backup_security_check.backup_encryption_enabled",
      "adapter": "k8s.core.backup.backup.backup_security_check",
      "assertion_id": "cluster_component_security.etcd_security.backup_encryption_enabled",
      "title": "etcd backup encryption is enabled",
      "service": "core",
      "resource_type": "etcd.backup",
      "scope": "etcd.backup",
      "severity": "high",
      "domain_subcategory": "cluster_component_security.etcd_security",
      "rationale": "Backup encryption protects sensitive cluster state data during backup and restore operations.",
      "validation_method": "kubectl get pods,jobs,cronjobs -n kube-system | grep etcd",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "Job",
        "CronJob"
      ],
      "rule_name": "core_prevent_backup_theft"
    },
    {
      "rule_id": "k8s.core.scheduler.security.security_check.component_isolation_enforced",
      "adapter": "k8s.core.scheduler.security.security_check",
      "assertion_id": "cluster_component_security.control_plane_security.component_isolation_enforced",
      "title": "Control plane components are network isolated",
      "service": "core",
      "resource_type": "scheduler.scheduler",
      "scope": "scheduler.scheduler",
      "severity": "medium",
      "domain_subcategory": "cluster_component_security.control_plane_security",
      "rationale": "Component isolation prevents lateral movement between control plane components.",
      "validation_method": "kubectl get pods -n kube-system | grep scheduler",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod"
      ],
      "rule_name": "core_scheduler_security_component_isolation_enforced"
    },
    {
      "rule_id": "k8s.core.controller_manager.security.security_check.component_isolation_enforced",
      "adapter": "k8s.core.controller_manager.security.security_check",
      "assertion_id": "cluster_component_security.control_plane_security.component_isolation_enforced",
      "title": "Control plane components are network isolated",
      "service": "core",
      "resource_type": "controller.controller_manager",
      "scope": "scheduler.scheduler",
      "severity": "medium",
      "domain_subcategory": "cluster_component_security.control_plane_security",
      "rationale": "Component isolation prevents lateral movement between control plane components.",
      "validation_method": "kubectl get pods -n kube-system | grep controller-manager",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod"
      ],
      "rule_name": "core_controller_manager_isolation_enforced"
    },
    {
      "rule_id": "k8s.core.kubelet.security.security_check.kubelet_authentication_enabled",
      "adapter": "k8s.core.kubelet.security.security_check",
      "assertion_id": "cluster_component_security.kubelet_security.kubelet_authentication_enabled",
      "title": "Kubelet authentication is enabled",
      "service": "core",
      "resource_type": "kubelet.kubelet",
      "scope": "kubelet.kubelet",
      "severity": "high",
      "domain_subcategory": "cluster_component_security.kubelet_security",
      "rationale": "Kubelet authentication prevents unauthorized access to node resources.",
      "validation_method": "kubectl get nodes -o yaml | grep kubelet",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Node"
      ],
      "rule_name": "core_prevent_kubelet_spoofing"
    },
    {
      "rule_id": "k8s.core.kubelet.security.security_check.kubelet_readonly_port_disabled",
      "adapter": "k8s.core.kubelet.security.security_check",
      "assertion_id": "cluster_component_security.kubelet_security.kubelet_readonly_port_disabled",
      "title": "Kubelet read-only port is disabled",
      "service": "core",
      "resource_type": "kubelet.kubelet",
      "scope": "kubelet.kubelet",
      "severity": "medium",
      "domain_subcategory": "cluster_component_security.kubelet_security",
      "rationale": "Read-only port exposes node information without authentication.",
      "validation_method": "kubectl get nodes -o yaml | grep kubelet",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Node"
      ],
      "rule_name": "core_prevent_kubelet_exploitation"
    },
    {
      "rule_id": "k8s.core.kube_proxy.security.security_check.proxy_configuration_secured",
      "adapter": "k8s.core.kube_proxy.security.security_check",
      "assertion_id": "cluster_component_security.kube_proxy_security.proxy_configuration_secured",
      "title": "Kube-proxy configuration is secured",
      "service": "core",
      "resource_type": "kube_proxy.kube_proxy",
      "scope": "kube_proxy.kube_proxy",
      "severity": "medium",
      "domain_subcategory": "cluster_component_security.kube_proxy_security",
      "rationale": "Securing kube-proxy prevents network proxy vulnerabilities.",
      "validation_method": "kubectl get pods,daemonsets -n kube-system | grep kube-proxy",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "core_prevent_proxy_compromise"
    },
    {
      "rule_id": "k8s.admission.admission_controller.control.status_check.builtin_controllers_enabled",
      "adapter": "k8s.admission.admission_controller.control.status_check",
      "assertion_id": "admission_policy_enforcement.admission_control.builtin_controllers_enabled",
      "title": "Built-in admission controllers are properly configured",
      "service": "admissionregistration.k8s.io",
      "resource_type": "api.admission_controller",
      "scope": "api.admission_controller",
      "severity": "high",
      "domain_subcategory": "admission_policy_enforcement.admission_control",
      "rationale": "Built-in admission controllers provide essential security controls.",
      "validation_method": "kubectl get validatingwebhookconfigurations, kubectl get mutatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ValidatingAdmissionWebhook",
        "MutatingAdmissionWebhook"
      ],
      "rule_name": "admission_controller_builtin_enabled"
    },
    {
      "rule_id": "k8s.admission.validating_webhook.validating_webhook.status_check.webhook_validation_enabled",
      "adapter": "k8s.admission.validating_webhook.validating_webhook.status_check",
      "assertion_id": "admission_policy_enforcement.validating_admission_webhooks.webhook_validation_enabled",
      "title": "Validating admission webhooks are configured",
      "service": "admissionregistration.k8s.io",
      "resource_type": "admission.validating_webhook",
      "scope": "admission.validating_webhook",
      "severity": "medium",
      "domain_subcategory": "admission_policy_enforcement.validating_admission_webhooks",
      "rationale": "Validating admission webhooks enforce custom security policies.",
      "validation_method": "kubectl get validatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ValidatingAdmissionWebhook"
      ],
      "rule_name": "admission_prevent_validation_bypass_via_webhook_validation"
    },
    {
      "rule_id": "k8s.admission.mutating_webhook.mutating_webhook.status_check.secure_webhooks_enforced",
      "adapter": "k8s.admission.mutating_webhook.mutating_webhook.status_check",
      "assertion_id": "admission_policy_enforcement.mutating_admission_webhooks.secure_webhooks_enforced",
      "title": "Mutating admission webhooks are securely configured",
      "service": "admissionregistration.k8s.io",
      "resource_type": "admission.mutating_webhook",
      "scope": "admission.mutating_webhook",
      "severity": "medium",
      "domain_subcategory": "admission_policy_enforcement.mutating_admission_webhooks",
      "rationale": "Secure webhooks prevent malicious admission controller attacks.",
      "validation_method": "kubectl get mutatingwebhookconfigurations",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "MutatingAdmissionWebhook"
      ],
      "rule_name": "admission_prevent_webhook_tampering_via_secure_enforcement"
    },
    {
      "rule_id": "k8s.gatekeeper.opa_constraint.constraint.status_check.constraints_configured",
      "adapter": "k8s.gatekeeper.opa_constraint.constraint.status_check",
      "assertion_id": "admission_policy_enforcement.opa_gatekeeper.constraints_configured",
      "title": "OPA Gatekeeper constraints are configured",
      "service": "constraints.gatekeeper.sh",
      "resource_type": "admission.opa_constraint",
      "scope": "admission.opa_constraint",
      "severity": "medium",
      "domain_subcategory": "admission_policy_enforcement.opa_gatekeeper",
      "rationale": "OPA Gatekeeper provides policy-as-code enforcement for Kubernetes resources.",
      "validation_method": "kubectl get constrainttemplates, kubectl get k8srequiredlabels",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ConstraintTemplate",
        "K8sRequiredLabels",
        "K8sRequiredAnnotations"
      ],
      "rule_name": "gatekeeper_prevent_policy_bypass_via_opa_constraints"
    },
    {
      "rule_id": "k8s.kyverno.kyverno_policy.policy.status_check.policy_enforcement_enabled",
      "adapter": "k8s.kyverno.kyverno_policy.policy.status_check",
      "assertion_id": "admission_policy_enforcement.kyverno_policies.policy_enforcement_enabled",
      "title": "Kyverno policy enforcement is enabled",
      "service": "kyverno.io",
      "resource_type": "admission.kyverno_policy",
      "scope": "admission.kyverno_policy",
      "severity": "medium",
      "domain_subcategory": "admission_policy_enforcement.kyverno_policies",
      "rationale": "Kyverno provides Kubernetes-native policy management.",
      "validation_method": "kubectl get clusterpolicies, kubectl get policies",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ClusterPolicy",
        "Policy"
      ],
      "rule_name": "kyverno_prevent_policy_evasion_via_enforcement"
    },
    {
      "rule_id": "k8s.core.persistent_volume.security.access_modes.pv_access_modes_restricted",
      "adapter": "k8s.core.persistent_volume.security.access_modes",
      "assertion_id": "storage_security.persistent_volume_security.pv_access_modes_restricted",
      "title": "Persistent volume access modes are appropriately restricted",
      "service": "core",
      "resource_type": "storage.persistent_volume",
      "scope": "storage.persistent_volume",
      "severity": "medium",
      "domain_subcategory": "storage_security.persistent_volume_security",
      "rationale": "Restricted access modes prevent unauthorized data access and corruption.",
      "validation_method": "kubectl get persistentvolumes",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "PersistentVolume"
      ],
      "rule_name": "core_persistent_volume_security_access_modes_pv_access_modes_restricted"
    },
    {
      "rule_id": "k8s.core.persistent_volume_claim.security.security_check.pv_access_modes_restricted",
      "adapter": "k8s.core.persistent_volume_claim.security.security_check",
      "assertion_id": "storage_security.persistent_volume_security.pv_access_modes_restricted",
      "title": "Persistent volume access modes are appropriately restricted",
      "service": "core",
      "resource_type": "storage.persistent_volume_claim",
      "scope": "storage.persistent_volume",
      "severity": "medium",
      "domain_subcategory": "storage_security.persistent_volume_security",
      "rationale": "Restricted access modes prevent unauthorized data access and corruption.",
      "validation_method": "kubectl get persistentvolumeclaims",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "PersistentVolumeClaim"
      ],
      "rule_name": "core_persistent_volume_claim_security_pv_access_modes_restricted"
    },
    {
      "rule_id": "k8s.storage.storage_class.security.security_check.pv_access_modes_restricted",
      "adapter": "k8s.storage.storage_class.security.security_check",
      "assertion_id": "storage_security.persistent_volume_security.pv_access_modes_restricted",
      "title": "Persistent volume access modes are appropriately restricted",
      "service": "storage.k8s.io",
      "resource_type": "storage.storage_class",
      "scope": "storage.persistent_volume",
      "severity": "medium",
      "domain_subcategory": "storage_security.persistent_volume_security",
      "rationale": "Restricted access modes prevent unauthorized data access and corruption.",
      "validation_method": "kubectl get storageclasses",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "StorageClass"
      ],
      "rule_name": "storage_prevent_unauthorized_access_via_access_restrictions"
    },
    {
      "rule_id": "k8s.core.persistent_volume_claim.mount.mount_security_check.host_path_restricted",
      "adapter": "k8s.core.persistent_volume_claim.mount.mount_security_check",
      "assertion_id": "storage_security.volume_mount_security.host_path_restricted",
      "title": "Host path volume mounts are restricted",
      "service": "core",
      "resource_type": "storage.persistent_volume_claim",
      "scope": "storage.persistent_volume",
      "severity": "high",
      "domain_subcategory": "storage_security.volume_mount_security",
      "rationale": "Restricting host paths prevents unauthorized host access.",
      "validation_method": "kubectl get persistentvolumeclaims -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "PersistentVolumeClaim"
      ],
      "rule_name": "core_persistent_volume_claim_mount_mount_host_path_restricted"
    },
    {
      "rule_id": "k8s.storage.storage_class.encryption.encryption_check.storage_class_encryption_enabled",
      "adapter": "k8s.storage.storage_class.encryption.encryption_check",
      "assertion_id": "storage_security.storage_encryption.storage_class_encryption_enabled",
      "title": "Storage classes have encryption enabled",
      "service": "storage.k8s.io",
      "resource_type": "storage.storage_class",
      "scope": "storage.storage_class",
      "severity": "high",
      "domain_subcategory": "storage_security.storage_encryption",
      "rationale": "Storage encryption protects data at rest from unauthorized access.",
      "validation_method": "kubectl get storageclasses -o yaml | grep encryption",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "StorageClass"
      ],
      "rule_name": "storage_prevent_storage_breach_via_class_encryption"
    },
    {
      "rule_id": "k8s.storage.storage_class.access.access_controls_check.rbac_enforced",
      "adapter": "k8s.storage.storage_class.access.access_controls_check",
      "assertion_id": "storage_security.storage_access_controls.rbac_enforced",
      "title": "Storage access controls are enforced through RBAC",
      "service": "storage.k8s.io",
      "resource_type": "storage.storage_class",
      "scope": "storage.persistent_volume",
      "severity": "medium",
      "domain_subcategory": "storage_security.storage_access_controls",
      "rationale": "RBAC controls prevent unauthorized storage access.",
      "validation_method": "kubectl get storageclasses -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "StorageClass"
      ],
      "rule_name": "storage_prevent_storage_privilege_abuse_via_rbac"
    },
    {
      "rule_id": "k8s.core.audit_log.audit_logging.policy_enforcement.audit_policy_comprehensive",
      "adapter": "k8s.core.audit_log.audit_logging.policy_enforcement",
      "assertion_id": "monitoring_observability.audit_logging.audit_policy_comprehensive",
      "title": "Comprehensive audit policy is configured",
      "service": "core",
      "resource_type": "monitoring.audit_log",
      "scope": "monitoring.audit_log",
      "severity": "high",
      "domain_subcategory": "monitoring_observability.audit_logging",
      "rationale": "Comprehensive audit logging enables security monitoring and compliance.",
      "validation_method": "kubectl get configmap -n kube-system kube-apiserver",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ConfigMap"
      ],
      "rule_name": "core_prevent_audit_gaps_via_comprehensive_policy"
    },
    {
      "rule_id": "k8s.core.logs.log_collection.status_check.centralized_logging_enabled",
      "adapter": "k8s.core.logs.log_collection.status_check",
      "assertion_id": "monitoring_observability.log_collection.centralized_logging_enabled",
      "title": "Centralized log collection is enabled",
      "service": "core",
      "resource_type": "monitoring.logs",
      "scope": "monitoring.logs",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.log_collection",
      "rationale": "Centralized logging enables comprehensive security monitoring.",
      "validation_method": "kubectl get pods,daemonsets -n kube-system | grep logging",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "core_prevent_log_tampering_via_centralized_logging"
    },
    {
      "rule_id": "k8s.monitoring.metrics.prometheus.status_check.security_alerts_configured",
      "adapter": "k8s.monitoring.metrics.prometheus.status_check",
      "assertion_id": "monitoring_observability.monitoring_alerting.security_alerts_configured",
      "title": "Security alerting is configured for critical events",
      "service": "monitoring.coreos.com",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "high",
      "domain_subcategory": "monitoring_observability.monitoring_alerting",
      "rationale": "Security alerting enables rapid response to security incidents.",
      "validation_method": "kubectl get servicemonitors, kubectl get prometheusrules",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceMonitor",
        "PrometheusRule"
      ],
      "rule_name": "monitoring_prometheus_security_alerts_configured"
    },
    {
      "rule_id": "k8s.core.logs.log_retention.status_check.retention_policies_enforced",
      "adapter": "k8s.core.logs.log_retention.status_check",
      "assertion_id": "monitoring_observability.log_retention.retention_policies_enforced",
      "title": "Log retention policies are enforced",
      "service": "core",
      "resource_type": "monitoring.logs",
      "scope": "monitoring.logs",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.log_retention",
      "rationale": "Retention policies ensure compliance and forensic capability.",
      "validation_method": "kubectl get pods,daemonsets -n kube-system | grep logging",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "core_logs_retention_policies_enforced"
    },
    {
      "rule_id": "k8s.monitoring.metrics.log_analysis.status_check.correlation_enabled",
      "adapter": "k8s.monitoring.metrics.log_analysis.status_check",
      "assertion_id": "monitoring_observability.log_analysis.correlation_enabled",
      "title": "Log analysis and correlation is enabled",
      "service": "monitoring.coreos.com",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.log_analysis",
      "rationale": "Log correlation identifies complex attack patterns.",
      "validation_method": "kubectl get servicemonitors, kubectl get prometheusrules",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ServiceMonitor",
        "PrometheusRule"
      ],
      "rule_name": "monitoring_prevent_attack_hiding"
    },
    {
      "rule_id": "k8s.apps.deployment.security.security_check.resource_limits_configured",
      "adapter": "k8s.apps.deployment.security.security_check",
      "assertion_id": "workload_security.deployment_security.resource_limits_configured",
      "title": "Deployments have resource limits configured",
      "service": "apps",
      "resource_type": "workload.deployment",
      "scope": "workload.deployment",
      "severity": "medium",
      "domain_subcategory": "workload_security.deployment_security",
      "rationale": "Resource limits prevent resource exhaustion attacks and ensure cluster stability.",
      "validation_method": "kubectl get deployments,replicasets",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Deployment",
        "ReplicaSet"
      ],
      "rule_name": "apps_deployment_resource_limits_configured"
    },
    {
      "rule_id": "k8s.apps.daemonset.security.security_check.daemonset_host_access_controlled",
      "adapter": "k8s.apps.daemonset.security.security_check",
      "assertion_id": "workload_security.daemonset_security.daemonset_host_access_controlled",
      "title": "DaemonSets have controlled host access",
      "service": "apps",
      "resource_type": "workload.daemonset",
      "scope": "workload.daemonset",
      "severity": "high",
      "domain_subcategory": "workload_security.daemonset_security",
      "rationale": "DaemonSet host access controls prevent privilege escalation and resource abuse.",
      "validation_method": "kubectl get daemonsets",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "DaemonSet"
      ],
      "rule_name": "apps_daemonset_host_access_controlled"
    },
    {
      "rule_id": "k8s.apps.statefulset.security.security_check.persistence_secured",
      "adapter": "k8s.apps.statefulset.security.security_check",
      "assertion_id": "workload_security.statefulset_security.persistence_secured",
      "title": "StatefulSet persistent storage is secured",
      "service": "apps",
      "resource_type": "workload.statefulset",
      "scope": "workload.statefulset",
      "severity": "high",
      "domain_subcategory": "workload_security.statefulset_security",
      "rationale": "Securing StatefulSet persistence prevents data exposure.",
      "validation_method": "kubectl get statefulsets",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "StatefulSet"
      ],
      "rule_name": "apps_statefulset_persistence_secured"
    },
    {
      "rule_id": "k8s.batch.cronjob.security.security_check.execution_constraints_enforced",
      "adapter": "k8s.batch.cronjob.security.security_check",
      "assertion_id": "workload_security.cronjob_security.execution_constraints_enforced",
      "title": "CronJob execution constraints and security are enforced",
      "service": "batch",
      "resource_type": "workload.cronjob",
      "scope": "workload.cronjob",
      "severity": "medium",
      "domain_subcategory": "workload_security.cronjob_security",
      "rationale": "Execution constraints prevent CronJob abuse and resource exhaustion.",
      "validation_method": "kubectl get cronjobs",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "CronJob"
      ],
      "rule_name": "batch_cronjob_execution_constraints_enforced"
    },
    {
      "rule_id": "k8s.batch.job.security.security_check.completion_policies_enforced",
      "adapter": "k8s.batch.job.security.security_check",
      "assertion_id": "workload_security.job_security.completion_policies_enforced",
      "title": "Job completion policies and security are enforced",
      "service": "batch",
      "resource_type": "workload.job",
      "scope": "workload.job",
      "severity": "medium",
      "domain_subcategory": "workload_security.job_security",
      "rationale": "Completion policies ensure proper job lifecycle management.",
      "validation_method": "kubectl get jobs",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Job"
      ],
      "rule_name": "batch_job_completion_policies_enforced"
    },
    {
      "rule_id": "k8s.core.node.security.security_check.node_hardening_applied",
      "adapter": "k8s.core.node.security.security_check",
      "assertion_id": "infrastructure_security.node_security.node_hardening_applied",
      "title": "Worker nodes have security hardening applied",
      "service": "core",
      "resource_type": "infrastructure.node",
      "scope": "infrastructure.node",
      "severity": "high",
      "domain_subcategory": "infrastructure_security.node_security",
      "rationale": "Node hardening reduces attack surface and prevents host-level compromises.",
      "validation_method": "kubectl get nodes -o yaml",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Node"
      ],
      "rule_name": "core_node_security_node_hardening_applied"
    },
    {
      "rule_id": "k8s.core.container_runtime.security.security_check.runtime_security_enabled",
      "adapter": "k8s.core.container_runtime.security.security_check",
      "assertion_id": "infrastructure_security.container_runtime_security.runtime_security_enabled",
      "title": "Container runtime security is enabled",
      "service": "core",
      "resource_type": "infrastructure.container_runtime",
      "scope": "infrastructure.container_runtime",
      "severity": "medium",
      "domain_subcategory": "infrastructure_security.container_runtime_security",
      "rationale": "Container runtime security provides additional isolation and attack prevention.",
      "validation_method": "kubectl get nodes -o yaml | grep containerRuntime",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Node",
        "RuntimeClass"
      ],
      "rule_name": "core_prevent_runtime_escape"
    },
    {
      "rule_id": "k8s.core.namespace.governance.governance_check.resource_quotas_enforced",
      "adapter": "k8s.core.namespace.governance.governance_check",
      "assertion_id": "compliance_governance.namespace_governance.resource_quotas_enforced",
      "title": "Resource quotas are enforced at namespace level",
      "service": "core",
      "resource_type": "compliance.namespace",
      "scope": "compliance.resource_quota",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.namespace_governance",
      "rationale": "Resource quotas prevent resource exhaustion and ensure fair resource allocation.",
      "validation_method": "kubectl get namespaces",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Namespace"
      ],
      "rule_name": "core_namespace_governance_governance_resource_quotas_enforced"
    },
    {
      "rule_id": "k8s.core.resource_quota.governance.governance_check.resource_quotas_enforced",
      "adapter": "k8s.core.resource_quota.governance.governance_check",
      "assertion_id": "compliance_governance.namespace_governance.resource_quotas_enforced",
      "title": "Resource quotas are enforced at namespace level",
      "service": "core",
      "resource_type": "compliance.resource_quota",
      "scope": "compliance.resource_quota",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.namespace_governance",
      "rationale": "Resource quotas prevent resource exhaustion and ensure fair resource allocation.",
      "validation_method": "kubectl get resourcequotas",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "ResourceQuota"
      ],
      "rule_name": "core_resource_quota_governance_governance_resource_quotas_enforced"
    },
    {
      "rule_id": "k8s.core.namespace.compliance.compliance_check.cis_benchmark_compliance",
      "adapter": "k8s.core.namespace.compliance.compliance_check",
      "assertion_id": "compliance_governance.compliance_frameworks.cis_benchmark_compliance",
      "title": "CIS Kubernetes Benchmark compliance is enforced",
      "service": "core",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.compliance_frameworks",
      "rationale": "CIS Benchmark compliance ensures industry-standard security practices.",
      "validation_method": "kubectl get namespaces -o yaml | grep labels",
      "not_applicable_when": "resource_not_configured",
      "k8s_resources": [
        "Namespace"
      ],
      "rule_name": "core_namespace_compliance_compliance_cis_benchmark_compliance"
    },
    {
      "rule_id": "k8s.networking.network_segmentation.zero_trust.micro_segmentation_status.micro_segmentation_enabled",
      "adapter": "k8s.networking.network_segmentation.zero_trust.micro_segmentation_status",
      "assertion_id": "zero_trust_security.zero_trust_networking.micro_segmentation_enabled",
      "title": "Micro-segmentation is enabled for network traffic",
      "service": "networking.k8s.io",
      "resource_type": "zero_trust.network_segmentation",
      "scope": "zero_trust.network_segmentation",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.zero_trust_networking",
      "rationale": "Micro-segmentation provides fine-grained network isolation and reduces attack surface.",
      "validation_method": "kubectl get networkpolicies --all-namespaces, kubectl get namespaces",
      "not_applicable_when": "no_network_policies_configured",
      "k8s_resources": [
        "NetworkPolicy",
        "Namespace"
      ],
      "rule_name": "networking_network_segmentation_zero_trust_micro_segmentation_status_micro_segmentation_enabled"
    },
    {
      "rule_id": "k8s.networking.network_segmentation.default_deny.default_deny_enforcement.micro_segmentation_enabled",
      "adapter": "k8s.networking.network_segmentation.default_deny.default_deny_enforcement",
      "assertion_id": "zero_trust_security.zero_trust_networking.micro_segmentation_enabled",
      "title": "Micro-segmentation is enabled for network traffic",
      "service": "networking.k8s.io",
      "resource_type": "zero_trust.network_segmentation",
      "scope": "zero_trust.network_segmentation",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.zero_trust_networking",
      "rationale": "Micro-segmentation provides fine-grained network isolation and reduces attack surface.",
      "validation_method": "kubectl get networkpolicies -o yaml",
      "not_applicable_when": "no_network_policies_configured",
      "k8s_resources": [
        "NetworkPolicy"
      ],
      "rule_name": "networking_network_segmentation_default_deny_default_deny_enforcement_micro_segmentation_enabled"
    },
    {
      "rule_id": "k8s.networking.service_mesh.mtls.mtls_enforcement_status.mtls_enforced",
      "adapter": "k8s.networking.service_mesh.mtls.mtls_enforcement_status",
      "assertion_id": "zero_trust_security.service_to_service_encryption.mtls_enforced",
      "title": "Mutual TLS is enforced for service-to-service communication",
      "service": "networking.k8s.io",
      "resource_type": "zero_trust.service_mesh",
      "scope": "zero_trust.service_mesh",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.service_to_service_encryption",
      "rationale": "mTLS ensures encrypted and authenticated communication between services.",
      "validation_method": "kubectl get services, kubectl get configmaps, kubectl get secrets",
      "not_applicable_when": "no_service_mesh_configured",
      "k8s_resources": [
        "Service",
        "ConfigMap",
        "Secret"
      ],
      "rule_name": "networking_service_mesh_mtls_mtls_enforcement_status_mtls_enforced"
    },
    {
      "rule_id": "k8s.networking.service_mesh.mtls.mtls_policy_validation.mtls_enforced",
      "adapter": "k8s.networking.service_mesh.mtls.mtls_policy_validation",
      "assertion_id": "zero_trust_security.service_to_service_encryption.mtls_enforced",
      "title": "Mutual TLS is enforced for service-to-service communication",
      "service": "networking.k8s.io",
      "resource_type": "zero_trust.service_mesh",
      "scope": "zero_trust.service_mesh",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.service_to_service_encryption",
      "rationale": "mTLS ensures encrypted and authenticated communication between services.",
      "validation_method": "kubectl get peerauthentications, kubectl get destinationrules",
      "not_applicable_when": "istio_not_installed",
      "k8s_resources": [
        "PeerAuthentication",
        "DestinationRule"
      ],
      "rule_name": "networking_service_mesh_mtls_mtls_policy_mtls_enforced"
    },
    {
      "rule_id": "k8s.security.dlp.dlp.dlp_policy_enforcement.dlp_policies_enforced",
      "adapter": "k8s.security.dlp.dlp.dlp_policy_enforcement",
      "assertion_id": "data_protection.data_loss_prevention.dlp_policies_enforced",
      "title": "Data loss prevention policies are enforced",
      "service": "security.k8s.io",
      "resource_type": "data.dlp",
      "scope": "data.dlp",
      "severity": "high",
      "domain_subcategory": "data_protection.data_loss_prevention",
      "rationale": "DLP policies prevent sensitive data exfiltration.",
      "validation_method": "kubectl get networkpolicies, kubectl get pods",
      "not_applicable_when": "no_dlp_policies_configured",
      "k8s_resources": [
        "NetworkPolicy",
        "Pod"
      ],
      "rule_name": "security_dlp_policies_enforced"
    },
    {
      "rule_id": "k8s.security.dlp.dlp.data_exfiltration_prevention.dlp_policies_enforced",
      "adapter": "k8s.security.dlp.dlp.data_exfiltration_prevention",
      "assertion_id": "data_protection.data_loss_prevention.dlp_policies_enforced",
      "title": "Data loss prevention policies are enforced",
      "service": "security.k8s.io",
      "resource_type": "data.dlp",
      "scope": "data.dlp",
      "severity": "high",
      "domain_subcategory": "data_protection.data_loss_prevention",
      "rationale": "DLP policies prevent sensitive data exfiltration.",
      "validation_method": "kubectl get pods, kubectl get networkpolicies",
      "not_applicable_when": "no_dlp_policies_configured",
      "k8s_resources": [
        "Pod",
        "NetworkPolicy"
      ],
      "rule_name": "security_dlp_data_exfiltration_prevention_enforced"
    },
    {
      "rule_id": "k8s.security.forensics.hunting.threat_hunting_enabled.proactive_hunting_enabled",
      "adapter": "k8s.security.forensics.hunting.threat_hunting_enabled",
      "assertion_id": "incident_response.threat_hunting.proactive_hunting_enabled",
      "title": "Proactive threat hunting is enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.forensics",
      "scope": "incident.forensics",
      "severity": "medium",
      "domain_subcategory": "incident_response.threat_hunting",
      "rationale": "Proactive threat hunting identifies advanced persistent threats.",
      "validation_method": "kubectl get events, kubectl get pods",
      "not_applicable_when": "no_events_collected",
      "k8s_resources": [
        "Event",
        "Pod"
      ],
      "rule_name": "security_prevent_attack_hiding_via_threat_hunting"
    },
    {
      "rule_id": "k8s.security.forensics.behavior.behavioral_analysis_tools.proactive_hunting_enabled",
      "adapter": "k8s.security.forensics.behavior.behavioral_analysis_tools",
      "assertion_id": "incident_response.threat_hunting.proactive_hunting_enabled",
      "title": "Proactive threat hunting is enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.forensics",
      "scope": "incident.forensics",
      "severity": "medium",
      "domain_subcategory": "incident_response.threat_hunting",
      "rationale": "Proactive threat hunting identifies advanced persistent threats.",
      "validation_method": "kubectl get pods, kubectl get daemonsets",
      "not_applicable_when": "no_behavioral_analysis",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "security_prevent_behavioral_evasion_via_behavioral_analysis"
    },
    {
      "rule_id": "k8s.security.deployment.identity.identity_verification_status.identity_verification_enabled",
      "adapter": "k8s.security.deployment.identity.identity_verification_status",
      "assertion_id": "zero_trust_security.continuous_verification.identity_verification_enabled",
      "title": "Continuous identity verification is enabled",
      "service": "security.k8s.io",
      "resource_type": "workload.deployment",
      "scope": "workload.deployment",
      "severity": "medium",
      "domain_subcategory": "zero_trust_security.continuous_verification",
      "rationale": "Continuous verification ensures ongoing authentication and authorization.",
      "validation_method": "kubectl get deployments, kubectl get serviceaccounts",
      "not_applicable_when": "no_deployments_configured",
      "k8s_resources": [
        "Deployment",
        "ServiceAccount"
      ],
      "rule_name": "security_prevent_deployment_spoofing"
    },
    {
      "rule_id": "k8s.security.service_account.token.token_binding_validation.identity_verification_enabled",
      "adapter": "k8s.security.service_account.token.token_binding_validation",
      "assertion_id": "zero_trust_security.continuous_verification.identity_verification_enabled",
      "title": "Continuous identity verification is enabled",
      "service": "security.k8s.io",
      "resource_type": "identity.service_account",
      "scope": "workload.deployment",
      "severity": "medium",
      "domain_subcategory": "zero_trust_security.continuous_verification",
      "rationale": "Continuous verification ensures ongoing authentication and authorization.",
      "validation_method": "kubectl get serviceaccounts, kubectl get tokenrequests",
      "not_applicable_when": "no_service_accounts_configured",
      "k8s_resources": [
        "ServiceAccount",
        "TokenRequest"
      ],
      "rule_name": "security_service_account_token_binding_validation_enabled"
    },
    {
      "rule_id": "k8s.networking.network_policy.pod_segment.pod_level_segmentation.network_policies_enforced",
      "adapter": "k8s.networking.network_policy.pod_segment.pod_level_segmentation",
      "assertion_id": "zero_trust_security.micro_segmentation.network_policies_enforced",
      "title": "Network policies enforce micro-segmentation",
      "service": "networking.k8s.io",
      "resource_type": "network.network_policy",
      "scope": "network.network_policy",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.micro_segmentation",
      "rationale": "Network policies implement micro-segmentation at the pod level.",
      "validation_method": "kubectl get networkpolicies, kubectl get pods",
      "not_applicable_when": "no_network_policies_configured",
      "k8s_resources": [
        "NetworkPolicy",
        "Pod"
      ],
      "rule_name": "networking_network_policy_pod_segment_pod_level_segmentation_network_policies_enforced"
    },
    {
      "rule_id": "k8s.networking.network_policy.namespace.namespace_isolation_status.network_policies_enforced",
      "adapter": "k8s.networking.network_policy.namespace.namespace_isolation_status",
      "assertion_id": "zero_trust_security.micro_segmentation.network_policies_enforced",
      "title": "Network policies enforce micro-segmentation",
      "service": "networking.k8s.io",
      "resource_type": "network.network_policy",
      "scope": "network.network_policy",
      "severity": "high",
      "domain_subcategory": "zero_trust_security.micro_segmentation",
      "rationale": "Network policies implement micro-segmentation at the pod level.",
      "validation_method": "kubectl get networkpolicies --all-namespaces",
      "not_applicable_when": "no_network_policies_configured",
      "k8s_resources": [
        "NetworkPolicy",
        "Namespace"
      ],
      "rule_name": "networking_network_policy_namespace_namespace_isolation_status_network_policies_enforced"
    },
    {
      "rule_id": "k8s.security.gdpr.gdpr.gdpr_compliance_status.gdpr_compliance_enabled",
      "adapter": "k8s.security.gdpr.gdpr.gdpr_compliance_status",
      "assertion_id": "data_protection.privacy_controls.gdpr_compliance_enabled",
      "title": "GDPR privacy controls are implemented",
      "service": "security.k8s.io",
      "resource_type": "privacy.gdpr",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "data_protection.privacy_controls",
      "rationale": "Privacy controls ensure compliance with data protection regulations.",
      "validation_method": "kubectl get secrets, kubectl get configmaps",
      "not_applicable_when": "no_sensitive_data_processed",
      "k8s_resources": [
        "Secret",
        "ConfigMap"
      ],
      "rule_name": "security_prevent_privacy_breach"
    },
    {
      "rule_id": "k8s.security.gdpr.retention.data_retention_policy.gdpr_compliance_enabled",
      "adapter": "k8s.security.gdpr.retention.data_retention_policy",
      "assertion_id": "data_protection.privacy_controls.gdpr_compliance_enabled",
      "title": "GDPR privacy controls are implemented",
      "service": "security.k8s.io",
      "resource_type": "privacy.gdpr",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "data_protection.privacy_controls",
      "rationale": "Privacy controls ensure compliance with data protection regulations.",
      "validation_method": "kubectl get pods, kubectl get persistentvolumes",
      "not_applicable_when": "no_persistent_data_stored",
      "k8s_resources": [
        "Pod",
        "PersistentVolume"
      ],
      "rule_name": "security_prevent_data_retention_violation"
    },
    {
      "rule_id": "k8s.security.classification.classification.data_classification_labels.labels_enforced",
      "adapter": "k8s.security.classification.classification.data_classification_labels",
      "assertion_id": "data_protection.data_classification.labels_enforced",
      "title": "Data classification labels are enforced",
      "service": "security.k8s.io",
      "resource_type": "data.classification",
      "scope": "data.classification",
      "severity": "medium",
      "domain_subcategory": "data_protection.data_classification",
      "rationale": "Data classification enables appropriate protection controls.",
      "validation_method": "kubectl get secrets --show-labels, kubectl get configmaps --show-labels",
      "not_applicable_when": "no_classified_data",
      "k8s_resources": [
        "Secret",
        "ConfigMap"
      ],
      "rule_name": "security_classification_labels_enforced"
    },
    {
      "rule_id": "k8s.security.classification.sensitivity.sensitivity_label_validation.labels_enforced",
      "adapter": "k8s.security.classification.sensitivity.sensitivity_label_validation",
      "assertion_id": "data_protection.data_classification.labels_enforced",
      "title": "Data classification labels are enforced",
      "service": "security.k8s.io",
      "resource_type": "data.classification",
      "scope": "data.classification",
      "severity": "medium",
      "domain_subcategory": "data_protection.data_classification",
      "rationale": "Data classification enables appropriate protection controls.",
      "validation_method": "kubectl get pods --show-labels, kubectl get namespaces --show-labels",
      "not_applicable_when": "no_sensitivity_labels",
      "k8s_resources": [
        "Pod",
        "Namespace"
      ],
      "rule_name": "security_classification_sensitivity_labels_enforced"
    },
    {
      "rule_id": "k8s.security.classification.geo.geographic_location_validation.transfer_controls_enabled",
      "adapter": "k8s.security.classification.geo.geographic_location_validation",
      "assertion_id": "data_protection.cross_border_transfer.transfer_controls_enabled",
      "title": "Cross-border data transfer controls are enabled",
      "service": "security.k8s.io",
      "resource_type": "data.classification",
      "scope": "data.classification",
      "severity": "medium",
      "domain_subcategory": "data_protection.cross_border_transfer",
      "rationale": "Transfer controls ensure compliance with data residency requirements.",
      "validation_method": "kubectl get nodes --show-labels, kubectl get namespaces",
      "not_applicable_when": "no_geographic_restrictions",
      "k8s_resources": [
        "Node",
        "Namespace"
      ],
      "rule_name": "security_classification_geo_transfer_controls_enabled"
    },
    {
      "rule_id": "k8s.security.classification.residency.data_residency_check.transfer_controls_enabled",
      "adapter": "k8s.security.classification.residency.data_residency_check",
      "assertion_id": "data_protection.cross_border_transfer.transfer_controls_enabled",
      "title": "Cross-border data transfer controls are enabled",
      "service": "security.k8s.io",
      "resource_type": "data.classification",
      "scope": "data.classification",
      "severity": "medium",
      "domain_subcategory": "data_protection.cross_border_transfer",
      "rationale": "Transfer controls ensure compliance with data residency requirements.",
      "validation_method": "kubectl get persistentvolumes, kubectl get storageclasses",
      "not_applicable_when": "no_persistent_storage",
      "k8s_resources": [
        "PersistentVolume",
        "StorageClass"
      ],
      "rule_name": "security_classification_residency_transfer_controls_enabled"
    },
    {
      "rule_id": "k8s.security.automation.automation.automated_response_enabled.automated_containment_enabled",
      "adapter": "k8s.security.automation.automation.automated_response_enabled",
      "assertion_id": "incident_response.automated_containment_enabled",
      "title": "Automated incident containment is enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.automation",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "incident_response.automated_response",
      "rationale": "Automated containment reduces incident impact and response time.",
      "validation_method": "kubectl get events, kubectl get pods",
      "not_applicable_when": "no_incident_response_configured",
      "k8s_resources": [
        "Event",
        "Pod"
      ],
      "rule_name": "security_prevent_attack_spread_via_automated_containment"
    },
    {
      "rule_id": "k8s.security.automation.playbook.security_playbook_execution.automated_containment_enabled",
      "adapter": "k8s.security.automation.playbook.security_playbook_execution",
      "assertion_id": "incident_response.automated_containment_enabled",
      "title": "Automated incident containment is enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.automation",
      "scope": "api.api_server",
      "severity": "medium",
      "domain_subcategory": "incident_response.automated_response",
      "rationale": "Automated containment reduces incident impact and response time.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_automated_playbooks",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_automation_playbook_execution_enabled"
    },
    {
      "rule_id": "k8s.security.forensics.forensics.forensic_data_collection.incident_forensics_enabled",
      "adapter": "k8s.security.forensics.forensics.forensic_data_collection",
      "assertion_id": "incident_response.forensic_capabilities.incident_forensics_enabled",
      "title": "Incident forensic capabilities are enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.forensics",
      "scope": "monitoring.audit_log",
      "severity": "medium",
      "domain_subcategory": "incident_response.forensic_capabilities",
      "rationale": "Forensic capabilities enable proper incident investigation and evidence collection.",
      "validation_method": "kubectl get pods, kubectl get persistentvolumes",
      "not_applicable_when": "no_forensic_tools_installed",
      "k8s_resources": [
        "Pod",
        "PersistentVolume"
      ],
      "rule_name": "security_prevent_evidence_destruction_via_data_collection"
    },
    {
      "rule_id": "k8s.security.forensics.forensics.forensic_log_preservation.incident_forensics_enabled",
      "adapter": "k8s.security.forensics.forensics.forensic_log_preservation",
      "assertion_id": "incident_response.forensic_capabilities.incident_forensics_enabled",
      "title": "Incident forensic capabilities are enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.forensics",
      "scope": "monitoring.audit_log",
      "severity": "medium",
      "domain_subcategory": "incident_response.forensic_capabilities",
      "rationale": "Forensic capabilities enable proper incident investigation and evidence collection.",
      "validation_method": "kubectl get configmaps, kubectl get secrets",
      "not_applicable_when": "no_audit_logging_enabled",
      "k8s_resources": [
        "ConfigMap",
        "Secret"
      ],
      "rule_name": "security_prevent_log_tampering_via_log_preservation"
    },
    {
      "rule_id": "k8s.security.automation.orchestration.security_orchestration_status.playbooks_automated",
      "adapter": "k8s.security.automation.orchestration.security_orchestration_status",
      "assertion_id": "incident_response.security_orchestration.playbooks_automated",
      "title": "Security orchestration and automated playbooks are enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.automation",
      "scope": "incident.automation",
      "severity": "medium",
      "domain_subcategory": "incident_response.security_orchestration",
      "rationale": "Automated playbooks enable rapid incident response.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_orchestration_tools",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_automation_orchestration_playbooks_automated"
    },
    {
      "rule_id": "k8s.security.automation.automation.security_response_automation.playbooks_automated",
      "adapter": "k8s.security.automation.automation.security_response_automation",
      "assertion_id": "incident_response.security_orchestration.playbooks_automated",
      "title": "Security orchestration and automated playbooks are enabled",
      "service": "security.k8s.io",
      "resource_type": "incident.automation",
      "scope": "incident.automation",
      "severity": "medium",
      "domain_subcategory": "incident_response.security_orchestration",
      "rationale": "Automated playbooks enable rapid incident response.",
      "validation_method": "kubectl get services, kubectl get configmaps",
      "not_applicable_when": "no_automation_configured",
      "k8s_resources": [
        "Service",
        "ConfigMap"
      ],
      "rule_name": "security_automation_response_automation_enabled"
    },
    {
      "rule_id": "k8s.security.user.mfa.mfa_enforcement_status.mfa_enforced",
      "adapter": "k8s.security.user.mfa.mfa_enforcement_status",
      "assertion_id": "identity_access.multi_factor_authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "security.k8s.io",
      "resource_type": "identity.user",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.multi_factor_authentication",
      "rationale": "MFA provides additional security layer for administrative access.",
      "validation_method": "kubectl get users, kubectl get configmaps",
      "not_applicable_when": "no_external_auth_configured",
      "k8s_resources": [
        "User",
        "ConfigMap"
      ],
      "rule_name": "security_user_mfa_enforced"
    },
    {
      "rule_id": "k8s.security.user.oidc.oidc_mfa_validation.mfa_enforced",
      "adapter": "k8s.security.user.oidc.oidc_mfa_validation",
      "assertion_id": "identity_access.multi_factor_authentication.mfa_enforced",
      "title": "Multi-factor authentication is enforced for administrative access",
      "service": "security.k8s.io",
      "resource_type": "identity.user",
      "scope": "identity.user",
      "severity": "high",
      "domain_subcategory": "identity_access.multi_factor_authentication",
      "rationale": "MFA provides additional security layer for administrative access.",
      "validation_method": "kubectl get configmaps, kubectl get secrets",
      "not_applicable_when": "no_oidc_configured",
      "k8s_resources": [
        "ConfigMap",
        "Secret"
      ],
      "rule_name": "security_user_oidc_mfa_enforced"
    },
    {
      "rule_id": "k8s.security.user.rotation.rotation_policy_status.automated_rotation_enabled",
      "adapter": "k8s.security.user.rotation.rotation_policy_status",
      "assertion_id": "identity_access.certificate_lifecycle.automated_rotation_enabled",
      "title": "Automated certificate rotation is enabled",
      "service": "security.k8s.io",
      "resource_type": "identity.user",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.certificate_lifecycle",
      "rationale": "Automated certificate rotation prevents expired certificates and security risks.",
      "validation_method": "kubectl get csr, kubectl get secrets",
      "not_applicable_when": "no_certificates_configured",
      "k8s_resources": [
        "CertificateSigningRequest",
        "Secret"
      ],
      "rule_name": "security_prevent_user_credential_staleness"
    },
    {
      "rule_id": "k8s.security.user.expiry.expiry_monitoring.automated_rotation_enabled",
      "adapter": "k8s.security.user.expiry.expiry_monitoring",
      "assertion_id": "identity_access.certificate_lifecycle.automated_rotation_enabled",
      "title": "Automated certificate rotation is enabled",
      "service": "security.k8s.io",
      "resource_type": "identity.user",
      "scope": "api.api_server",
      "severity": "high",
      "domain_subcategory": "identity_access.certificate_lifecycle",
      "rationale": "Automated certificate rotation prevents expired certificates and security risks.",
      "validation_method": "kubectl get csr, kubectl get pods",
      "not_applicable_when": "no_certificates_configured",
      "k8s_resources": [
        "CertificateSigningRequest",
        "Pod"
      ],
      "rule_name": "security_prevent_user_credential_expiry"
    },
    {
      "rule_id": "k8s.security.cluster_role_binding.emergency.emergency_access_controls.break_glass_controls",
      "adapter": "k8s.security.cluster_role_binding.emergency.emergency_access_controls",
      "assertion_id": "identity_access.emergency_access.break_glass_controls",
      "title": "Break-glass emergency access controls are configured",
      "service": "security.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.cluster_role_binding",
      "severity": "medium",
      "domain_subcategory": "identity_access.emergency_access",
      "rationale": "Emergency access controls provide secure temporary access during incidents.",
      "validation_method": "kubectl get clusterrolebindings, kubectl get configmaps",
      "not_applicable_when": "no_emergency_access_configured",
      "k8s_resources": [
        "ClusterRoleBinding",
        "ConfigMap"
      ],
      "rule_name": "security_cluster_role_binding_emergency_access_controls"
    },
    {
      "rule_id": "k8s.security.cluster_role_binding.break_glass.break_glass_audit.break_glass_controls",
      "adapter": "k8s.security.cluster_role_binding.break_glass.break_glass_audit",
      "assertion_id": "identity_access.emergency_access.break_glass_controls",
      "title": "Break-glass emergency access controls are configured",
      "service": "security.k8s.io",
      "resource_type": "rbac.cluster_role_binding",
      "scope": "rbac.cluster_role_binding",
      "severity": "medium",
      "domain_subcategory": "identity_access.emergency_access",
      "rationale": "Emergency access controls provide secure temporary access during incidents.",
      "validation_method": "kubectl get clusterrolebindings, kubectl get events",
      "not_applicable_when": "no_emergency_access_configured",
      "k8s_resources": [
        "ClusterRoleBinding",
        "Event"
      ],
      "rule_name": "security_cluster_role_binding_break_glass_audit"
    },
    {
      "rule_id": "k8s.security.container.signing.image_signing_validation.image_signing_verified",
      "adapter": "k8s.security.container.signing.image_signing_validation",
      "assertion_id": "pod_container_security.supply_chain_security.image_signing_verified",
      "title": "Container images are cryptographically signed and verified",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "high",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "Image signing ensures image integrity and prevents tampering.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "no_image_signing_configured",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_container_image_signing_verified"
    },
    {
      "rule_id": "k8s.security.container.signing.image_signing_validation.sbom_management_enabled",
      "adapter": "k8s.security.container.signing.image_signing_validation",
      "assertion_id": "pod_container_security.supply_chain_security.sbom_management_enabled",
      "title": "Software Bill of Materials (SBOM) is generated and managed",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "SBOM provides transparency into software components and vulnerabilities.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "no_image_signing_configured",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_container_sbom_management_enabled"
    },
    {
      "rule_id": "k8s.security.container.signing.image_signing_validation.vulnerability_scanning_enabled",
      "adapter": "k8s.security.container.signing.image_signing_validation",
      "assertion_id": "pod_container_security.supply_chain_security.vulnerability_scanning_enabled",
      "title": "Automated vulnerability scanning is enabled for container images",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "high",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "Vulnerability scanning identifies and prevents deployment of vulnerable images.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "no_image_signing_configured",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_prevent_known_vulnerabilities"
    },
    {
      "rule_id": "k8s.security.container.vuln.vulnerability_scanning_status.image_signing_verified",
      "adapter": "k8s.security.container.vuln.vulnerability_scanning_status",
      "assertion_id": "pod_container_security.supply_chain_security.image_signing_verified",
      "title": "Container images are cryptographically signed and verified",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "high",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "Image signing ensures image integrity and prevents tampering.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_vulnerability_scanning",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_container_vuln_vulnerability_scanning_status_image_signing_verified"
    },
    {
      "rule_id": "k8s.security.container.vuln.vulnerability_scanning_status.sbom_management_enabled",
      "adapter": "k8s.security.container.vuln.vulnerability_scanning_status",
      "assertion_id": "pod_container_security.supply_chain_security.sbom_management_enabled",
      "title": "Software Bill of Materials (SBOM) is generated and managed",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "SBOM provides transparency into software components and vulnerabilities.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_vulnerability_scanning",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_container_vuln_vulnerability_scanning_status_sbom_management_enabled"
    },
    {
      "rule_id": "k8s.security.container.vuln.vulnerability_scanning_status.vulnerability_scanning_enabled",
      "adapter": "k8s.security.container.vuln.vulnerability_scanning_status",
      "assertion_id": "pod_container_security.supply_chain_security.vulnerability_scanning_enabled",
      "title": "Automated vulnerability scanning is enabled for container images",
      "service": "security.k8s.io",
      "resource_type": "container.container",
      "scope": "supply_chain.image",
      "severity": "high",
      "domain_subcategory": "pod_container_security.supply_chain_security",
      "rationale": "Vulnerability scanning identifies and prevents deployment of vulnerable images.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_vulnerability_scanning",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_container_vuln_vulnerability_scanning_status_vulnerability_scanning_enabled"
    },
    {
      "rule_id": "k8s.security.node.falco.falco_runtime_monitoring.anomaly_detection_enabled",
      "adapter": "k8s.security.node.falco.falco_runtime_monitoring",
      "assertion_id": "pod_container_security.behavioral_analysis.anomaly_detection_enabled",
      "title": "Behavioral analysis and anomaly detection is enabled",
      "service": "security.k8s.io",
      "resource_type": "infrastructure.node",
      "scope": "infrastructure.node",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.behavioral_analysis",
      "rationale": "Behavioral analysis detects deviations from normal patterns.",
      "validation_method": "kubectl get pods, kubectl get daemonsets",
      "not_applicable_when": "falco_not_installed",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "security_node_falco_falco_runtime_monitoring_anomaly_detection_enabled"
    },
    {
      "rule_id": "k8s.security.node.ebpf.ebpf_security_monitoring.anomaly_detection_enabled",
      "adapter": "k8s.security.node.ebpf.ebpf_security_monitoring",
      "assertion_id": "pod_container_security.behavioral_analysis.anomaly_detection_enabled",
      "title": "Behavioral analysis and anomaly detection is enabled",
      "service": "security.k8s.io",
      "resource_type": "infrastructure.node",
      "scope": "infrastructure.node",
      "severity": "medium",
      "domain_subcategory": "pod_container_security.behavioral_analysis",
      "rationale": "Behavioral analysis detects deviations from normal patterns.",
      "validation_method": "kubectl get pods, kubectl get daemonsets",
      "not_applicable_when": "ebpf_not_available",
      "k8s_resources": [
        "Pod",
        "DaemonSet"
      ],
      "rule_name": "security_node_ebpf_ebpf_security_monitoring_anomaly_detection_enabled"
    },
    {
      "rule_id": "k8s.security.metrics.threat.threat_detection_rules.anomaly_detection_enabled",
      "adapter": "k8s.security.metrics.threat.threat_detection_rules",
      "assertion_id": "monitoring_observability.threat_detection.anomaly_detection_enabled",
      "title": "Anomaly detection is enabled for security events",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.threat_detection",
      "rationale": "Anomaly detection identifies unusual patterns that may indicate security threats.",
      "validation_method": "kubectl get prometheusrules, kubectl get servicemonitors",
      "not_applicable_when": "prometheus_not_installed",
      "k8s_resources": [
        "PrometheusRule",
        "ServiceMonitor"
      ],
      "rule_name": "security_metrics_threat_threat_detection_rules_anomaly_detection_enabled"
    },
    {
      "rule_id": "k8s.security.metrics.security.security_alerting.anomaly_detection_enabled",
      "adapter": "k8s.security.metrics.security.security_alerting",
      "assertion_id": "monitoring_observability.threat_detection.anomaly_detection_enabled",
      "title": "Anomaly detection is enabled for security events",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.threat_detection",
      "rationale": "Anomaly detection identifies unusual patterns that may indicate security threats.",
      "validation_method": "kubectl get alertmanagers, kubectl get configmaps",
      "not_applicable_when": "alertmanager_not_installed",
      "k8s_resources": [
        "Alertmanager",
        "ConfigMap"
      ],
      "rule_name": "security_metrics_anomaly_detection_enabled"
    },
    {
      "rule_id": "k8s.security.metrics.security.security_dashboard_status.security_events_monitored",
      "adapter": "k8s.security.metrics.security.security_dashboard_status",
      "assertion_id": "monitoring_observability.security_monitoring.security_events_monitored",
      "title": "Security events are monitored and alerted",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.security_monitoring",
      "rationale": "Security monitoring enables detection of threats and anomalous behavior.",
      "validation_method": "kubectl get configmaps, kubectl get services",
      "not_applicable_when": "grafana_not_installed",
      "k8s_resources": [
        "ConfigMap",
        "Service"
      ],
      "rule_name": "security_metrics_events_monitored"
    },
    {
      "rule_id": "k8s.security.metrics.security.security_dashboard_status.behavioral_analysis_enabled",
      "adapter": "k8s.security.metrics.security.security_dashboard_status",
      "assertion_id": "monitoring_observability.security_monitoring.behavioral_analysis_enabled",
      "title": "Behavioral analysis is enabled for security monitoring",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.security_monitoring",
      "rationale": "Behavioral analysis detects deviations from normal cluster operation patterns.",
      "validation_method": "kubectl get configmaps, kubectl get services",
      "not_applicable_when": "grafana_not_installed",
      "k8s_resources": [
        "ConfigMap",
        "Service"
      ],
      "rule_name": "security_metrics_behavioral_analysis_enabled"
    },
    {
      "rule_id": "k8s.security.metrics.security.security_log_aggregation.security_events_monitored",
      "adapter": "k8s.security.metrics.security.security_log_aggregation",
      "assertion_id": "monitoring_observability.security_monitoring.security_events_monitored",
      "title": "Security events are monitored and alerted",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.security_monitoring",
      "rationale": "Security monitoring enables detection of threats and anomalous behavior.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "fluentd_not_installed",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_metrics_log_events_monitored"
    },
    {
      "rule_id": "k8s.security.metrics.security.security_log_aggregation.behavioral_analysis_enabled",
      "adapter": "k8s.security.metrics.security.security_log_aggregation",
      "assertion_id": "monitoring_observability.security_monitoring.behavioral_analysis_enabled",
      "title": "Behavioral analysis is enabled for security monitoring",
      "service": "security.k8s.io",
      "resource_type": "monitoring.metrics",
      "scope": "monitoring.metrics",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.security_monitoring",
      "rationale": "Behavioral analysis detects deviations from normal cluster operation patterns.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "fluentd_not_installed",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_metrics_log_behavioral_analysis_enabled"
    },
    {
      "rule_id": "k8s.security.audit_log.compliance.compliance_reporting_automation.automated_compliance_dashboard",
      "adapter": "k8s.security.audit_log.compliance.compliance_reporting_automation",
      "assertion_id": "monitoring_observability.compliance_reporting.automated_compliance_dashboard",
      "title": "Automated compliance reporting dashboard is enabled",
      "service": "security.k8s.io",
      "resource_type": "monitoring.audit_log",
      "scope": "monitoring.audit_log",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.compliance_reporting",
      "rationale": "Automated compliance reporting provides real-time visibility into security posture.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_compliance_reporting",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_audit_log_compliance_compliance_reporting_automation_automated_compliance_dashboard"
    },
    {
      "rule_id": "k8s.security.audit_log.regulatory.regulatory_framework_alignment.automated_compliance_dashboard",
      "adapter": "k8s.security.audit_log.regulatory.regulatory_framework_alignment",
      "assertion_id": "monitoring_observability.compliance_reporting.automated_compliance_dashboard",
      "title": "Automated compliance reporting dashboard is enabled",
      "service": "security.k8s.io",
      "resource_type": "monitoring.audit_log",
      "scope": "monitoring.audit_log",
      "severity": "medium",
      "domain_subcategory": "monitoring_observability.compliance_reporting",
      "rationale": "Automated compliance reporting provides real-time visibility into security posture.",
      "validation_method": "kubectl get configmaps, kubectl get secrets",
      "not_applicable_when": "no_regulatory_requirements",
      "k8s_resources": [
        "ConfigMap",
        "Secret"
      ],
      "rule_name": "security_audit_log_regulatory_regulatory_framework_alignment_automated_compliance_dashboard"
    },
    {
      "rule_id": "k8s.security.namespace.policy.policy_sync_status.gitops_integration_enabled",
      "adapter": "k8s.security.namespace.policy.policy_sync_status",
      "assertion_id": "compliance_governance.policy_as_code.gitops_integration_enabled",
      "title": "GitOps integration is enabled for policy management",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.policy_as_code",
      "rationale": "GitOps integration ensures policy changes are version-controlled and auditable.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "gitops_not_configured",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_namespace_gitops_sync_enabled"
    },
    {
      "rule_id": "k8s.security.namespace.policy.policy_deployment_validation.gitops_integration_enabled",
      "adapter": "k8s.security.namespace.policy.policy_deployment_validation",
      "assertion_id": "compliance_governance.policy_as_code.gitops_integration_enabled",
      "title": "GitOps integration is enabled for policy management",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.policy_as_code",
      "rationale": "GitOps integration ensures policy changes are version-controlled and auditable.",
      "validation_method": "kubectl get applications, kubectl get configmaps",
      "not_applicable_when": "argocd_not_installed",
      "k8s_resources": [
        "Application",
        "ConfigMap"
      ],
      "rule_name": "security_namespace_gitops_deployment_enabled"
    },
    {
      "rule_id": "k8s.security.namespace.remediation.automated_remediation_status.automated_compliance_reporting",
      "adapter": "k8s.security.namespace.remediation.automated_remediation_status",
      "assertion_id": "compliance_governance.compliance_automation.automated_compliance_reporting",
      "title": "Automated compliance reporting is enabled",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.compliance_automation",
      "rationale": "Automated compliance reporting reduces manual effort and ensures consistent reporting.",
      "validation_method": "kubectl get pods, kubectl get jobs",
      "not_applicable_when": "no_automated_remediation",
      "k8s_resources": [
        "Pod",
        "Job"
      ],
      "rule_name": "security_namespace_remediation_automated_remediation_status_automated_compliance_reporting"
    },
    {
      "rule_id": "k8s.security.namespace.validation.continuous_validation.automated_compliance_reporting",
      "adapter": "k8s.security.namespace.validation.continuous_validation",
      "assertion_id": "compliance_governance.compliance_automation.automated_compliance_reporting",
      "title": "Automated compliance reporting is enabled",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.compliance_automation",
      "rationale": "Automated compliance reporting reduces manual effort and ensures consistent reporting.",
      "validation_method": "kubectl get pods, kubectl get cronjobs",
      "not_applicable_when": "no_continuous_validation",
      "k8s_resources": [
        "Pod",
        "CronJob"
      ],
      "rule_name": "security_namespace_validation_continuous_automated_compliance_reporting"
    },
    {
      "rule_id": "k8s.security.namespace.vuln.vulnerability_assessment_status.risk_assessment_integrated",
      "adapter": "k8s.security.namespace.vuln.vulnerability_assessment_status",
      "assertion_id": "compliance_governance.risk_management.risk_assessment_integrated",
      "title": "Risk assessment is integrated with compliance monitoring",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.risk_management",
      "rationale": "Risk assessment integration provides context-aware compliance monitoring and prioritization.",
      "validation_method": "kubectl get pods, kubectl get configmaps",
      "not_applicable_when": "no_vulnerability_assessment",
      "k8s_resources": [
        "Pod",
        "ConfigMap"
      ],
      "rule_name": "security_namespace_vuln_vulnerability_assessment_status_risk_assessment_integrated"
    },
    {
      "rule_id": "k8s.security.namespace.threat.threat_modeling_validation.risk_assessment_integrated",
      "adapter": "k8s.security.namespace.threat.threat_modeling_validation",
      "assertion_id": "compliance_governance.risk_management.risk_assessment_integrated",
      "title": "Risk assessment is integrated with compliance monitoring",
      "service": "security.k8s.io",
      "resource_type": "compliance.namespace",
      "scope": "compliance.namespace",
      "severity": "medium",
      "domain_subcategory": "compliance_governance.risk_management",
      "rationale": "Risk assessment integration provides context-aware compliance monitoring and prioritization.",
      "validation_method": "kubectl get configmaps, kubectl get secrets",
      "not_applicable_when": "no_threat_modeling",
      "k8s_resources": [
        "ConfigMap",
        "Secret"
      ],
      "rule_name": "security_namespace_threat_threat_modeling_risk_assessment_integrated"
    }
  ]
}