[
  {
    "rule_id": "gcp.iam.serviceAccount.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.serviceAccount.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.serviceAccount",
    "adapter": "gcp.iam.serviceAccount",
    "adapter_evidence_type": "gcp.iam.serviceAccount[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.serviceAccount",
      "evidence_path": "gcp.iam.serviceAccount[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.workload_identity_pool.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.workload_identity_pool",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.workload_identity_pool",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_constraints.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_constraints",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_constraints",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity strong_authn_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for strong_authn_enabled",
    "remediation": "Configure cloudidentity with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity service_authn_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for service_authn_configured",
    "remediation": "Configure cloudidentity with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity legacy_authn_disabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for legacy_authn_disabled",
    "remediation": "Configure cloudidentity with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_authentication_policy.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_authentication_policy",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_authentication_policy",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_timeout_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_timeout_configured",
    "remediation": "Configure cloudidentity with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity strong_authn_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for strong_authn_enabled",
    "remediation": "Configure cloudidentity with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity service_authn_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for service_authn_configured",
    "remediation": "Configure cloudidentity with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity legacy_authn_disabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for legacy_authn_disabled",
    "remediation": "Configure cloudidentity with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.sso_configuration.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.sso_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.sso_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_timeout_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_timeout_configured",
    "remediation": "Configure cloudidentity with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager strong_authn_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for strong_authn_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager service_authn_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for service_authn_configured",
    "remediation": "Configure accesscontextmanager with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager legacy_authn_disabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for legacy_authn_disabled",
    "remediation": "Configure accesscontextmanager with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.authentication_configuration.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.authentication_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.authentication_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager session_timeout_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for session_timeout_configured",
    "remediation": "Configure accesscontextmanager with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.strong_authn_enabled",
    "assertion_id": "identity_access.authentication.strong_authn_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_authn_factors_required": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for strong_authn_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam strong_authn_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for strong_authn_enabled",
    "remediation": "Configure iam with security best practices for strong_authn_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.service_authn_configured",
    "assertion_id": "identity_access.authentication.service_authn_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for service_authn_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_authn_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_authn_configured",
    "remediation": "Configure iam with security best practices for service_authn_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.legacy_authn_disabled",
    "assertion_id": "identity_access.authentication.legacy_authn_disabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for legacy_authn_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam legacy_authn_disabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for legacy_authn_disabled",
    "remediation": "Configure iam with security best practices for legacy_authn_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.service_account_key_rotation.session_timeout_configured",
    "assertion_id": "identity_access.authentication.session_timeout_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.service_account_key_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "iam must implement security controls for session_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.service_account_key_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_timeout_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_timeout_configured",
    "remediation": "Configure iam with security best practices for session_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_based_access_control.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_based_access_control",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_based_access_control",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.conditional_access_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.conditional_access_policies",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.conditional_access_policies",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam permission_boundaries_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure iam with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam resource_policies_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for resource_policies_configured",
    "remediation": "Configure iam with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.organization_policy_enforcement.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.organization_policy_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.organization_policy_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam conditional_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for conditional_access_enabled",
    "remediation": "Configure iam with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity permission_boundaries_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure cloudidentity with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity resource_policies_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for resource_policies_configured",
    "remediation": "Configure cloudidentity with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group_membership_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_membership_policies",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_membership_policies",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity conditional_access_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for conditional_access_enabled",
    "remediation": "Configure cloudidentity with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity permission_boundaries_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure cloudidentity with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity resource_policies_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for resource_policies_configured",
    "remediation": "Configure cloudidentity with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.access_control_lists.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.access_control_lists",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.access_control_lists",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity conditional_access_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for conditional_access_enabled",
    "remediation": "Configure cloudidentity with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager permission_boundaries_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager resource_policies_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for resource_policies_configured",
    "remediation": "Configure accesscontextmanager with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.access_level_conditions.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.access_level_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.access_level_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager conditional_access_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for conditional_access_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.permission_boundaries_enforced",
    "assertion_id": "identity_access.authorization.permission_boundaries_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for permission_boundaries_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager permission_boundaries_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for permission_boundaries_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for permission_boundaries_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.resource_policies_configured",
    "assertion_id": "identity_access.authorization.resource_policies_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for resource_policies_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager resource_policies_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for resource_policies_configured",
    "remediation": "Configure accesscontextmanager with security best practices for resource_policies_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.service_perimeter_policies.conditional_access_enabled",
    "assertion_id": "identity_access.authorization.conditional_access_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.service_perimeter_policies",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for conditional_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.service_perimeter_policies",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager conditional_access_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for conditional_access_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for conditional_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam external_idp_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for external_idp_configured",
    "remediation": "Configure iam with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam trust_relationships_managed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for trust_relationships_managed",
    "remediation": "Configure iam with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.federation_configuration.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.federation_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.federation_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam cross_account_access_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for cross_account_access_controlled",
    "remediation": "Configure iam with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity external_idp_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for external_idp_configured",
    "remediation": "Configure cloudidentity with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity trust_relationships_managed implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for trust_relationships_managed",
    "remediation": "Configure cloudidentity with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.federation_configuration.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.federation_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.federation_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity cross_account_access_controlled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for cross_account_access_controlled",
    "remediation": "Configure cloudidentity with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.external_idp_configured",
    "assertion_id": "identity_access.federation.external_idp_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for external_idp_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager external_idp_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for external_idp_configured",
    "remediation": "Configure accesscontextmanager with security best practices for external_idp_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.trust_relationships_managed",
    "assertion_id": "identity_access.federation.trust_relationships_managed",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for trust_relationships_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager trust_relationships_managed implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for trust_relationships_managed",
    "remediation": "Configure accesscontextmanager with security best practices for trust_relationships_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.external_identity_conditions.cross_account_access_controlled",
    "assertion_id": "identity_access.federation.cross_account_access_controlled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.external_identity_conditions",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for cross_account_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.external_identity_conditions",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager cross_account_access_controlled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for cross_account_access_controlled",
    "remediation": "Configure accesscontextmanager with security best practices for cross_account_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam enforced_for_privileged_users implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure iam with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam backup_methods_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for backup_methods_configured",
    "remediation": "Configure iam with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.mfa_enforcement.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.mfa_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.mfa_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required_for_privileged implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure iam with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam enforced_for_privileged_users implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure iam with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam backup_methods_configured implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for backup_methods_configured",
    "remediation": "Configure iam with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.security_key_enforcement.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.security_key_enforcement",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.security_key_enforcement",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required_for_privileged implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure iam with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity enforced_for_privileged_users implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure cloudidentity with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity backup_methods_configured implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for backup_methods_configured",
    "remediation": "Configure cloudidentity with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.mfa_configuration.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.mfa_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.mfa_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity hardware_tokens_required_for_privileged implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure cloudidentity with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.enforced_for_privileged_users",
    "assertion_id": "identity_access.mfa.enforced_for_privileged_users",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user,standard]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for enforced_for_privileged_users to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager enforced_for_privileged_users implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for enforced_for_privileged_users",
    "remediation": "Configure accesscontextmanager with security best practices for enforced_for_privileged_users",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.backup_methods_configured",
    "assertion_id": "identity_access.mfa.backup_methods_configured",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for backup_methods_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager backup_methods_configured implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for backup_methods_configured",
    "remediation": "Configure accesscontextmanager with security best practices for backup_methods_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.mfa_configuration.hardware_tokens_required_for_privileged",
    "assertion_id": "identity_access.mfa.hardware_tokens_required_for_privileged",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.mfa_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "privilege_threshold": "enum[admin,power_user]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for hardware_tokens_required_for_privileged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.mfa_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager hardware_tokens_required_for_privileged implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for hardware_tokens_required_for_privileged",
    "remediation": "Configure accesscontextmanager with security best practices for hardware_tokens_required_for_privileged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.session_duration_limits.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.session_duration_limits",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.session_duration_limits",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_duration_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_duration_limited",
    "remediation": "Configure iam with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.session_duration_limits.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.session_duration_limits",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.session_duration_limits",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_credentials_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure iam with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.temporary_credentials_rotation.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.temporary_credentials_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.temporary_credentials_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam session_duration_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for session_duration_limited",
    "remediation": "Configure iam with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.temporary_credentials_rotation.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.temporary_credentials_rotation",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "iam must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.temporary_credentials_rotation",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_credentials_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure iam with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.session_management_configuration.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.session_management_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.session_management_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity session_duration_limited implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for session_duration_limited",
    "remediation": "Configure cloudidentity with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.session_management_configuration.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.session_management_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "cloudidentity must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.session_management_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity temporary_credentials_controlled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure cloudidentity with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.session_management_configuration.session_duration_limited",
    "assertion_id": "identity_access.session_management.session_duration_limited",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.session_management_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_session_duration_minutes": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for session_duration_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.session_management_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager session_duration_limited implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for session_duration_limited",
    "remediation": "Configure accesscontextmanager with security best practices for session_duration_limited",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.session_management_configuration.temporary_credentials_controlled",
    "assertion_id": "identity_access.session_management.temporary_credentials_controlled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.session_management_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for temporary_credentials_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.session_management_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager temporary_credentials_controlled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for temporary_credentials_controlled",
    "remediation": "Configure accesscontextmanager with security best practices for temporary_credentials_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_definition_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_definition_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam least_privilege_roles implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for least_privilege_roles",
    "remediation": "Configure iam with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_definition_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_definition_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam service_linked_roles_used implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for service_linked_roles_used",
    "remediation": "Configure iam with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_definition_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_definition_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager least_privilege_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for least_privilege_roles",
    "remediation": "Configure resourcemanager with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_definition_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_definition_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager service_linked_roles_used implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for service_linked_roles_used",
    "remediation": "Configure resourcemanager with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_definition_configuration.least_privilege_roles",
    "assertion_id": "rbac_entitlements.role_definition.least_privilege_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_definition_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for least_privilege_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_definition_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager least_privilege_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for least_privilege_roles",
    "remediation": "Configure resourcemanager with security best practices for least_privilege_roles",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_definition_configuration.service_linked_roles_used",
    "assertion_id": "rbac_entitlements.role_definition.service_linked_roles_used",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_definition_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for service_linked_roles_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_definition_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager service_linked_roles_used implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for service_linked_roles_used",
    "remediation": "Configure resourcemanager with security best practices for service_linked_roles_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_assignment_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_assignment_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam principals_limited implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for principals_limited",
    "remediation": "Configure iam with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.role_assignment_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.role_assignment_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam just_in_time_access_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure iam with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_assignment_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_assignment_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager principals_limited implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for principals_limited",
    "remediation": "Configure resourcemanager with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.role_assignment_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.role_assignment_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager just_in_time_access_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure resourcemanager with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_assignment_configuration.principals_limited",
    "assertion_id": "rbac_entitlements.role_assignment.principals_limited",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_assignment_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for principals_limited to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_assignment_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager principals_limited implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for principals_limited",
    "remediation": "Configure resourcemanager with security best practices for principals_limited",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.role_assignment_configuration.just_in_time_access_enabled",
    "assertion_id": "rbac_entitlements.role_assignment.just_in_time_access_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.role_assignment_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for just_in_time_access_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.role_assignment_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager just_in_time_access_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for just_in_time_access_enabled",
    "remediation": "Configure resourcemanager with security best practices for just_in_time_access_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.least_privilege_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.least_privilege_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam access_reviews_conducted implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for access_reviews_conducted",
    "remediation": "Configure iam with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.least_privilege_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.least_privilege_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam unused_permissions_removed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for unused_permissions_removed",
    "remediation": "Configure iam with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.least_privilege_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.least_privilege_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager access_reviews_conducted implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for access_reviews_conducted",
    "remediation": "Configure resourcemanager with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.least_privilege_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.least_privilege_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager unused_permissions_removed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for unused_permissions_removed",
    "remediation": "Configure resourcemanager with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.least_privilege_configuration.access_reviews_conducted",
    "assertion_id": "rbac_entitlements.least_privilege.access_reviews_conducted",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.least_privilege_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "review_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for access_reviews_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.least_privilege_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager access_reviews_conducted implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for access_reviews_conducted",
    "remediation": "Configure resourcemanager with security best practices for access_reviews_conducted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.least_privilege_configuration.unused_permissions_removed",
    "assertion_id": "rbac_entitlements.least_privilege.unused_permissions_removed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.least_privilege_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for unused_permissions_removed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.least_privilege_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager unused_permissions_removed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for unused_permissions_removed",
    "remediation": "Configure resourcemanager with security best practices for unused_permissions_removed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.entitlement_management_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam lifecycle_managed implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for lifecycle_managed",
    "remediation": "Configure iam with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.entitlement_management_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam temporary_access_controlled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for temporary_access_controlled",
    "remediation": "Configure iam with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.entitlement_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager lifecycle_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for lifecycle_managed",
    "remediation": "Configure resourcemanager with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.entitlement_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager temporary_access_controlled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for temporary_access_controlled",
    "remediation": "Configure resourcemanager with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.entitlement_management_configuration.lifecycle_managed",
    "assertion_id": "rbac_entitlements.entitlement_management.lifecycle_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for lifecycle_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.entitlement_management_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager lifecycle_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for lifecycle_managed",
    "remediation": "Configure resourcemanager with security best practices for lifecycle_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.entitlement_management_configuration.temporary_access_controlled",
    "assertion_id": "rbac_entitlements.entitlement_management.temporary_access_controlled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.entitlement_management_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "max_temporary_duration_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for temporary_access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.entitlement_management_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager temporary_access_controlled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for temporary_access_controlled",
    "remediation": "Configure resourcemanager with security best practices for temporary_access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_encryption_at_rest.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_encryption_at_rest",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_encryption_at_rest",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_encryption_at_rest.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_encryption_at_rest",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_encryption_at_rest",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_access_control.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_access_control",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_access_control",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_access_control.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_access_control",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_access_control",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_rotation_policy.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_rotation_policy",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "secretmanager must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_rotation_policy",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager encrypted_storage_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure secretmanager with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_rotation_policy.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_rotation_policy",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "secretmanager must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_rotation_policy",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager access_controlled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for access_controlled",
    "remediation": "Configure secretmanager with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_storage_configuration.encrypted_storage_enabled",
    "assertion_id": "secrets_key_mgmt.secret_storage.encrypted_storage_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_storage_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for encrypted_storage_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_storage_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms encrypted_storage_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for encrypted_storage_enabled",
    "remediation": "Configure kms with security best practices for encrypted_storage_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_storage_configuration.access_controlled",
    "assertion_id": "secrets_key_mgmt.secret_storage.access_controlled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_storage_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for access_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_storage_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms access_controlled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for access_controlled",
    "remediation": "Configure kms with security best practices for access_controlled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.automatic_rotation.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.automatic_rotation",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.automatic_rotation",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager automatic_rotation_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure secretmanager with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.automatic_rotation.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.automatic_rotation",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.automatic_rotation",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager manual_rotation_scheduled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure secretmanager with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.rotation_schedule.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.rotation_schedule",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.rotation_schedule",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager automatic_rotation_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure secretmanager with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.rotation_schedule.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.rotation_schedule",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "secretmanager must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.rotation_schedule",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager manual_rotation_scheduled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure secretmanager with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_configuration.automatic_rotation_enabled",
    "assertion_id": "secrets_key_mgmt.key_rotation.automatic_rotation_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for automatic_rotation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms automatic_rotation_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for automatic_rotation_enabled",
    "remediation": "Configure kms with security best practices for automatic_rotation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_configuration.manual_rotation_scheduled",
    "assertion_id": "secrets_key_mgmt.key_rotation.manual_rotation_scheduled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "kms must implement security controls for manual_rotation_scheduled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms manual_rotation_scheduled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for manual_rotation_scheduled",
    "remediation": "Configure kms with security best practices for manual_rotation_scheduled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.key_protection_configuration.hsm_protection_enabled",
    "assertion_id": "secrets_key_mgmt.key_protection.hsm_protection_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.key_protection_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for hsm_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.key_protection_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager hsm_protection_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for hsm_protection_enabled",
    "remediation": "Configure secretmanager with security best practices for hsm_protection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.key_protection_configuration.key_access_logged",
    "assertion_id": "secrets_key_mgmt.key_protection.key_access_logged",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.key_protection_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for key_access_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.key_protection_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager key_access_logged implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for key_access_logged",
    "remediation": "Configure secretmanager with security best practices for key_access_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_configuration.hsm_protection_enabled",
    "assertion_id": "secrets_key_mgmt.key_protection.hsm_protection_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for hsm_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms hsm_protection_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for hsm_protection_enabled",
    "remediation": "Configure kms with security best practices for hsm_protection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_configuration.key_access_logged",
    "assertion_id": "secrets_key_mgmt.key_protection.key_access_logged",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for key_access_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_access_logged implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_access_logged",
    "remediation": "Configure kms with security best practices for key_access_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_retrieval_configuration.secure_injection_enabled",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.secure_injection_enabled",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for secure_injection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_retrieval_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager secure_injection_enabled implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for secure_injection_enabled",
    "remediation": "Configure secretmanager with security best practices for secure_injection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_retrieval_configuration.workload_identity_used",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.workload_identity_used",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for workload_identity_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_retrieval_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager workload_identity_used implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for workload_identity_used",
    "remediation": "Configure secretmanager with security best practices for workload_identity_used",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_retrieval_configuration.secure_injection_enabled",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.secure_injection_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for secure_injection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_retrieval_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms secure_injection_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for secure_injection_enabled",
    "remediation": "Configure kms with security best practices for secure_injection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_retrieval_configuration.workload_identity_used",
    "assertion_id": "secrets_key_mgmt.secret_retrieval.workload_identity_used",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_retrieval_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for workload_identity_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_retrieval_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms workload_identity_used implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for workload_identity_used",
    "remediation": "Configure kms with security best practices for workload_identity_used",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms default_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for default_encryption_enabled",
    "remediation": "Configure kms with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_buckets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_databases implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_disks implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms database_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for database_encryption_enabled",
    "remediation": "Configure kms with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.customer_managed_encryption",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.customer_managed_encryption",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms volume_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for volume_encryption_enabled",
    "remediation": "Configure kms with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms default_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for default_encryption_enabled",
    "remediation": "Configure kms with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_buckets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_databases implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms customer_managed_keys_used_disks implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure kms with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms database_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for database_encryption_enabled",
    "remediation": "Configure kms with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_key_usage.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_key_usage",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_key_usage",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms volume_encryption_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for volume_encryption_enabled",
    "remediation": "Configure kms with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage default_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for default_encryption_enabled",
    "remediation": "Configure storage with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_databases implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_disks implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage database_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for database_encryption_enabled",
    "remediation": "Configure storage with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_encryption_default.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_encryption_default",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_encryption_default",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage volume_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for volume_encryption_enabled",
    "remediation": "Configure storage with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage default_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for default_encryption_enabled",
    "remediation": "Configure storage with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_databases implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage customer_managed_keys_used_disks implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure storage with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage database_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for database_encryption_enabled",
    "remediation": "Configure storage with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_customer_managed_encryption",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_customer_managed_encryption",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage volume_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for volume_encryption_enabled",
    "remediation": "Configure storage with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_encryption_key.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_encryption_key",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption_key",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk_customer_managed_encryption.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disk_customer_managed_encryption",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disk_customer_managed_encryption",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database default_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for default_encryption_enabled",
    "remediation": "Configure database with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_buckets implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_databases implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database customer_managed_keys_used_disks implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure database with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database database_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for database_encryption_enabled",
    "remediation": "Configure database with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_at_rest_configuration.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_at_rest_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database volume_encryption_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for volume_encryption_enabled",
    "remediation": "Configure database with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.default_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.default_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for default_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute default_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for default_encryption_enabled",
    "remediation": "Configure compute with security best practices for default_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_buckets",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_buckets",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_buckets",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_databases",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_databases",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_databases to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_databases implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_databases",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_databases",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.customer_managed_keys_used_disks",
    "assertion_id": "crypto_data_protection.encryption_at_rest.customer_managed_keys_used_disks",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "rotation_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for customer_managed_keys_used_disks to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute customer_managed_keys_used_disks implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for customer_managed_keys_used_disks",
    "remediation": "Configure compute with security best practices for customer_managed_keys_used_disks",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.database_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.database_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for database_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute database_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for database_encryption_enabled",
    "remediation": "Configure compute with security best practices for database_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_at_rest_configuration.volume_encryption_enabled",
    "assertion_id": "crypto_data_protection.encryption_at_rest.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_at_rest_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for volume_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_at_rest_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute volume_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms tls_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for tls_enforced",
    "remediation": "Configure kms with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms mtls_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for mtls_enabled",
    "remediation": "Configure kms with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.encryption_in_transit_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms private_endpoints_used implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for private_endpoints_used",
    "remediation": "Configure kms with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage tls_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for tls_enforced",
    "remediation": "Configure storage with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage mtls_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for mtls_enabled",
    "remediation": "Configure storage with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.encryption_in_transit_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage private_endpoints_used implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for private_endpoints_used",
    "remediation": "Configure storage with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute tls_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for tls_enforced",
    "remediation": "Configure compute with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute mtls_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for mtls_enabled",
    "remediation": "Configure compute with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_endpoints_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_endpoints_used",
    "remediation": "Configure compute with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database tls_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for tls_enforced",
    "remediation": "Configure database with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database mtls_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for mtls_enabled",
    "remediation": "Configure database with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.encryption_in_transit_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database private_endpoints_used implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for private_endpoints_used",
    "remediation": "Configure database with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.tls_enforced",
    "assertion_id": "crypto_data_protection.encryption_in_transit.tls_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "min_tls_version": "enum[tls1.2,tls1.3]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for tls_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute tls_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for tls_enforced",
    "remediation": "Configure compute with security best practices for tls_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.mtls_enabled",
    "assertion_id": "crypto_data_protection.encryption_in_transit.mtls_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for mtls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute mtls_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for mtls_enabled",
    "remediation": "Configure compute with security best practices for mtls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.encryption_in_transit_configuration.private_endpoints_used",
    "assertion_id": "crypto_data_protection.encryption_in_transit.private_endpoints_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.encryption_in_transit_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_endpoints_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.encryption_in_transit_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_endpoints_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_endpoints_used",
    "remediation": "Configure compute with security best practices for private_endpoints_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_policy.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_policy",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_policy",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_rotation_policy.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_rotation_policy",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_rotation_policy",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_level.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_level",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_level",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.key_protection_level.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.key_protection_level",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.key_protection_level",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_key_access_control.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_key_access_control",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_key_access_control",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms kms_configured implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for kms_configured",
    "remediation": "Configure kms with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_key_access_control.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_key_access_control",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_key_access_control",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms key_policies_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for key_policies_enforced",
    "remediation": "Configure kms with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.key_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.key_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage kms_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for kms_configured",
    "remediation": "Configure storage with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.key_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.key_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage key_policies_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for key_policies_enforced",
    "remediation": "Configure storage with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.key_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute kms_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for kms_configured",
    "remediation": "Configure compute with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.key_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute key_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for key_policies_enforced",
    "remediation": "Configure compute with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.key_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.key_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database kms_configured implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for kms_configured",
    "remediation": "Configure database with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.key_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.key_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database key_policies_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for key_policies_enforced",
    "remediation": "Configure database with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.key_management_configuration.kms_configured",
    "assertion_id": "crypto_data_protection.key_management.kms_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for kms_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.key_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute kms_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for kms_configured",
    "remediation": "Configure compute with security best practices for kms_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.key_management_configuration.key_policies_enforced",
    "assertion_id": "crypto_data_protection.key_management.key_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.key_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for key_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.key_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute key_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for key_policies_enforced",
    "remediation": "Configure compute with security best practices for key_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.certificate_management_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.certificate_management_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms auto_renewal_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for auto_renewal_enabled",
    "remediation": "Configure kms with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.certificate_management_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.certificate_management_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms certificate_validation_enabled implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for certificate_validation_enabled",
    "remediation": "Configure kms with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.certificate_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.certificate_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage auto_renewal_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for auto_renewal_enabled",
    "remediation": "Configure storage with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.certificate_management_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.certificate_management_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage certificate_validation_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for certificate_validation_enabled",
    "remediation": "Configure storage with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.certificate_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_renewal_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_renewal_enabled",
    "remediation": "Configure compute with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.certificate_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute certificate_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for certificate_validation_enabled",
    "remediation": "Configure compute with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.certificate_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.certificate_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database auto_renewal_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for auto_renewal_enabled",
    "remediation": "Configure database with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.certificate_management_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.certificate_management_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database certificate_validation_enabled implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for certificate_validation_enabled",
    "remediation": "Configure database with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.certificate_management_configuration.auto_renewal_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.auto_renewal_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for auto_renewal_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.certificate_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_renewal_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_renewal_enabled",
    "remediation": "Configure compute with security best practices for auto_renewal_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.certificate_management_configuration.certificate_validation_enabled",
    "assertion_id": "crypto_data_protection.certificate_management.certificate_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.certificate_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for certificate_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.certificate_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute certificate_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for certificate_validation_enabled",
    "remediation": "Configure compute with security best practices for certificate_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_policies_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms algorithm_standards_enforced implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure kms with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.crypto_policies_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms compliance_standards_met implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for compliance_standards_met",
    "remediation": "Configure kms with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.crypto_policies_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage algorithm_standards_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure storage with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.crypto_policies_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage compliance_standards_met implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for compliance_standards_met",
    "remediation": "Configure storage with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.crypto_policies_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute algorithm_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure compute with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.crypto_policies_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_standards_met implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_standards_met",
    "remediation": "Configure compute with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.crypto_policies_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database algorithm_standards_enforced implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure database with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.crypto_policies_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database compliance_standards_met implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for compliance_standards_met",
    "remediation": "Configure database with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.crypto_policies_configuration.algorithm_standards_enforced",
    "assertion_id": "crypto_data_protection.crypto_policies.algorithm_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_key_size_bits": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for algorithm_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.crypto_policies_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute algorithm_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for algorithm_standards_enforced",
    "remediation": "Configure compute with security best practices for algorithm_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.crypto_policies_configuration.compliance_standards_met",
    "assertion_id": "crypto_data_protection.crypto_policies.compliance_standards_met",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.crypto_policies_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_standards_met to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.crypto_policies_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_standards_met implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_standards_met",
    "remediation": "Configure compute with security best practices for compliance_standards_met",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_classification_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_classification_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage sensitivity_labels_applied implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure storage with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_classification_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_classification_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage automatic_classification_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for automatic_classification_enabled",
    "remediation": "Configure storage with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_classification_configuration.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_classification_configuration.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_classification_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_classification_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.sensitive_data_detection.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.sensitive_data_detection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.sensitive_data_detection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.sensitive_data_detection.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.sensitive_data_detection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.sensitive_data_detection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_classification_labels.sensitivity_labels_applied",
    "assertion_id": "data_protection_storage.data_classification.sensitivity_labels_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_classification_labels",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitivity_labels_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_classification_labels",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitivity_labels_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitivity_labels_applied",
    "remediation": "Configure compute with security best practices for sensitivity_labels_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_classification_labels.automatic_classification_enabled",
    "assertion_id": "data_protection_storage.data_classification.automatic_classification_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_classification_labels",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for automatic_classification_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_classification_labels",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_classification_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_classification_enabled",
    "remediation": "Configure compute with security best practices for automatic_classification_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_retention_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_retention_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage retention_policies_enforced implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for retention_policies_enforced",
    "remediation": "Configure storage with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_retention_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_retention_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage secure_deletion_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for secure_deletion_enabled",
    "remediation": "Configure storage with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_retention_configuration.retention_policies_enforced",
    "assertion_id": "data_protection_storage.data_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_policies_enforced",
    "remediation": "Configure compute with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_retention_configuration.secure_deletion_enabled",
    "assertion_id": "data_protection_storage.data_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_retention_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_retention_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_deletion_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_deletion_enabled",
    "remediation": "Configure compute with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_encryption_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_encryption_enabled",
    "remediation": "Configure storage with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_retention_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_retention_configured",
    "remediation": "Configure storage with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.backup_recovery_configuration.backup_encryption_enabled",
    "assertion_id": "data_protection_storage.backup_recovery.backup_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_encryption_enabled",
    "remediation": "Configure compute with security best practices for backup_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.backup_recovery_configuration.backup_retention_configured",
    "assertion_id": "data_protection_storage.backup_recovery.backup_retention_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.backup_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for backup_retention_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.backup_recovery_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_retention_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_retention_configured",
    "remediation": "Configure compute with security best practices for backup_retention_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.data_masking_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.data_masking_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage sensitive_data_masked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for sensitive_data_masked",
    "remediation": "Configure storage with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.data_masking_configuration.sensitive_data_masked",
    "assertion_id": "data_protection_storage.data_masking.sensitive_data_masked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.data_masking_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for sensitive_data_masked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.data_masking_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sensitive_data_masked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sensitive_data_masked",
    "remediation": "Configure compute with security best practices for sensitive_data_masked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_public_access_prevention.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_public_access_prevention",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_public_access_prevention",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_public_access_prevention.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_public_access_prevention",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_public_access_prevention",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_uniform_bucket_level_access.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_uniform_bucket_level_access",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_uniform_bucket_level_access",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_uniform_bucket_level_access.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_uniform_bucket_level_access",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_uniform_bucket_level_access",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_iam_policy.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_iam_policy",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_iam_policy",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage public_access_blocked implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for public_access_blocked",
    "remediation": "Configure storage with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.bucket_iam_policy.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.bucket_iam_policy",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.bucket_iam_policy",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage access_logging_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for access_logging_enabled",
    "remediation": "Configure storage with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.bigquery.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.bigquery.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dataproc.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dataproc.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.storage_security_configuration.public_access_blocked",
    "assertion_id": "data_protection_storage.storage_security.public_access_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dlp.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for public_access_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute public_access_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for public_access_blocked",
    "remediation": "Configure compute with security best practices for public_access_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.storage_security_configuration.access_logging_enabled",
    "assertion_id": "data_protection_storage.storage_security.access_logging_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.dlp.storage_security_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for access_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.storage_security_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_logging_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_logging_enabled",
    "remediation": "Configure compute with security best practices for access_logging_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.network_segmentation_configuration.vpc_isolation_enforced",
    "assertion_id": "network_perimeter.network_segmentation.vpc_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_isolation_enforced",
    "remediation": "Configure compute with security best practices for vpc_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.network_segmentation_configuration.subnet_segmentation_configured",
    "assertion_id": "network_perimeter.network_segmentation.subnet_segmentation_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.network_segmentation_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for subnet_segmentation_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.network_segmentation_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute subnet_segmentation_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for subnet_segmentation_configured",
    "remediation": "Configure compute with security best practices for subnet_segmentation_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.security_policy_rules.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.security_policy_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.security_policy_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.waf_rules.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.waf_rules",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.waf_rules",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.firewall_rules_configuration.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.firewall_rules_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.firewall_rules_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.deny_all_default",
    "assertion_id": "network_perimeter.firewall_rules.deny_all_default",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for deny_all_default to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deny_all_default implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deny_all_default",
    "remediation": "Configure compute with security best practices for deny_all_default",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.ssh_rdp_restricted",
    "assertion_id": "network_perimeter.firewall_rules.ssh_rdp_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "allowed_cidrs": "array[cidr]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssh_rdp_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssh_rdp_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssh_rdp_restricted",
    "remediation": "Configure compute with security best practices for ssh_rdp_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.waf_enabled",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "waf_mode": "enum[block,detect]"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled",
    "remediation": "Configure compute with security best practices for waf_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.waf_enabled_at_edge",
    "assertion_id": "network_perimeter.firewall_rules.waf_enabled_at_edge",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for waf_enabled_at_edge to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute waf_enabled_at_edge implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for waf_enabled_at_edge",
    "remediation": "Configure compute with security best practices for waf_enabled_at_edge",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.ddos_protection.egress_filtering_enabled",
    "assertion_id": "network_perimeter.firewall_rules.egress_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.ddos_protection",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for egress_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.ddos_protection",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute egress_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for egress_filtering_enabled",
    "remediation": "Configure compute with security best practices for egress_filtering_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.dns_security_configuration.dns_filtering_enabled",
    "assertion_id": "network_perimeter.dns_security.dns_filtering_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for dns_filtering_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dns_filtering_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dns_filtering_enabled",
    "remediation": "Configure compute with security best practices for dns_filtering_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.dns_security_configuration.private_dns_zones_used",
    "assertion_id": "network_perimeter.dns_security.private_dns_zones_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.dns_security_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_zones_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.dns_security_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_zones_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_zones_used",
    "remediation": "Configure compute with security best practices for private_dns_zones_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.load_balancing_configuration.ssl_termination_configured",
    "assertion_id": "network_perimeter.load_balancing.ssl_termination_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ssl_termination_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ssl_termination_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ssl_termination_configured",
    "remediation": "Configure compute with security best practices for ssl_termination_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.load_balancing_configuration.health_checks_configured",
    "assertion_id": "network_perimeter.load_balancing.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.load_balancing_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.load_balancing_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.vpn_connectivity_configuration.vpn_encryption_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_encryption_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_encryption_enabled",
    "remediation": "Configure compute with security best practices for vpn_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.vpn_connectivity_configuration.vpn_monitoring_enabled",
    "assertion_id": "network_perimeter.vpn_connectivity.vpn_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.vpn_connectivity_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpn_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.vpn_connectivity_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpn_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpn_monitoring_enabled",
    "remediation": "Configure compute with security best practices for vpn_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_shielded_vm.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_shielded_vm",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_shielded_vm",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_shielded_vm.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_shielded_vm",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_shielded_vm",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_os_integrity_monitoring.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_os_integrity_monitoring",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_os_integrity_monitoring",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_os_integrity_monitoring.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_os_integrity_monitoring",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_os_integrity_monitoring",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_secure_boot.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_secure_boot",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_secure_boot",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_secure_boot.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_secure_boot",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_secure_boot",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.os_hardening_configuration.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.os_hardening_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.os_hardening_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_configuration_applied implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_configuration_applied",
    "remediation": "Configure compute with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.os_hardening_configuration.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.os_hardening_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.os_hardening_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute unnecessary_services_disabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure compute with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.os_hardening_configuration.baseline_configuration_applied",
    "assertion_id": "compute_host_security.os_hardening.baseline_configuration_applied",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.os_hardening_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for baseline_configuration_applied to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.os_hardening_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter baseline_configuration_applied implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for baseline_configuration_applied",
    "remediation": "Configure securitycenter with security best practices for baseline_configuration_applied",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.os_hardening_configuration.unnecessary_services_disabled",
    "assertion_id": "compute_host_security.os_hardening.unnecessary_services_disabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.os_hardening_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for unnecessary_services_disabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.os_hardening_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter unnecessary_services_disabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for unnecessary_services_disabled",
    "remediation": "Configure securitycenter with security best practices for unnecessary_services_disabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_patch_management.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_patch_management",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_patch_management",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_patch_management.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_patch_management",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_patch_management",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_automatic_updates.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_automatic_updates",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_automatic_updates",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instance_automatic_updates.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.instance_automatic_updates",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.instance_automatic_updates",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.patch_management_configuration.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.patch_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.patch_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_patching_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_patching_enabled",
    "remediation": "Configure compute with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.patch_management_configuration.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.patch_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.patch_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_compliance_monitored",
    "remediation": "Configure compute with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.patch_management_configuration.automatic_patching_enabled",
    "assertion_id": "compute_host_security.patch_management.automatic_patching_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.patch_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for automatic_patching_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.patch_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter automatic_patching_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for automatic_patching_enabled",
    "remediation": "Configure securitycenter with security best practices for automatic_patching_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.patch_management_configuration.patch_compliance_monitored",
    "assertion_id": "compute_host_security.patch_management.patch_compliance_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.patch_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for patch_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.patch_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter patch_compliance_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for patch_compliance_monitored",
    "remediation": "Configure securitycenter with security best practices for patch_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute antimalware_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for antimalware_enabled",
    "remediation": "Configure compute with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute intrusion_detection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure compute with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute antimalware_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for antimalware_enabled",
    "remediation": "Configure compute with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.endpoint_protection_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute intrusion_detection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure compute with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.endpoint_protection_configuration.antimalware_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.antimalware_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for antimalware_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.endpoint_protection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter antimalware_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for antimalware_enabled",
    "remediation": "Configure securitycenter with security best practices for antimalware_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.endpoint_protection_configuration.intrusion_detection_enabled",
    "assertion_id": "compute_host_security.endpoint_protection.intrusion_detection_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.endpoint_protection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for intrusion_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.endpoint_protection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter intrusion_detection_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for intrusion_detection_enabled",
    "remediation": "Configure securitycenter with security best practices for intrusion_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for scanning_enabled",
    "remediation": "Configure compute with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute remediation_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for remediation_tracked",
    "remediation": "Configure compute with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for scanning_enabled",
    "remediation": "Configure compute with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.vulnerability_management_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute remediation_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for remediation_tracked",
    "remediation": "Configure compute with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.vulnerability_management_configuration.scanning_enabled",
    "assertion_id": "compute_host_security.vulnerability_management.scanning_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.vulnerability_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter scanning_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for scanning_enabled",
    "remediation": "Configure securitycenter with security best practices for scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.vulnerability_management_configuration.remediation_tracked",
    "assertion_id": "compute_host_security.vulnerability_management.remediation_tracked",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.vulnerability_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for remediation_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.vulnerability_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter remediation_tracked implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for remediation_tracked",
    "remediation": "Configure securitycenter with security best practices for remediation_tracked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.compliance_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_compliance_checked",
    "remediation": "Configure compute with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.osconfig.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.compliance_monitoring_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute baseline_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for baseline_compliance_checked",
    "remediation": "Configure compute with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_monitoring_configuration.baseline_compliance_checked",
    "assertion_id": "compute_host_security.compliance_monitoring.baseline_compliance_checked",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.compliance_monitoring_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for baseline_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_monitoring_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter baseline_compliance_checked implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for baseline_compliance_checked",
    "remediation": "Configure securitycenter with security best practices for baseline_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_binary_authorization.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_binary_authorization",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_binary_authorization",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_image_vulnerability_scanning.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_image_vulnerability_scanning",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_image_vulnerability_scanning",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container vulnerability_scanning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure container with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container base_images_approved implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for base_images_approved",
    "remediation": "Configure container with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_workload_identity.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_workload_identity",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_workload_identity",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container image_signing_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for image_signing_enabled",
    "remediation": "Configure container with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.image_security_configuration.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.image_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.image_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_policy.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_policy",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_policy",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.vulnerability_scanning_enabled",
    "assertion_id": "containers_kubernetes.image_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.base_images_approved",
    "assertion_id": "containers_kubernetes.image_security.base_images_approved",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for base_images_approved to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute base_images_approved implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for base_images_approved",
    "remediation": "Configure compute with security best practices for base_images_approved",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.image_attestation_verification.image_signing_enabled",
    "assertion_id": "containers_kubernetes.image_security.image_signing_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.image_attestation_verification",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for image_signing_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.image_attestation_verification",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_signing_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for image_signing_enabled",
    "remediation": "Configure compute with security best practices for image_signing_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_pod_security_standards.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_pod_security_standards",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_pod_security_standards",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_network_policy_enforcement.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_network_policy_enforcement",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_network_policy_enforcement",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container runtime_protection_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for runtime_protection_enabled",
    "remediation": "Configure container with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_restricted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_restricted",
    "remediation": "Configure container with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.cluster_authorized_networks.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.cluster_authorized_networks",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.cluster_authorized_networks",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container resource_limits_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for resource_limits_enforced",
    "remediation": "Configure container with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute runtime_protection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for runtime_protection_enabled",
    "remediation": "Configure compute with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_restricted",
    "remediation": "Configure compute with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.runtime_security_configuration.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.artifactregistry.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_limits_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_limits_enforced",
    "remediation": "Configure compute with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.runtime_protection_enabled",
    "assertion_id": "containers_kubernetes.runtime_security.runtime_protection_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for runtime_protection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute runtime_protection_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for runtime_protection_enabled",
    "remediation": "Configure compute with security best practices for runtime_protection_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.privileged_containers_restricted",
    "assertion_id": "containers_kubernetes.runtime_security.privileged_containers_restricted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_restricted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_restricted",
    "remediation": "Configure compute with security best practices for privileged_containers_restricted",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.runtime_security_configuration.resource_limits_enforced",
    "assertion_id": "containers_kubernetes.runtime_security.resource_limits_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.binaryauthorization.runtime_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.runtime_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_limits_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_limits_enforced",
    "remediation": "Configure compute with security best practices for resource_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.network_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.network_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container network_segmentation_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for network_segmentation_enforced",
    "remediation": "Configure container with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.network_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.network_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container ingress_egress_controlled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for ingress_egress_controlled",
    "remediation": "Configure container with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.network_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.network_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_segmentation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_segmentation_enforced",
    "remediation": "Configure compute with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.network_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.network_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ingress_egress_controlled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ingress_egress_controlled",
    "remediation": "Configure compute with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.network_policies_configuration.network_segmentation_enforced",
    "assertion_id": "containers_kubernetes.network_policies.network_segmentation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.network_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_segmentation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.network_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_segmentation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_segmentation_enforced",
    "remediation": "Configure compute with security best practices for network_segmentation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.network_policies_configuration.ingress_egress_controlled",
    "assertion_id": "containers_kubernetes.network_policies.ingress_egress_controlled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.network_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for ingress_egress_controlled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.network_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute ingress_egress_controlled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for ingress_egress_controlled",
    "remediation": "Configure compute with security best practices for ingress_egress_controlled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.rbac_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container least_privilege_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for least_privilege_enforced",
    "remediation": "Configure container with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.rbac_policies_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container service_account_restrictions implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for service_account_restrictions",
    "remediation": "Configure container with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.rbac_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute least_privilege_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for least_privilege_enforced",
    "remediation": "Configure compute with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.rbac_policies_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_account_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_account_restrictions",
    "remediation": "Configure compute with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.rbac_policies_configuration.least_privilege_enforced",
    "assertion_id": "containers_kubernetes.rbac_policies.least_privilege_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for least_privilege_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.rbac_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute least_privilege_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for least_privilege_enforced",
    "remediation": "Configure compute with security best practices for least_privilege_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.rbac_policies_configuration.service_account_restrictions",
    "assertion_id": "containers_kubernetes.rbac_policies.service_account_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.rbac_policies_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for service_account_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.rbac_policies_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_account_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_account_restrictions",
    "remediation": "Configure compute with security best practices for service_account_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.admission_control_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.admission_control_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container policy_validation_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for policy_validation_enabled",
    "remediation": "Configure container with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.admission_control_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.admission_control_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container security_policies_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for security_policies_enforced",
    "remediation": "Configure container with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.admission_control_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.admission_control_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_validation_enabled",
    "remediation": "Configure compute with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.admission_control_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.admission_control_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_enforced",
    "remediation": "Configure compute with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.admission_control_configuration.policy_validation_enabled",
    "assertion_id": "containers_kubernetes.admission_control.policy_validation_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.admission_control_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.admission_control_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_validation_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_validation_enabled",
    "remediation": "Configure compute with security best practices for policy_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.admission_control_configuration.security_policies_enforced",
    "assertion_id": "containers_kubernetes.admission_control.security_policies_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.admission_control_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for security_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.admission_control_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_enforced",
    "remediation": "Configure compute with security best practices for security_policies_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.function_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.function_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.function_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.function_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.runtime_security_enabled",
    "assertion_id": "serverless_paas.function_security.runtime_security_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for runtime_security_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless runtime_security_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for runtime_security_enabled",
    "remediation": "Configure serverless with security best practices for runtime_security_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.execution_timeout_configured",
    "assertion_id": "serverless_paas.function_security.execution_timeout_configured",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_execution_timeout_seconds": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for execution_timeout_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless execution_timeout_configured implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for execution_timeout_configured",
    "remediation": "Configure serverless with security best practices for execution_timeout_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.function_security_configuration.memory_limits_enforced",
    "assertion_id": "serverless_paas.function_security.memory_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.function_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for memory_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.function_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless memory_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for memory_limits_enforced",
    "remediation": "Configure serverless with security best practices for memory_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.api_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.api_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.rate_limiting_enabled",
    "assertion_id": "serverless_paas.api_security.rate_limiting_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for rate_limiting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rate_limiting_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rate_limiting_enabled",
    "remediation": "Configure serverless with security best practices for rate_limiting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.authentication_required",
    "assertion_id": "serverless_paas.api_security.authentication_required",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for authentication_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless authentication_required implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for authentication_required",
    "remediation": "Configure serverless with security best practices for authentication_required",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.api_security_configuration.input_validation_enabled",
    "assertion_id": "serverless_paas.api_security.input_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.api_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for input_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.api_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless input_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for input_validation_enabled",
    "remediation": "Configure serverless with security best practices for input_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.paas_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.paas_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.paas_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.paas_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.paas_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.paas_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.paas_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.paas_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.paas_security_configuration.platform_hardening_enabled",
    "assertion_id": "serverless_paas.paas_security.platform_hardening_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.paas_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for platform_hardening_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.paas_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_hardening_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_hardening_enabled",
    "remediation": "Configure serverless with security best practices for platform_hardening_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.paas_security_configuration.secure_configuration_enforced",
    "assertion_id": "serverless_paas.paas_security.secure_configuration_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.paas_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for secure_configuration_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.paas_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless secure_configuration_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for secure_configuration_enforced",
    "remediation": "Configure serverless with security best practices for secure_configuration_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.event_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.event_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.event_security_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.event_security_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.event_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.event_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.event_security_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.event_security_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.event_security_configuration.event_encryption_enabled",
    "assertion_id": "serverless_paas.event_security.event_encryption_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.event_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for event_encryption_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.event_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_encryption_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_encryption_enabled",
    "remediation": "Configure serverless with security best practices for event_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.event_security_configuration.event_validation_enabled",
    "assertion_id": "serverless_paas.event_security.event_validation_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.event_security_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for event_validation_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.event_security_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless event_validation_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for event_validation_enabled",
    "remediation": "Configure serverless with security best practices for event_validation_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.resource_limits_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.resource_limits_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.resource_limits_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.resource_limits_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.resource_limits_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.resource_limits_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.resource_limits_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.resource_limits_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.resource_limits_configuration.concurrency_limits_enforced",
    "assertion_id": "serverless_paas.resource_limits.concurrency_limits_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.resource_limits_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_concurrent_executions": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for concurrency_limits_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.resource_limits_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless concurrency_limits_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for concurrency_limits_enforced",
    "remediation": "Configure serverless with security best practices for concurrency_limits_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.resource_limits_configuration.cost_controls_enabled",
    "assertion_id": "serverless_paas.resource_limits.cost_controls_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.resource_limits_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for cost_controls_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.resource_limits_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless cost_controls_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for cost_controls_enabled",
    "remediation": "Configure serverless with security best practices for cost_controls_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.access_control_enforced",
    "assertion_id": "supply_chain_registries.registry_security.access_control_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for access_control_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_control_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_control_enforced",
    "remediation": "Configure compute with security best practices for access_control_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "supply_chain_registries.registry_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.registry_security_configuration.immutable_tags_enforced",
    "assertion_id": "supply_chain_registries.registry_security.immutable_tags_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.registry_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for immutable_tags_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.registry_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_tags_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_tags_enforced",
    "remediation": "Configure compute with security best practices for immutable_tags_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.access_control_enforced",
    "assertion_id": "supply_chain_registries.registry_security.access_control_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for access_control_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute access_control_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for access_control_enforced",
    "remediation": "Configure compute with security best practices for access_control_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.vulnerability_scanning_enabled",
    "assertion_id": "supply_chain_registries.registry_security.vulnerability_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vulnerability_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vulnerability_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vulnerability_scanning_enabled",
    "remediation": "Configure compute with security best practices for vulnerability_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.registry_security_configuration.immutable_tags_enforced",
    "assertion_id": "supply_chain_registries.registry_security.immutable_tags_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.registry_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for immutable_tags_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.registry_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_tags_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_tags_enforced",
    "remediation": "Configure compute with security best practices for immutable_tags_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.dependency_scanning_enabled",
    "assertion_id": "supply_chain_registries.dependency_management.dependency_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dependency_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dependency_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dependency_scanning_enabled",
    "remediation": "Configure compute with security best practices for dependency_scanning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.license_compliance_checked",
    "assertion_id": "supply_chain_registries.dependency_management.license_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for license_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute license_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for license_compliance_checked",
    "remediation": "Configure compute with security best practices for license_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.dependency_management_configuration.outdated_dependencies_blocked",
    "assertion_id": "supply_chain_registries.dependency_management.outdated_dependencies_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.dependency_management_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for outdated_dependencies_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.dependency_management_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute outdated_dependencies_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for outdated_dependencies_blocked",
    "remediation": "Configure compute with security best practices for outdated_dependencies_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.dependency_scanning_enabled",
    "assertion_id": "supply_chain_registries.dependency_management.dependency_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for dependency_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dependency_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dependency_scanning_enabled",
    "remediation": "Configure compute with security best practices for dependency_scanning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.license_compliance_checked",
    "assertion_id": "supply_chain_registries.dependency_management.license_compliance_checked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for license_compliance_checked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute license_compliance_checked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for license_compliance_checked",
    "remediation": "Configure compute with security best practices for license_compliance_checked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.dependency_management_configuration.outdated_dependencies_blocked",
    "assertion_id": "supply_chain_registries.dependency_management.outdated_dependencies_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.dependency_management_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for outdated_dependencies_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.dependency_management_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute outdated_dependencies_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for outdated_dependencies_blocked",
    "remediation": "Configure compute with security best practices for outdated_dependencies_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.secure_build_environments",
    "assertion_id": "supply_chain_registries.build_security.secure_build_environments",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for secure_build_environments to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_build_environments implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_build_environments",
    "remediation": "Configure compute with security best practices for secure_build_environments",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.build_artifacts_signed",
    "assertion_id": "supply_chain_registries.build_security.build_artifacts_signed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for build_artifacts_signed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_artifacts_signed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_artifacts_signed",
    "remediation": "Configure compute with security best practices for build_artifacts_signed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.build_security_configuration.build_secrets_protected",
    "assertion_id": "supply_chain_registries.build_security.build_secrets_protected",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.build_security_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for build_secrets_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.build_security_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_secrets_protected implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_secrets_protected",
    "remediation": "Configure compute with security best practices for build_secrets_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.secure_build_environments",
    "assertion_id": "supply_chain_registries.build_security.secure_build_environments",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for secure_build_environments to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute secure_build_environments implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for secure_build_environments",
    "remediation": "Configure compute with security best practices for secure_build_environments",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.build_artifacts_signed",
    "assertion_id": "supply_chain_registries.build_security.build_artifacts_signed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for build_artifacts_signed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_artifacts_signed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_artifacts_signed",
    "remediation": "Configure compute with security best practices for build_artifacts_signed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.build_security_configuration.build_secrets_protected",
    "assertion_id": "supply_chain_registries.build_security.build_secrets_protected",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.build_security_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for build_secrets_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.build_security_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute build_secrets_protected implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for build_secrets_protected",
    "remediation": "Configure compute with security best practices for build_secrets_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.vulnerability_scanning_configuration.continuous_scanning_enabled",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.continuous_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for continuous_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute continuous_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for continuous_scanning_enabled",
    "remediation": "Configure compute with security best practices for continuous_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.vulnerability_scanning_configuration.critical_vulnerabilities_blocked",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.critical_vulnerabilities_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for critical_vulnerabilities_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute critical_vulnerabilities_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for critical_vulnerabilities_blocked",
    "remediation": "Configure compute with security best practices for critical_vulnerabilities_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.vulnerability_scanning_configuration.continuous_scanning_enabled",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.continuous_scanning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high",
      "scan_frequency_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for continuous_scanning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.vulnerability_scanning_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute continuous_scanning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for continuous_scanning_enabled",
    "remediation": "Configure compute with security best practices for continuous_scanning_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.vulnerability_scanning_configuration.critical_vulnerabilities_blocked",
    "assertion_id": "supply_chain_registries.vulnerability_scanning.critical_vulnerabilities_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.vulnerability_scanning_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for critical_vulnerabilities_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.vulnerability_scanning_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute critical_vulnerabilities_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for critical_vulnerabilities_blocked",
    "remediation": "Configure compute with security best practices for critical_vulnerabilities_blocked",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.signing_verification_configuration.digital_signatures_verified",
    "assertion_id": "supply_chain_registries.signing_verification.digital_signatures_verified",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.signing_verification_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for digital_signatures_verified to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.signing_verification_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute digital_signatures_verified implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for digital_signatures_verified",
    "remediation": "Configure compute with security best practices for digital_signatures_verified",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.signing_verification_configuration.chain_of_trust_maintained",
    "assertion_id": "supply_chain_registries.signing_verification.chain_of_trust_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.signing_verification_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for chain_of_trust_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.signing_verification_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute chain_of_trust_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for chain_of_trust_maintained",
    "remediation": "Configure compute with security best practices for chain_of_trust_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.signing_verification_configuration.digital_signatures_verified",
    "assertion_id": "supply_chain_registries.signing_verification.digital_signatures_verified",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.signing_verification_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for digital_signatures_verified to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.signing_verification_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute digital_signatures_verified implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for digital_signatures_verified",
    "remediation": "Configure compute with security best practices for digital_signatures_verified",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.signing_verification_configuration.chain_of_trust_maintained",
    "assertion_id": "supply_chain_registries.signing_verification.chain_of_trust_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.signing_verification_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for chain_of_trust_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.signing_verification_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute chain_of_trust_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for chain_of_trust_maintained",
    "remediation": "Configure compute with security best practices for chain_of_trust_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring centralized_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for centralized_logging_enabled",
    "remediation": "Configure monitoring with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring log_integrity_protected implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for log_integrity_protected",
    "remediation": "Configure monitoring with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_collection_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_collection_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring structured_logging_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for structured_logging_enforced",
    "remediation": "Configure monitoring with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring centralized_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for centralized_logging_enabled",
    "remediation": "Configure monitoring with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring log_integrity_protected implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for log_integrity_protected",
    "remediation": "Configure monitoring with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_collection_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_collection_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring structured_logging_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for structured_logging_enforced",
    "remediation": "Configure monitoring with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.centralized_logging_enabled",
    "assertion_id": "logging_monitoring.log_collection.centralized_logging_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for centralized_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter centralized_logging_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for centralized_logging_enabled",
    "remediation": "Configure securitycenter with security best practices for centralized_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.log_integrity_protected",
    "assertion_id": "logging_monitoring.log_collection.log_integrity_protected",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for log_integrity_protected to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter log_integrity_protected implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for log_integrity_protected",
    "remediation": "Configure securitycenter with security best practices for log_integrity_protected",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_collection_configuration.structured_logging_enforced",
    "assertion_id": "logging_monitoring.log_collection.structured_logging_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_collection_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for structured_logging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_collection_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter structured_logging_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for structured_logging_enforced",
    "remediation": "Configure securitycenter with security best practices for structured_logging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring real_time_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring alerting_rules_configured implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for alerting_rules_configured",
    "remediation": "Configure monitoring with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.monitoring_alerting_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring performance_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring real_time_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring alerting_rules_configured implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for alerting_rules_configured",
    "remediation": "Configure monitoring with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring performance_monitoring_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure monitoring with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.real_time_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.real_time_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for real_time_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter real_time_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for real_time_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for real_time_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.alerting_rules_configured",
    "assertion_id": "logging_monitoring.monitoring_alerting.alerting_rules_configured",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for alerting_rules_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter alerting_rules_configured implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for alerting_rules_configured",
    "remediation": "Configure securitycenter with security best practices for alerting_rules_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.monitoring_alerting_configuration.performance_monitoring_enabled",
    "assertion_id": "logging_monitoring.monitoring_alerting.performance_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.securitycenter.monitoring_alerting_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for performance_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.monitoring_alerting_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter performance_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for performance_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for performance_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring security_events_logged implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for security_events_logged",
    "remediation": "Configure monitoring with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring audit_trail_integrity_maintained implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure monitoring with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring compliance_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for compliance_logging_enabled",
    "remediation": "Configure monitoring with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring security_events_logged implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for security_events_logged",
    "remediation": "Configure monitoring with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring audit_trail_integrity_maintained implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure monitoring with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.monitoring.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring compliance_logging_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for compliance_logging_enabled",
    "remediation": "Configure monitoring with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.security_events_logged",
    "assertion_id": "logging_monitoring.audit_logging.security_events_logged",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for security_events_logged to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter security_events_logged implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for security_events_logged",
    "remediation": "Configure securitycenter with security best practices for security_events_logged",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.audit_trail_integrity_maintained",
    "assertion_id": "logging_monitoring.audit_logging.audit_trail_integrity_maintained",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for audit_trail_integrity_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter audit_trail_integrity_maintained implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for audit_trail_integrity_maintained",
    "remediation": "Configure securitycenter with security best practices for audit_trail_integrity_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.audit_logging_configuration.compliance_logging_enabled",
    "assertion_id": "logging_monitoring.audit_logging.compliance_logging_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.securitycenter.audit_logging_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for compliance_logging_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.audit_logging_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter compliance_logging_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for compliance_logging_enabled",
    "remediation": "Configure securitycenter with security best practices for compliance_logging_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_retention_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_retention_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_policies_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_policies_enforced",
    "remediation": "Configure monitoring with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_retention_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_retention_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring secure_deletion_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for secure_deletion_enabled",
    "remediation": "Configure monitoring with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_retention_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_retention_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_policies_enforced implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_policies_enforced",
    "remediation": "Configure monitoring with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_retention_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_retention_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring secure_deletion_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for secure_deletion_enabled",
    "remediation": "Configure monitoring with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_retention_configuration.retention_policies_enforced",
    "assertion_id": "logging_monitoring.log_retention.retention_policies_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_retention_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for retention_policies_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_retention_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter retention_policies_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for retention_policies_enforced",
    "remediation": "Configure securitycenter with security best practices for retention_policies_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_retention_configuration.secure_deletion_enabled",
    "assertion_id": "logging_monitoring.log_retention.secure_deletion_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_retention_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for secure_deletion_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_retention_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter secure_deletion_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for secure_deletion_enabled",
    "remediation": "Configure securitycenter with security best practices for secure_deletion_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_analysis_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_analysis_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring anomaly_detection_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure monitoring with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_analysis_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_analysis_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring correlation_analysis_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure monitoring with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_analysis_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_analysis_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring anomaly_detection_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure monitoring with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_analysis_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_analysis_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring correlation_analysis_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure monitoring with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_analysis_configuration.anomaly_detection_enabled",
    "assertion_id": "logging_monitoring.log_analysis.anomaly_detection_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_analysis_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for anomaly_detection_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_analysis_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter anomaly_detection_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for anomaly_detection_enabled",
    "remediation": "Configure securitycenter with security best practices for anomaly_detection_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_analysis_configuration.correlation_analysis_enabled",
    "assertion_id": "logging_monitoring.log_analysis.correlation_analysis_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_analysis_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for correlation_analysis_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_analysis_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter correlation_analysis_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for correlation_analysis_enabled",
    "remediation": "Configure securitycenter with security best practices for correlation_analysis_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.automated_backups_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.automated_backups_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automated_backups_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automated_backups_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automated_backups_enabled",
    "remediation": "Configure compute with security best practices for automated_backups_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.backup_testing_conducted",
    "assertion_id": "resilience_recovery.backup_strategy.backup_testing_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "test_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for backup_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_testing_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_testing_conducted",
    "remediation": "Configure compute with security best practices for backup_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.backup_strategy_configuration.geographic_redundancy_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.geographic_redundancy_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for geographic_redundancy_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.backup_strategy_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute geographic_redundancy_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for geographic_redundancy_enabled",
    "remediation": "Configure compute with security best practices for geographic_redundancy_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.automated_backups_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.automated_backups_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for automated_backups_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage automated_backups_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for automated_backups_enabled",
    "remediation": "Configure storage with security best practices for automated_backups_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.backup_testing_conducted",
    "assertion_id": "resilience_recovery.backup_strategy.backup_testing_conducted",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "test_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for backup_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_testing_conducted implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_testing_conducted",
    "remediation": "Configure storage with security best practices for backup_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.backup_strategy_configuration.geographic_redundancy_enabled",
    "assertion_id": "resilience_recovery.backup_strategy.geographic_redundancy_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.backup_strategy_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for geographic_redundancy_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.backup_strategy_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage geographic_redundancy_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for geographic_redundancy_enabled",
    "remediation": "Configure storage with security best practices for geographic_redundancy_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.dr_plan_documented",
    "assertion_id": "resilience_recovery.disaster_recovery.dr_plan_documented",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dr_plan_documented to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dr_plan_documented implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dr_plan_documented",
    "remediation": "Configure compute with security best practices for dr_plan_documented",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.rto_rpo_defined",
    "assertion_id": "resilience_recovery.disaster_recovery.rto_rpo_defined",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_rto_hours": "integer",
      "max_rpo_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for rto_rpo_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute rto_rpo_defined implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for rto_rpo_defined",
    "remediation": "Configure compute with security best practices for rto_rpo_defined",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disaster_recovery_configuration.cross_region_replication_enabled",
    "assertion_id": "resilience_recovery.disaster_recovery.cross_region_replication_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for cross_region_replication_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.disaster_recovery_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute cross_region_replication_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for cross_region_replication_enabled",
    "remediation": "Configure compute with security best practices for cross_region_replication_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.dr_plan_documented",
    "assertion_id": "resilience_recovery.disaster_recovery.dr_plan_documented",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for dr_plan_documented to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage dr_plan_documented implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for dr_plan_documented",
    "remediation": "Configure storage with security best practices for dr_plan_documented",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.rto_rpo_defined",
    "assertion_id": "resilience_recovery.disaster_recovery.rto_rpo_defined",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_rto_hours": "integer",
      "max_rpo_hours": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for rto_rpo_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage rto_rpo_defined implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for rto_rpo_defined",
    "remediation": "Configure storage with security best practices for rto_rpo_defined",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.disaster_recovery_configuration.cross_region_replication_enabled",
    "assertion_id": "resilience_recovery.disaster_recovery.cross_region_replication_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.disaster_recovery_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for cross_region_replication_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.disaster_recovery_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage cross_region_replication_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for cross_region_replication_enabled",
    "remediation": "Configure storage with security best practices for cross_region_replication_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.load_balancing_configured",
    "assertion_id": "resilience_recovery.high_availability.load_balancing_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for load_balancing_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute load_balancing_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for load_balancing_configured",
    "remediation": "Configure compute with security best practices for load_balancing_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.auto_scaling_enabled",
    "assertion_id": "resilience_recovery.high_availability.auto_scaling_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for auto_scaling_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute auto_scaling_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for auto_scaling_enabled",
    "remediation": "Configure compute with security best practices for auto_scaling_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.high_availability_configuration.health_checks_configured",
    "assertion_id": "resilience_recovery.high_availability.health_checks_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.high_availability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.high_availability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute health_checks_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for health_checks_configured",
    "remediation": "Configure compute with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.load_balancing_configured",
    "assertion_id": "resilience_recovery.high_availability.load_balancing_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for load_balancing_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage load_balancing_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for load_balancing_configured",
    "remediation": "Configure storage with security best practices for load_balancing_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.auto_scaling_enabled",
    "assertion_id": "resilience_recovery.high_availability.auto_scaling_enabled",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for auto_scaling_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage auto_scaling_enabled implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for auto_scaling_enabled",
    "remediation": "Configure storage with security best practices for auto_scaling_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.high_availability_configuration.health_checks_configured",
    "assertion_id": "resilience_recovery.high_availability.health_checks_configured",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.high_availability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for health_checks_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.high_availability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage health_checks_configured implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for health_checks_configured",
    "remediation": "Configure storage with security best practices for health_checks_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.recovery_testing_configuration.dr_drills_conducted",
    "assertion_id": "resilience_recovery.recovery_testing.dr_drills_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "drill_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for dr_drills_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.recovery_testing_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute dr_drills_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for dr_drills_conducted",
    "remediation": "Configure compute with security best practices for dr_drills_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.recovery_testing_configuration.backup_restoration_tested",
    "assertion_id": "resilience_recovery.recovery_testing.backup_restoration_tested",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for backup_restoration_tested to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.recovery_testing_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute backup_restoration_tested implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for backup_restoration_tested",
    "remediation": "Configure compute with security best practices for backup_restoration_tested",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.recovery_testing_configuration.dr_drills_conducted",
    "assertion_id": "resilience_recovery.recovery_testing.dr_drills_conducted",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "drill_frequency_days": "integer"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for dr_drills_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.recovery_testing_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage dr_drills_conducted implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for dr_drills_conducted",
    "remediation": "Configure storage with security best practices for dr_drills_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.recovery_testing_configuration.backup_restoration_tested",
    "assertion_id": "resilience_recovery.recovery_testing.backup_restoration_tested",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.recovery_testing_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for backup_restoration_tested to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.recovery_testing_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage backup_restoration_tested implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for backup_restoration_tested",
    "remediation": "Configure storage with security best practices for backup_restoration_tested",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager security_policies_defined implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for security_policies_defined",
    "remediation": "Configure resourcemanager with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager policy_compliance_monitored implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for policy_compliance_monitored",
    "remediation": "Configure resourcemanager with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.policy_management_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.policy_management_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager policy_exceptions_managed implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for policy_exceptions_managed",
    "remediation": "Configure resourcemanager with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter security_policies_defined implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for security_policies_defined",
    "remediation": "Configure securitycenter with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter policy_compliance_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for policy_compliance_monitored",
    "remediation": "Configure securitycenter with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.policy_management_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.policy_management_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter policy_exceptions_managed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for policy_exceptions_managed",
    "remediation": "Configure securitycenter with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.security_policies_defined",
    "assertion_id": "governance_compliance.policy_management.security_policies_defined",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for security_policies_defined to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute security_policies_defined implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for security_policies_defined",
    "remediation": "Configure compute with security best practices for security_policies_defined",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.policy_compliance_monitored",
    "assertion_id": "governance_compliance.policy_management.policy_compliance_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_compliance_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_compliance_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_compliance_monitored",
    "remediation": "Configure compute with security best practices for policy_compliance_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.policy_management_configuration.policy_exceptions_managed",
    "assertion_id": "governance_compliance.policy_management.policy_exceptions_managed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.policy_management_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for policy_exceptions_managed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.policy_management_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute policy_exceptions_managed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for policy_exceptions_managed",
    "remediation": "Configure compute with security best practices for policy_exceptions_managed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager regulatory_requirements_mapped implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure resourcemanager with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager compliance_reporting_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure resourcemanager with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.compliance_framework_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager audit_trail_maintained implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for audit_trail_maintained",
    "remediation": "Configure resourcemanager with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter regulatory_requirements_mapped implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure securitycenter with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter compliance_reporting_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure securitycenter with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.compliance_framework_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter audit_trail_maintained implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for audit_trail_maintained",
    "remediation": "Configure securitycenter with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.regulatory_requirements_mapped",
    "assertion_id": "governance_compliance.compliance_framework.regulatory_requirements_mapped",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for regulatory_requirements_mapped to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute regulatory_requirements_mapped implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for regulatory_requirements_mapped",
    "remediation": "Configure compute with security best practices for regulatory_requirements_mapped",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.compliance_reporting_enabled",
    "assertion_id": "governance_compliance.compliance_framework.compliance_reporting_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_reporting_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_reporting_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_reporting_enabled",
    "remediation": "Configure compute with security best practices for compliance_reporting_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.compliance_framework_configuration.audit_trail_maintained",
    "assertion_id": "governance_compliance.compliance_framework.audit_trail_maintained",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.compliance_framework_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_trail_maintained to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.compliance_framework_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_trail_maintained implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_trail_maintained",
    "remediation": "Configure compute with security best practices for audit_trail_maintained",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.resource_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.resource_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager resource_tagging_enforced implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for resource_tagging_enforced",
    "remediation": "Configure resourcemanager with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.resource_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.resource_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager resource_approval_required implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for resource_approval_required",
    "remediation": "Configure resourcemanager with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.resource_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.resource_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter resource_tagging_enforced implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for resource_tagging_enforced",
    "remediation": "Configure securitycenter with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.resource_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.resource_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter resource_approval_required implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for resource_approval_required",
    "remediation": "Configure securitycenter with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.resource_governance_configuration.resource_tagging_enforced",
    "assertion_id": "governance_compliance.resource_governance.resource_tagging_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.resource_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_tagging_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.resource_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_tagging_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_tagging_enforced",
    "remediation": "Configure compute with security best practices for resource_tagging_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.resource_governance_configuration.resource_approval_required",
    "assertion_id": "governance_compliance.resource_governance.resource_approval_required",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.resource_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for resource_approval_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.resource_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute resource_approval_required implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for resource_approval_required",
    "remediation": "Configure compute with security best practices for resource_approval_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.cost_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.cost_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager cost_monitoring_enabled implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure resourcemanager with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.cost_governance_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.cost_governance_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager budget_alerts_configured implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for budget_alerts_configured",
    "remediation": "Configure resourcemanager with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.cost_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.cost_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter cost_monitoring_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure securitycenter with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.cost_governance_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.cost_governance_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter budget_alerts_configured implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for budget_alerts_configured",
    "remediation": "Configure securitycenter with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.cost_governance_configuration.cost_monitoring_enabled",
    "assertion_id": "governance_compliance.cost_governance.cost_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.cost_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for cost_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.cost_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute cost_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for cost_monitoring_enabled",
    "remediation": "Configure compute with security best practices for cost_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.cost_governance_configuration.budget_alerts_configured",
    "assertion_id": "governance_compliance.cost_governance.budget_alerts_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.cost_governance_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for budget_alerts_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.cost_governance_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute budget_alerts_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for budget_alerts_configured",
    "remediation": "Configure compute with security best practices for budget_alerts_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.version_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.version_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute supported_versions_used implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for supported_versions_used",
    "remediation": "Configure compute with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.version_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.version_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute version_monitoring_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for version_monitoring_enabled",
    "remediation": "Configure compute with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.version_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.version_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container supported_versions_used implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for supported_versions_used",
    "remediation": "Configure container with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.version_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.version_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container version_monitoring_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for version_monitoring_enabled",
    "remediation": "Configure container with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.version_management_configuration.supported_versions_used",
    "assertion_id": "platform_surfaces_versions.version_management.supported_versions_used",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.version_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for supported_versions_used to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.version_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless supported_versions_used implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for supported_versions_used",
    "remediation": "Configure serverless with security best practices for supported_versions_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.version_management_configuration.version_monitoring_enabled",
    "assertion_id": "platform_surfaces_versions.version_management.version_monitoring_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.version_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for version_monitoring_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.version_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless version_monitoring_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for version_monitoring_enabled",
    "remediation": "Configure serverless with security best practices for version_monitoring_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_mgmt_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deprecation_notices_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure compute with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_mgmt_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute migration_planning_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for migration_planning_enabled",
    "remediation": "Configure compute with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_mgmt_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container deprecation_notices_monitored implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure container with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_mgmt_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container migration_planning_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for migration_planning_enabled",
    "remediation": "Configure container with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_mgmt_configuration.deprecation_notices_monitored",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.deprecation_notices_monitored",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for deprecation_notices_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_mgmt_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless deprecation_notices_monitored implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for deprecation_notices_monitored",
    "remediation": "Configure serverless with security best practices for deprecation_notices_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_mgmt_configuration.migration_planning_enabled",
    "assertion_id": "platform_surfaces_versions.deprecation_mgmt.migration_planning_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_mgmt_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for migration_planning_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_mgmt_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless migration_planning_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for migration_planning_enabled",
    "remediation": "Configure serverless with security best practices for migration_planning_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.api_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.api_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute api_versioning_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for api_versioning_enforced",
    "remediation": "Configure compute with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.api_management_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.api_management_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute api_security_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for api_security_enforced",
    "remediation": "Configure compute with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.api_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.api_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container api_versioning_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for api_versioning_enforced",
    "remediation": "Configure container with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.api_management_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.api_management_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container api_security_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for api_security_enforced",
    "remediation": "Configure container with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_management_configuration.api_versioning_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_versioning_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for api_versioning_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless api_versioning_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for api_versioning_enforced",
    "remediation": "Configure serverless with security best practices for api_versioning_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.api_management_configuration.api_security_enforced",
    "assertion_id": "platform_surfaces_versions.api_management.api_security_enforced",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.api_management_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for api_security_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.api_management_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless api_security_enforced implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for api_security_enforced",
    "remediation": "Configure serverless with security best practices for api_security_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.platform_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute platform_health_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for platform_health_monitored",
    "remediation": "Configure compute with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.platform_monitoring_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute service_availability_tracked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for service_availability_tracked",
    "remediation": "Configure compute with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.platform_monitoring_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container platform_health_monitored implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for platform_health_monitored",
    "remediation": "Configure container with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.platform_monitoring_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container service_availability_tracked implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for service_availability_tracked",
    "remediation": "Configure container with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.platform_monitoring_configuration.platform_health_monitored",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.platform_health_monitored",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for platform_health_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.platform_monitoring_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless platform_health_monitored implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for platform_health_monitored",
    "remediation": "Configure serverless with security best practices for platform_health_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.platform_monitoring_configuration.service_availability_tracked",
    "assertion_id": "platform_surfaces_versions.platform_monitoring.service_availability_tracked",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.platform_monitoring_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for service_availability_tracked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.platform_monitoring_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless service_availability_tracked implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for service_availability_tracked",
    "remediation": "Configure serverless with security best practices for service_availability_tracked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.security_updates_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.security_updates_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute automatic_updates_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for automatic_updates_enabled",
    "remediation": "Configure compute with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.security_updates_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.security_updates_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute update_testing_conducted implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for update_testing_conducted",
    "remediation": "Configure compute with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.security_updates_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.security_updates_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container automatic_updates_enabled implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for automatic_updates_enabled",
    "remediation": "Configure container with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.security_updates_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.security_updates_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container update_testing_conducted implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for update_testing_conducted",
    "remediation": "Configure container with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.security_updates_configuration.automatic_updates_enabled",
    "assertion_id": "platform_surfaces_versions.security_updates.automatic_updates_enabled",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.security_updates_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for automatic_updates_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.security_updates_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless automatic_updates_enabled implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for automatic_updates_enabled",
    "remediation": "Configure serverless with security best practices for automatic_updates_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.security_updates_configuration.update_testing_conducted",
    "assertion_id": "platform_surfaces_versions.security_updates.update_testing_conducted",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.security_updates_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "low",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for update_testing_conducted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.security_updates_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless update_testing_conducted implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for update_testing_conducted",
    "remediation": "Configure serverless with security best practices for update_testing_conducted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam fido2_required_for_admins implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for fido2_required_for_admins",
    "remediation": "Configure iam with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam workload_identity_enabled implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for workload_identity_enabled",
    "remediation": "Configure iam with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam cae_enforced implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for cae_enforced",
    "remediation": "Configure iam with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam hardware_tokens_required implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for hardware_tokens_required",
    "remediation": "Configure iam with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam biometric_verification implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for biometric_verification",
    "remediation": "Configure iam with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.passwordless_authn_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam zero_trust_verification implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for zero_trust_verification",
    "remediation": "Configure iam with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity fido2_required_for_admins implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for fido2_required_for_admins",
    "remediation": "Configure cloudidentity with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity workload_identity_enabled implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for workload_identity_enabled",
    "remediation": "Configure cloudidentity with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity cae_enforced implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for cae_enforced",
    "remediation": "Configure cloudidentity with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity hardware_tokens_required implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for hardware_tokens_required",
    "remediation": "Configure cloudidentity with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity biometric_verification implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for biometric_verification",
    "remediation": "Configure cloudidentity with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.passwordless_authn_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity zero_trust_verification implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for zero_trust_verification",
    "remediation": "Configure cloudidentity with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.fido2_required_for_admins",
    "assertion_id": "identity_access.passwordless_authn.fido2_required_for_admins",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for fido2_required_for_admins to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager fido2_required_for_admins implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for fido2_required_for_admins",
    "remediation": "Configure accesscontextmanager with security best practices for fido2_required_for_admins",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.workload_identity_enabled",
    "assertion_id": "identity_access.passwordless_authn.workload_identity_enabled",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for workload_identity_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager workload_identity_enabled implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for workload_identity_enabled",
    "remediation": "Configure accesscontextmanager with security best practices for workload_identity_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.cae_enforced",
    "assertion_id": "identity_access.passwordless_authn.cae_enforced",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "evaluation_interval_minutes": 5
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for cae_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager cae_enforced implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for cae_enforced",
    "remediation": "Configure accesscontextmanager with security best practices for cae_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.hardware_tokens_required",
    "assertion_id": "identity_access.passwordless_authn.hardware_tokens_required",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "min_hardware_factors": 1
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for hardware_tokens_required to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager hardware_tokens_required implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for hardware_tokens_required",
    "remediation": "Configure accesscontextmanager with security best practices for hardware_tokens_required",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.biometric_verification",
    "assertion_id": "identity_access.passwordless_authn.biometric_verification",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for biometric_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager biometric_verification implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for biometric_verification",
    "remediation": "Configure accesscontextmanager with security best practices for biometric_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.passwordless_authn_configuration.zero_trust_verification",
    "assertion_id": "identity_access.passwordless_authn.zero_trust_verification",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.passwordless_authn_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for zero_trust_verification to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.passwordless_authn_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager zero_trust_verification implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for zero_trust_verification",
    "remediation": "Configure accesscontextmanager with security best practices for zero_trust_verification",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam emergency_accounts_restricted implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure iam with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam paw_workstations_isolated implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for paw_workstations_isolated",
    "remediation": "Configure iam with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam break_glass_monitoring implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for break_glass_monitoring",
    "remediation": "Configure iam with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam emergency_access_review implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for emergency_access_review",
    "remediation": "Configure iam with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.break_glass_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.break_glass_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam just_in_time_access implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for just_in_time_access",
    "remediation": "Configure iam with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity emergency_accounts_restricted implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure cloudidentity with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity paw_workstations_isolated implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for paw_workstations_isolated",
    "remediation": "Configure cloudidentity with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity break_glass_monitoring implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for break_glass_monitoring",
    "remediation": "Configure cloudidentity with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity emergency_access_review implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for emergency_access_review",
    "remediation": "Configure cloudidentity with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.break_glass_configuration",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "cloudidentity must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.break_glass_configuration",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity just_in_time_access implementation",
    "title": "Cloudidentity Security Check",
    "description": "Ensure cloudidentity implements security best practices for just_in_time_access",
    "remediation": "Configure cloudidentity with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.emergency_accounts_restricted",
    "assertion_id": "identity_access.break_glass.emergency_accounts_restricted",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_emergency_accounts": 3
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for emergency_accounts_restricted to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager emergency_accounts_restricted implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for emergency_accounts_restricted",
    "remediation": "Configure accesscontextmanager with security best practices for emergency_accounts_restricted",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.paw_workstations_isolated",
    "assertion_id": "identity_access.break_glass.paw_workstations_isolated",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for paw_workstations_isolated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager paw_workstations_isolated implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for paw_workstations_isolated",
    "remediation": "Configure accesscontextmanager with security best practices for paw_workstations_isolated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.break_glass_monitoring",
    "assertion_id": "identity_access.break_glass.break_glass_monitoring",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for break_glass_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager break_glass_monitoring implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for break_glass_monitoring",
    "remediation": "Configure accesscontextmanager with security best practices for break_glass_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.emergency_access_review",
    "assertion_id": "identity_access.break_glass.emergency_access_review",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_hours": 24
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for emergency_access_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager emergency_access_review implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for emergency_access_review",
    "remediation": "Configure accesscontextmanager with security best practices for emergency_access_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.accesscontextmanager.break_glass_configuration.just_in_time_access",
    "assertion_id": "identity_access.break_glass.just_in_time_access",
    "provider": "gcp",
    "service": "accesscontextmanager",
    "resource_type": "gcp.accesscontextmanager.accessPolicy",
    "adapter": "gcp.accesscontextmanager.break_glass_configuration",
    "adapter_evidence_type": "gcp.accesscontextmanager.accessPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_hours": 4
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "accesscontextmanager must implement security controls for just_in_time_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.accesscontextmanager.break_glass_configuration",
      "evidence_path": "gcp.accesscontextmanager.accessPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate accesscontextmanager just_in_time_access implementation",
    "title": "Accesscontextmanager Security Check",
    "description": "Ensure accesscontextmanager implements security best practices for just_in_time_access",
    "remediation": "Configure accesscontextmanager with security best practices for just_in_time_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam detect_conflicting_roles implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for detect_conflicting_roles",
    "remediation": "Configure iam with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam segregate_approval_execution implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for segregate_approval_execution",
    "remediation": "Configure iam with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam financial_controls_segregated implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for financial_controls_segregated",
    "remediation": "Configure iam with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam admin_audit_separation implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for admin_audit_separation",
    "remediation": "Configure iam with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.iam.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "iam",
    "resource_type": "gcp.iam.resource",
    "adapter": "gcp.iam.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.iam.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "iam must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.iam.sod_toxic_configuration",
      "evidence_path": "gcp.iam.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate iam periodic_sod_review implementation",
    "title": "Iam Security Check",
    "description": "Ensure iam implements security best practices for periodic_sod_review",
    "remediation": "Configure iam with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager detect_conflicting_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for detect_conflicting_roles",
    "remediation": "Configure resourcemanager with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager segregate_approval_execution implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for segregate_approval_execution",
    "remediation": "Configure resourcemanager with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager financial_controls_segregated implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for financial_controls_segregated",
    "remediation": "Configure resourcemanager with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager admin_audit_separation implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for admin_audit_separation",
    "remediation": "Configure resourcemanager with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "resourcemanager must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.sod_toxic_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager periodic_sod_review implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for periodic_sod_review",
    "remediation": "Configure resourcemanager with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.detect_conflicting_roles",
    "assertion_id": "rbac_entitlements.sod_toxic.detect_conflicting_roles",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for detect_conflicting_roles to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager detect_conflicting_roles implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for detect_conflicting_roles",
    "remediation": "Configure resourcemanager with security best practices for detect_conflicting_roles",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.segregate_approval_execution",
    "assertion_id": "rbac_entitlements.sod_toxic.segregate_approval_execution",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for segregate_approval_execution to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager segregate_approval_execution implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for segregate_approval_execution",
    "remediation": "Configure resourcemanager with security best practices for segregate_approval_execution",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.financial_controls_segregated",
    "assertion_id": "rbac_entitlements.sod_toxic.financial_controls_segregated",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for financial_controls_segregated to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager financial_controls_segregated implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for financial_controls_segregated",
    "remediation": "Configure resourcemanager with security best practices for financial_controls_segregated",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.admin_audit_separation",
    "assertion_id": "rbac_entitlements.sod_toxic.admin_audit_separation",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for admin_audit_separation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager admin_audit_separation implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for admin_audit_separation",
    "remediation": "Configure resourcemanager with security best practices for admin_audit_separation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.organizationpolicy.sod_toxic_configuration.periodic_sod_review",
    "assertion_id": "rbac_entitlements.sod_toxic.periodic_sod_review",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.organizationpolicy.constraint",
    "adapter": "gcp.organizationpolicy.sod_toxic_configuration",
    "adapter_evidence_type": "gcp.organizationpolicy.constraint[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "review_frequency_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "resourcemanager must implement security controls for periodic_sod_review to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.organizationpolicy.sod_toxic_configuration",
      "evidence_path": "gcp.organizationpolicy.constraint[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager periodic_sod_review implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for periodic_sod_review",
    "remediation": "Configure resourcemanager with security best practices for periodic_sod_review",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.detect_unused_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.detect_unused_secrets",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "stale_threshold_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for detect_unused_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager detect_unused_secrets implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for detect_unused_secrets",
    "remediation": "Configure secretmanager with security best practices for detect_unused_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.rotate_stale_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.rotate_stale_secrets",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for rotate_stale_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager rotate_stale_secrets implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for rotate_stale_secrets",
    "remediation": "Configure secretmanager with security best practices for rotate_stale_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.audit_secret_permissions",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.audit_secret_permissions",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for audit_secret_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager audit_secret_permissions implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for audit_secret_permissions",
    "remediation": "Configure secretmanager with security best practices for audit_secret_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.centralize_secret_management",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.centralize_secret_management",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for centralize_secret_management to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager centralize_secret_management implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for centralize_secret_management",
    "remediation": "Configure secretmanager with security best practices for centralize_secret_management",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.secretmanager.secret_sprawl_configuration.monitor_secret_usage",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.monitor_secret_usage",
    "provider": "gcp",
    "service": "secretmanager",
    "resource_type": "gcp.secretmanager.secret",
    "adapter": "gcp.secretmanager.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.secretmanager.secret[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "secretmanager must implement security controls for monitor_secret_usage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.secretmanager.secret_sprawl_configuration",
      "evidence_path": "gcp.secretmanager.secret[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate secretmanager monitor_secret_usage implementation",
    "title": "Secretmanager Security Check",
    "description": "Ensure secretmanager implements security best practices for monitor_secret_usage",
    "remediation": "Configure secretmanager with security best practices for monitor_secret_usage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.detect_unused_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.detect_unused_secrets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "stale_threshold_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for detect_unused_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms detect_unused_secrets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for detect_unused_secrets",
    "remediation": "Configure kms with security best practices for detect_unused_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.rotate_stale_secrets",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.rotate_stale_secrets",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for rotate_stale_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms rotate_stale_secrets implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for rotate_stale_secrets",
    "remediation": "Configure kms with security best practices for rotate_stale_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.audit_secret_permissions",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.audit_secret_permissions",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for audit_secret_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms audit_secret_permissions implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for audit_secret_permissions",
    "remediation": "Configure kms with security best practices for audit_secret_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.centralize_secret_management",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.centralize_secret_management",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for centralize_secret_management to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms centralize_secret_management implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for centralize_secret_management",
    "remediation": "Configure kms with security best practices for centralize_secret_management",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.secret_sprawl_configuration.monitor_secret_usage",
    "assertion_id": "secrets_key_mgmt.secret_sprawl.monitor_secret_usage",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.secret_sprawl_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "kms must implement security controls for monitor_secret_usage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.secret_sprawl_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms monitor_secret_usage implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for monitor_secret_usage",
    "remediation": "Configure kms with security best practices for monitor_secret_usage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms enable_worm_storage implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for enable_worm_storage",
    "remediation": "Configure kms with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms legal_hold_protection implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for legal_hold_protection",
    "remediation": "Configure kms with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms immutable_audit_logs implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for immutable_audit_logs",
    "remediation": "Configure kms with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms retention_lock_enforcement implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for retention_lock_enforcement",
    "remediation": "Configure kms with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.kms.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "kms",
    "resource_type": "gcp.kms.keyRing",
    "adapter": "gcp.kms.immutability_configuration",
    "adapter_evidence_type": "gcp.kms.keyRing[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "kms must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.kms.immutability_configuration",
      "evidence_path": "gcp.kms.keyRing[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate kms compliance_immutability implementation",
    "title": "Kms Security Check",
    "description": "Ensure kms implements security best practices for compliance_immutability",
    "remediation": "Configure kms with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage enable_worm_storage implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for enable_worm_storage",
    "remediation": "Configure storage with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage legal_hold_protection implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for legal_hold_protection",
    "remediation": "Configure storage with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage immutable_audit_logs implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for immutable_audit_logs",
    "remediation": "Configure storage with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage retention_lock_enforcement implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for retention_lock_enforcement",
    "remediation": "Configure storage with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.immutability_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.immutability_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage compliance_immutability implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for compliance_immutability",
    "remediation": "Configure storage with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enable_worm_storage implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enable_worm_storage",
    "remediation": "Configure compute with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute legal_hold_protection implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for legal_hold_protection",
    "remediation": "Configure compute with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_audit_logs implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_audit_logs",
    "remediation": "Configure compute with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_lock_enforcement implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_lock_enforcement",
    "remediation": "Configure compute with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.immutability_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_immutability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_immutability",
    "remediation": "Configure compute with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database enable_worm_storage implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for enable_worm_storage",
    "remediation": "Configure database with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database legal_hold_protection implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for legal_hold_protection",
    "remediation": "Configure database with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database immutable_audit_logs implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for immutable_audit_logs",
    "remediation": "Configure database with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database retention_lock_enforcement implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for retention_lock_enforcement",
    "remediation": "Configure database with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.sql.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "database",
    "resource_type": "gcp.database.resource",
    "adapter": "gcp.sql.immutability_configuration",
    "adapter_evidence_type": "gcp.database.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "database must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.sql.immutability_configuration",
      "evidence_path": "gcp.database.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate database compliance_immutability implementation",
    "title": "Database Security Check",
    "description": "Ensure database implements security best practices for compliance_immutability",
    "remediation": "Configure database with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.enable_worm_storage",
    "assertion_id": "crypto_data_protection.immutability.enable_worm_storage",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "retention_years": 7
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for enable_worm_storage to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enable_worm_storage implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enable_worm_storage",
    "remediation": "Configure compute with security best practices for enable_worm_storage",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.legal_hold_protection",
    "assertion_id": "crypto_data_protection.immutability.legal_hold_protection",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for legal_hold_protection to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute legal_hold_protection implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for legal_hold_protection",
    "remediation": "Configure compute with security best practices for legal_hold_protection",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.immutable_audit_logs",
    "assertion_id": "crypto_data_protection.immutability.immutable_audit_logs",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for immutable_audit_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_audit_logs implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_audit_logs",
    "remediation": "Configure compute with security best practices for immutable_audit_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.retention_lock_enforcement",
    "assertion_id": "crypto_data_protection.immutability.retention_lock_enforcement",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for retention_lock_enforcement to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute retention_lock_enforcement implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for retention_lock_enforcement",
    "remediation": "Configure compute with security best practices for retention_lock_enforcement",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.immutability_configuration.compliance_immutability",
    "assertion_id": "crypto_data_protection.immutability.compliance_immutability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.immutability_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for compliance_immutability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.immutability_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute compliance_immutability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for compliance_immutability",
    "remediation": "Configure compute with security best practices for compliance_immutability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage detect_public_buckets implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for detect_public_buckets",
    "remediation": "Configure storage with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage block_public_access implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for block_public_access",
    "remediation": "Configure storage with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage audit_public_permissions implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for audit_public_permissions",
    "remediation": "Configure storage with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage encrypt_public_data implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for encrypt_public_data",
    "remediation": "Configure storage with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.public_exposure_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "storage must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.public_exposure_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage monitor_public_access implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for monitor_public_access",
    "remediation": "Configure storage with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.bigquery.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.bigquery.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.bigquery.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dataproc.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dataproc.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dataproc.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.detect_public_buckets",
    "assertion_id": "data_protection_storage.public_exposure.detect_public_buckets",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for detect_public_buckets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute detect_public_buckets implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for detect_public_buckets",
    "remediation": "Configure compute with security best practices for detect_public_buckets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.block_public_access",
    "assertion_id": "data_protection_storage.public_exposure.block_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for block_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute block_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for block_public_access",
    "remediation": "Configure compute with security best practices for block_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.audit_public_permissions",
    "assertion_id": "data_protection_storage.public_exposure.audit_public_permissions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for audit_public_permissions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute audit_public_permissions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for audit_public_permissions",
    "remediation": "Configure compute with security best practices for audit_public_permissions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.encrypt_public_data",
    "assertion_id": "data_protection_storage.public_exposure.encrypt_public_data",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for encrypt_public_data to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute encrypt_public_data implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for encrypt_public_data",
    "remediation": "Configure compute with security best practices for encrypt_public_data",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.dlp.public_exposure_configuration.monitor_public_access",
    "assertion_id": "data_protection_storage.public_exposure.monitor_public_access",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.dlp.public_exposure_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for monitor_public_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.dlp.public_exposure_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute monitor_public_access implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for monitor_public_access",
    "remediation": "Configure compute with security best practices for monitor_public_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.vpc.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.vpc.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.vpc.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firewall.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.firewall.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.firewall.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudarmor.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.cloudarmor.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudarmor.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.prefer_private_connectivity",
    "assertion_id": "network_perimeter.private_endpoints.prefer_private_connectivity",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for prefer_private_connectivity to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute prefer_private_connectivity implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for prefer_private_connectivity",
    "remediation": "Configure compute with security best practices for prefer_private_connectivity",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.disable_public_ingress",
    "assertion_id": "network_perimeter.private_endpoints.disable_public_ingress",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for disable_public_ingress to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disable_public_ingress implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for disable_public_ingress",
    "remediation": "Configure compute with security best practices for disable_public_ingress",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.vpc_endpoints_configured",
    "assertion_id": "network_perimeter.private_endpoints.vpc_endpoints_configured",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for vpc_endpoints_configured to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute vpc_endpoints_configured implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for vpc_endpoints_configured",
    "remediation": "Configure compute with security best practices for vpc_endpoints_configured",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.private_dns_enabled",
    "assertion_id": "network_perimeter.private_endpoints.private_dns_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for private_dns_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute private_dns_enabled implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for private_dns_enabled",
    "remediation": "Configure compute with security best practices for private_dns_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.loadbalancing.private_endpoints_configuration.network_isolation_enforced",
    "assertion_id": "network_perimeter.private_endpoints.network_isolation_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.loadbalancing.private_endpoints_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for network_isolation_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.loadbalancing.private_endpoints_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute network_isolation_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for network_isolation_enforced",
    "remediation": "Configure compute with security best practices for network_isolation_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute edr_agents_installed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for edr_agents_installed",
    "remediation": "Configure compute with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_agents_healthy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_agents_healthy",
    "remediation": "Configure compute with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute config_agents_deployed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for config_agents_deployed",
    "remediation": "Configure compute with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_versions_current implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_versions_current",
    "remediation": "Configure compute with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.agent_coverage_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_connectivity_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure compute with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute edr_agents_installed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for edr_agents_installed",
    "remediation": "Configure compute with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute patch_agents_healthy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for patch_agents_healthy",
    "remediation": "Configure compute with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute config_agents_deployed implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for config_agents_deployed",
    "remediation": "Configure compute with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_versions_current implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_versions_current",
    "remediation": "Configure compute with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.osconfig.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.resource",
    "adapter": "gcp.osconfig.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.compute.resource[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.osconfig.agent_coverage_configuration",
      "evidence_path": "gcp.compute.resource[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute agent_connectivity_monitored implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure compute with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.edr_agents_installed",
    "assertion_id": "compute_host_security.agent_coverage.edr_agents_installed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for edr_agents_installed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter edr_agents_installed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for edr_agents_installed",
    "remediation": "Configure securitycenter with security best practices for edr_agents_installed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.patch_agents_healthy",
    "assertion_id": "compute_host_security.agent_coverage.patch_agents_healthy",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for patch_agents_healthy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter patch_agents_healthy implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for patch_agents_healthy",
    "remediation": "Configure securitycenter with security best practices for patch_agents_healthy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.config_agents_deployed",
    "assertion_id": "compute_host_security.agent_coverage.config_agents_deployed",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for config_agents_deployed to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter config_agents_deployed implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for config_agents_deployed",
    "remediation": "Configure securitycenter with security best practices for config_agents_deployed",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.agent_versions_current",
    "assertion_id": "compute_host_security.agent_coverage.agent_versions_current",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for agent_versions_current to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter agent_versions_current implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for agent_versions_current",
    "remediation": "Configure securitycenter with security best practices for agent_versions_current",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.agent_coverage_configuration.agent_connectivity_monitored",
    "assertion_id": "compute_host_security.agent_coverage.agent_connectivity_monitored",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.agent_coverage_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for agent_connectivity_monitored to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.agent_coverage_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter agent_connectivity_monitored implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for agent_connectivity_monitored",
    "remediation": "Configure securitycenter with security best practices for agent_connectivity_monitored",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container pod_security_standards_enforced implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure container with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container privileged_containers_blocked implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for privileged_containers_blocked",
    "remediation": "Configure container with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container host_network_isolation implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for host_network_isolation",
    "remediation": "Configure container with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container host_path_restrictions implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for host_path_restrictions",
    "remediation": "Configure container with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "container must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.psa_enforcement_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container psa_namespace_policies implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for psa_namespace_policies",
    "remediation": "Configure container with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pod_security_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure compute with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_blocked",
    "remediation": "Configure compute with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_network_isolation implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_network_isolation",
    "remediation": "Configure compute with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_path_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_path_restrictions",
    "remediation": "Configure compute with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.psa_enforcement_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute psa_namespace_policies implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for psa_namespace_policies",
    "remediation": "Configure compute with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.pod_security_standards_enforced",
    "assertion_id": "containers_kubernetes.psa_enforcement.pod_security_standards_enforced",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "enforcement_mode": "enforce"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for pod_security_standards_enforced to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pod_security_standards_enforced implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pod_security_standards_enforced",
    "remediation": "Configure compute with security best practices for pod_security_standards_enforced",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.privileged_containers_blocked",
    "assertion_id": "containers_kubernetes.psa_enforcement.privileged_containers_blocked",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for privileged_containers_blocked to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute privileged_containers_blocked implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for privileged_containers_blocked",
    "remediation": "Configure compute with security best practices for privileged_containers_blocked",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.host_network_isolation",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_network_isolation",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for host_network_isolation to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_network_isolation implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_network_isolation",
    "remediation": "Configure compute with security best practices for host_network_isolation",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.host_path_restrictions",
    "assertion_id": "containers_kubernetes.psa_enforcement.host_path_restrictions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for host_path_restrictions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute host_path_restrictions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for host_path_restrictions",
    "remediation": "Configure compute with security best practices for host_path_restrictions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.binaryauthorization.psa_enforcement_configuration.psa_namespace_policies",
    "assertion_id": "containers_kubernetes.psa_enforcement.psa_namespace_policies",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.binaryauthorization.policy",
    "adapter": "gcp.binaryauthorization.psa_enforcement_configuration",
    "adapter_evidence_type": "gcp.binaryauthorization.policy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for psa_namespace_policies to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.binaryauthorization.psa_enforcement_configuration",
      "evidence_path": "gcp.binaryauthorization.policy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute psa_namespace_policies implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for psa_namespace_policies",
    "remediation": "Configure compute with security best practices for psa_namespace_policies",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.secret_hygiene_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudrun.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.run.service",
    "adapter": "gcp.cloudrun.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.run.service[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudrun.secret_hygiene_configuration",
      "evidence_path": "gcp.run.service[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.no_plaintext_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.no_plaintext_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for no_plaintext_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless no_plaintext_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for no_plaintext_secrets",
    "remediation": "Configure serverless with security best practices for no_plaintext_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.use_managed_secret_references",
    "assertion_id": "serverless_paas.secret_hygiene.use_managed_secret_references",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for use_managed_secret_references to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless use_managed_secret_references implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for use_managed_secret_references",
    "remediation": "Configure serverless with security best practices for use_managed_secret_references",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.rotate_function_secrets",
    "assertion_id": "serverless_paas.secret_hygiene.rotate_function_secrets",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "rotation_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for rotate_function_secrets to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless rotate_function_secrets implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for rotate_function_secrets",
    "remediation": "Configure serverless with security best practices for rotate_function_secrets",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.audit_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.audit_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for audit_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless audit_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for audit_secret_access",
    "remediation": "Configure serverless with security best practices for audit_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.appengine.secret_hygiene_configuration.least_privilege_secret_access",
    "assertion_id": "serverless_paas.secret_hygiene.least_privilege_secret_access",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.appengine.application",
    "adapter": "gcp.appengine.secret_hygiene_configuration",
    "adapter_evidence_type": "gcp.appengine.application[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for least_privilege_secret_access to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.appengine.secret_hygiene_configuration",
      "evidence_path": "gcp.appengine.application[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless least_privilege_secret_access implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for least_privilege_secret_access",
    "remediation": "Configure serverless with security best practices for least_privilege_secret_access",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.generate_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.generate_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for generate_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute generate_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for generate_sbom",
    "remediation": "Configure compute with security best practices for generate_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.sign_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.sign_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for sign_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sign_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sign_sbom",
    "remediation": "Configure compute with security best practices for sign_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.verify_provenance",
    "assertion_id": "supply_chain_registries.sbom_provenance.verify_provenance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for verify_provenance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute verify_provenance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for verify_provenance",
    "remediation": "Configure compute with security best practices for verify_provenance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.attest_build_environment",
    "assertion_id": "supply_chain_registries.sbom_provenance.attest_build_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for attest_build_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute attest_build_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for attest_build_environment",
    "remediation": "Configure compute with security best practices for attest_build_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.sbom_provenance_configuration.enforce_sbom_policy",
    "assertion_id": "supply_chain_registries.sbom_provenance.enforce_sbom_policy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for enforce_sbom_policy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.sbom_provenance_configuration",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_sbom_policy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_sbom_policy",
    "remediation": "Configure compute with security best practices for enforce_sbom_policy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.generate_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.generate_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for generate_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute generate_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for generate_sbom",
    "remediation": "Configure compute with security best practices for generate_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.sign_sbom",
    "assertion_id": "supply_chain_registries.sbom_provenance.sign_sbom",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for sign_sbom to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute sign_sbom implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for sign_sbom",
    "remediation": "Configure compute with security best practices for sign_sbom",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.verify_provenance",
    "assertion_id": "supply_chain_registries.sbom_provenance.verify_provenance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for verify_provenance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute verify_provenance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for verify_provenance",
    "remediation": "Configure compute with security best practices for verify_provenance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.attest_build_environment",
    "assertion_id": "supply_chain_registries.sbom_provenance.attest_build_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for attest_build_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute attest_build_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for attest_build_environment",
    "remediation": "Configure compute with security best practices for attest_build_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudbuild.sbom_provenance_configuration.enforce_sbom_policy",
    "assertion_id": "supply_chain_registries.sbom_provenance.enforce_sbom_policy",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.cloudbuild.build",
    "adapter": "gcp.cloudbuild.sbom_provenance_configuration",
    "adapter_evidence_type": "gcp.cloudbuild.build[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "compute must implement security controls for enforce_sbom_policy to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudbuild.sbom_provenance_configuration",
      "evidence_path": "gcp.cloudbuild.build[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_sbom_policy implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_sbom_policy",
    "remediation": "Configure compute with security best practices for enforce_sbom_policy",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring append_only_logging implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for append_only_logging",
    "remediation": "Configure monitoring with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_lock_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_lock_enabled",
    "remediation": "Configure monitoring with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring legal_hold_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for legal_hold_logs",
    "remediation": "Configure monitoring with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring tamper_evident_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for tamper_evident_logs",
    "remediation": "Configure monitoring with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.logging.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.logging.logSink",
    "adapter": "gcp.logging.log_immutability_configuration",
    "adapter_evidence_type": "gcp.logging.logSink[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "monitoring must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.logging.log_immutability_configuration",
      "evidence_path": "gcp.logging.logSink[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring immutable_audit_trail implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for immutable_audit_trail",
    "remediation": "Configure monitoring with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring append_only_logging implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for append_only_logging",
    "remediation": "Configure monitoring with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring retention_lock_enabled implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for retention_lock_enabled",
    "remediation": "Configure monitoring with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring legal_hold_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for legal_hold_logs",
    "remediation": "Configure monitoring with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring tamper_evident_logs implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for tamper_evident_logs",
    "remediation": "Configure monitoring with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.monitoring.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "monitoring",
    "resource_type": "gcp.monitoring.alertPolicy",
    "adapter": "gcp.monitoring.log_immutability_configuration",
    "adapter_evidence_type": "gcp.monitoring.alertPolicy[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "monitoring must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.monitoring.log_immutability_configuration",
      "evidence_path": "gcp.monitoring.alertPolicy[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate monitoring immutable_audit_trail implementation",
    "title": "Monitoring Security Check",
    "description": "Ensure monitoring implements security best practices for immutable_audit_trail",
    "remediation": "Configure monitoring with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.append_only_logging",
    "assertion_id": "logging_monitoring.log_immutability.append_only_logging",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for append_only_logging to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter append_only_logging implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for append_only_logging",
    "remediation": "Configure securitycenter with security best practices for append_only_logging",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.retention_lock_enabled",
    "assertion_id": "logging_monitoring.log_immutability.retention_lock_enabled",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for retention_lock_enabled to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter retention_lock_enabled implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for retention_lock_enabled",
    "remediation": "Configure securitycenter with security best practices for retention_lock_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.legal_hold_logs",
    "assertion_id": "logging_monitoring.log_immutability.legal_hold_logs",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for legal_hold_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter legal_hold_logs implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for legal_hold_logs",
    "remediation": "Configure securitycenter with security best practices for legal_hold_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.tamper_evident_logs",
    "assertion_id": "logging_monitoring.log_immutability.tamper_evident_logs",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for tamper_evident_logs to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter tamper_evident_logs implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for tamper_evident_logs",
    "remediation": "Configure securitycenter with security best practices for tamper_evident_logs",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.log_immutability_configuration.immutable_audit_trail",
    "assertion_id": "logging_monitoring.log_immutability.immutable_audit_trail",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.log_immutability_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "securitycenter must implement security controls for immutable_audit_trail to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.log_immutability_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter immutable_audit_trail implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for immutable_audit_trail",
    "remediation": "Configure securitycenter with security best practices for immutable_audit_trail",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.immutable_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.immutable_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for immutable_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute immutable_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for immutable_backups",
    "remediation": "Configure compute with security best practices for immutable_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.isolated_recovery_environment",
    "assertion_id": "resilience_recovery.ransomware_protection.isolated_recovery_environment",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for isolated_recovery_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute isolated_recovery_environment implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for isolated_recovery_environment",
    "remediation": "Configure compute with security best practices for isolated_recovery_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.malware_scan_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.malware_scan_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for malware_scan_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute malware_scan_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for malware_scan_backups",
    "remediation": "Configure compute with security best practices for malware_scan_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.pitr_capability",
    "assertion_id": "resilience_recovery.ransomware_protection.pitr_capability",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "recovery_point_minutes": 15
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for pitr_capability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute pitr_capability implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for pitr_capability",
    "remediation": "Configure compute with security best practices for pitr_capability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.ransomware_protection_configuration.air_gapped_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.air_gapped_backups",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for air_gapped_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.ransomware_protection_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute air_gapped_backups implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for air_gapped_backups",
    "remediation": "Configure compute with security best practices for air_gapped_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.immutable_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.immutable_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for immutable_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage immutable_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for immutable_backups",
    "remediation": "Configure storage with security best practices for immutable_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.isolated_recovery_environment",
    "assertion_id": "resilience_recovery.ransomware_protection.isolated_recovery_environment",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for isolated_recovery_environment to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage isolated_recovery_environment implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for isolated_recovery_environment",
    "remediation": "Configure storage with security best practices for isolated_recovery_environment",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.malware_scan_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.malware_scan_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for malware_scan_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage malware_scan_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for malware_scan_backups",
    "remediation": "Configure storage with security best practices for malware_scan_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.pitr_capability",
    "assertion_id": "resilience_recovery.ransomware_protection.pitr_capability",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "recovery_point_minutes": 15
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for pitr_capability to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage pitr_capability implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for pitr_capability",
    "remediation": "Configure storage with security best practices for pitr_capability",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.storage.ransomware_protection_configuration.air_gapped_backups",
    "assertion_id": "resilience_recovery.ransomware_protection.air_gapped_backups",
    "provider": "gcp",
    "service": "storage",
    "resource_type": "gcp.storage.bucket",
    "adapter": "gcp.storage.ransomware_protection_configuration",
    "adapter_evidence_type": "gcp.storage.bucket[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "storage must implement security controls for air_gapped_backups to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.storage.ransomware_protection_configuration",
      "evidence_path": "gcp.storage.bucket[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate storage air_gapped_backups implementation",
    "title": "Storage Security Check",
    "description": "Ensure storage implements security best practices for air_gapped_backups",
    "remediation": "Configure storage with security best practices for air_gapped_backups",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager track_exceptions implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for track_exceptions",
    "remediation": "Configure resourcemanager with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_approval implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_approval",
    "remediation": "Configure resourcemanager with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_expiry implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_expiry",
    "remediation": "Configure resourcemanager with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_controls implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_controls",
    "remediation": "Configure resourcemanager with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.resourcemanager.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "resourcemanager",
    "resource_type": "gcp.resourcemanager.project",
    "adapter": "gcp.resourcemanager.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.resourcemanager.project[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "resourcemanager must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.resourcemanager.exceptions_registry_configuration",
      "evidence_path": "gcp.resourcemanager.project[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate resourcemanager exception_monitoring implementation",
    "title": "Resourcemanager Security Check",
    "description": "Ensure resourcemanager implements security best practices for exception_monitoring",
    "remediation": "Configure resourcemanager with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter track_exceptions implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for track_exceptions",
    "remediation": "Configure securitycenter with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_approval implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_approval",
    "remediation": "Configure securitycenter with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_expiry implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_expiry",
    "remediation": "Configure securitycenter with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_controls implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_controls",
    "remediation": "Configure securitycenter with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.securitycenter.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "securitycenter",
    "resource_type": "gcp.securitycenter.source",
    "adapter": "gcp.securitycenter.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.securitycenter.source[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "securitycenter must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.securitycenter.exceptions_registry_configuration",
      "evidence_path": "gcp.securitycenter.source[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate securitycenter exception_monitoring implementation",
    "title": "Securitycenter Security Check",
    "description": "Ensure securitycenter implements security best practices for exception_monitoring",
    "remediation": "Configure securitycenter with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.track_exceptions",
    "assertion_id": "governance_compliance.exceptions_registry.track_exceptions",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for track_exceptions to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute track_exceptions implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for track_exceptions",
    "remediation": "Configure compute with security best practices for track_exceptions",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_approval",
    "assertion_id": "governance_compliance.exceptions_registry.exception_approval",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_approval to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_approval implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_approval",
    "remediation": "Configure compute with security best practices for exception_approval",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_expiry",
    "assertion_id": "governance_compliance.exceptions_registry.exception_expiry",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "max_duration_days": 365
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_expiry to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_expiry implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_expiry",
    "remediation": "Configure compute with security best practices for exception_expiry",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_controls",
    "assertion_id": "governance_compliance.exceptions_registry.exception_controls",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_controls to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_controls implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_controls",
    "remediation": "Configure compute with security best practices for exception_controls",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.assetinventory.exceptions_registry_configuration.exception_monitoring",
    "assertion_id": "governance_compliance.exceptions_registry.exception_monitoring",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.assetinventory.asset",
    "adapter": "gcp.assetinventory.exceptions_registry_configuration",
    "adapter_evidence_type": "gcp.assetinventory.asset[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "compute must implement security controls for exception_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.assetinventory.exceptions_registry_configuration",
      "evidence_path": "gcp.assetinventory.asset[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute exception_monitoring implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for exception_monitoring",
    "remediation": "Configure compute with security best practices for exception_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute track_deprecated_apis implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for track_deprecated_apis",
    "remediation": "Configure compute with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute enforce_migration_plans implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for enforce_migration_plans",
    "remediation": "Configure compute with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute deprecation_notifications implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for deprecation_notifications",
    "remediation": "Configure compute with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute version_compliance implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for version_compliance",
    "remediation": "Configure compute with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instance",
    "adapter": "gcp.compute.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.compute.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "compute must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.compute.deprecation_tracking_configuration",
      "evidence_path": "gcp.compute.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute eol_monitoring implementation",
    "title": "Compute Security Check",
    "description": "Ensure compute implements security best practices for eol_monitoring",
    "remediation": "Configure compute with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container track_deprecated_apis implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for track_deprecated_apis",
    "remediation": "Configure container with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container enforce_migration_plans implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for enforce_migration_plans",
    "remediation": "Configure container with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container deprecation_notifications implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for deprecation_notifications",
    "remediation": "Configure container with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container version_compliance implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for version_compliance",
    "remediation": "Configure container with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.gke.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.gke.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "extended",
    "rationale": "container must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.gke.deprecation_tracking_configuration",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container eol_monitoring implementation",
    "title": "Container Security Check",
    "description": "Ensure container implements security best practices for eol_monitoring",
    "remediation": "Configure container with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.track_deprecated_apis",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.track_deprecated_apis",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for track_deprecated_apis to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless track_deprecated_apis implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for track_deprecated_apis",
    "remediation": "Configure serverless with security best practices for track_deprecated_apis",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.enforce_migration_plans",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.enforce_migration_plans",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for enforce_migration_plans to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless enforce_migration_plans implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for enforce_migration_plans",
    "remediation": "Configure serverless with security best practices for enforce_migration_plans",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.deprecation_notifications",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.deprecation_notifications",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium",
      "notification_days": 90
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for deprecation_notifications to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless deprecation_notifications implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for deprecation_notifications",
    "remediation": "Configure serverless with security best practices for deprecation_notifications",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.version_compliance",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.version_compliance",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for version_compliance to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless version_compliance implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for version_compliance",
    "remediation": "Configure serverless with security best practices for version_compliance",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudfunctions.deprecation_tracking_configuration.eol_monitoring",
    "assertion_id": "platform_surfaces_versions.deprecation_tracking.eol_monitoring",
    "provider": "gcp",
    "service": "serverless",
    "resource_type": "gcp.cloudfunctions.function",
    "adapter": "gcp.cloudfunctions.deprecation_tracking_configuration",
    "adapter_evidence_type": "gcp.cloudfunctions.function[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "exhaustive",
    "rationale": "serverless must implement security controls for eol_monitoring to ensure proper security posture and compliance with best practices.",
    "adapter_spec": {
      "function": "gcp.cloudfunctions.deprecation_tracking_configuration",
      "evidence_path": "gcp.cloudfunctions.function[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate serverless eol_monitoring implementation",
    "title": "Serverless Security Check",
    "description": "Ensure serverless implements security best practices for eol_monitoring",
    "remediation": "Configure serverless with security best practices for eol_monitoring",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group.group_mfa_enforced",
    "assertion_id": "identity_access.authentication.group_mfa_enforced",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_mfa_enforcement",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Group-based MFA ensures all privileged users have strong authentication.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_mfa_enforcement",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity group_mfa_enforcement implementation",
    "title": "Cloud Identity Group MFA Check",
    "description": "Ensure cloudidentity implements security best practices for group_mfa_enforced",
    "remediation": "Configure cloudidentity with security best practices for group_mfa_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.cloudidentity.group.group_roles_least_privilege",
    "assertion_id": "rbac_entitlements.role_definition.group_roles_least_privilege",
    "provider": "gcp",
    "service": "cloudidentity",
    "resource_type": "gcp.cloudidentity.group",
    "adapter": "gcp.cloudidentity.group_roles",
    "adapter_evidence_type": "gcp.cloudidentity.group[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Group roles should be scoped to minimum required permissions.",
    "adapter_spec": {
      "function": "gcp.cloudidentity.group_roles",
      "evidence_path": "gcp.cloudidentity.group[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate cloudidentity group_roles implementation",
    "title": "Cloud Identity Group Roles Check",
    "description": "Ensure cloudidentity implements security best practices for group_roles_least_privilege",
    "remediation": "Configure cloudidentity with security best practices for group_roles_least_privilege",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.filestore.instance.fileshare_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.fileshare_encryption_enabled",
    "provider": "gcp",
    "service": "filestore",
    "resource_type": "gcp.filestore.instance",
    "adapter": "gcp.filestore.encryption_at_rest",
    "adapter_evidence_type": "gcp.filestore.instance[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Encryption protects file share data from unauthorized access.",
    "adapter_spec": {
      "function": "gcp.filestore.encryption_at_rest",
      "evidence_path": "gcp.filestore.instance[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate filestore encryption_at_rest implementation",
    "title": "Filestore Encryption Check",
    "description": "Ensure filestore implements security best practices for fileshare_encryption_enabled",
    "remediation": "Configure filestore with security best practices for fileshare_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.pubsub.topic.queue_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.queue_encryption_enabled",
    "provider": "gcp",
    "service": "pubsub",
    "resource_type": "gcp.pubsub.topic",
    "adapter": "gcp.pubsub.topic_encryption",
    "adapter_evidence_type": "gcp.pubsub.topic[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Queue encryption prevents data exposure from message interception.",
    "adapter_spec": {
      "function": "gcp.pubsub.topic_encryption",
      "evidence_path": "gcp.pubsub.topic[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate pubsub topic_encryption implementation",
    "title": "Pub/Sub Topic Encryption Check",
    "description": "Ensure pubsub implements security best practices for queue_encryption_enabled",
    "remediation": "Configure pubsub with security best practices for queue_encryption_enabled",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.firestore.database.table_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.table_encryption_enabled",
    "provider": "gcp",
    "service": "firestore",
    "resource_type": "gcp.firestore.database",
    "adapter": "gcp.firestore.database_encryption",
    "adapter_evidence_type": "gcp.firestore.database[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Table encryption protects structured data at rest.",
    "adapter_spec": {
      "function": "gcp.firestore.database_encryption",
      "evidence_path": "gcp.firestore.database[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate firestore database_encryption implementation",
    "title": "Firestore Database Encryption Check",
    "description": "Ensure firestore implements security best practices for table_encryption_enabled",
    "remediation": "Configure firestore with security best practices for table_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.snapshot.snapshot_encryption_enabled",
    "assertion_id": "storage_datastores.snapshot_management.snapshot_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.snapshot",
    "adapter": "gcp.compute.snapshot_encryption",
    "adapter_evidence_type": "gcp.compute.snapshot[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Snapshot encryption prevents data exposure from backup access.",
    "adapter_spec": {
      "function": "gcp.compute.snapshot_encryption",
      "evidence_path": "gcp.compute.snapshot[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute snapshot_encryption implementation",
    "title": "Compute Snapshot Encryption Check",
    "description": "Ensure compute implements security best practices for snapshot_encryption_enabled",
    "remediation": "Configure compute with security best practices for snapshot_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.disk.volume_encryption_enabled",
    "assertion_id": "storage_datastores.storage_security.volume_encryption_enabled",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.disk",
    "adapter": "gcp.compute.disk_encryption",
    "adapter_evidence_type": "gcp.compute.disk[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Volume encryption protects persistent data from unauthorized access.",
    "adapter_spec": {
      "function": "gcp.compute.disk_encryption",
      "evidence_path": "gcp.compute.disk[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute disk_encryption implementation",
    "title": "Compute Disk Encryption Check",
    "description": "Ensure compute implements security best practices for volume_encryption_enabled",
    "remediation": "Configure compute with security best practices for volume_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.image.golden_images_used",
    "assertion_id": "compute_host_security.image_security.golden_images_used",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.image",
    "adapter": "gcp.compute.image_approval",
    "adapter_evidence_type": "gcp.compute.image[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Golden images reduce attack surface and ensure consistent hardening.",
    "adapter_spec": {
      "function": "gcp.compute.image_approval",
      "evidence_path": "gcp.compute.image[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_approval implementation",
    "title": "Compute Image Approval Check",
    "description": "Ensure compute implements security best practices for golden_images_used",
    "remediation": "Configure compute with security best practices for golden_images_used",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.image.image_vulnerability_scanning",
    "assertion_id": "compute_host_security.image_security.image_vulnerability_scanning",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.image",
    "adapter": "gcp.compute.image_vulnerability_scan",
    "adapter_evidence_type": "gcp.compute.image[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Pre-deployment scanning prevents vulnerable images from being deployed.",
    "adapter_spec": {
      "function": "gcp.compute.image_vulnerability_scan",
      "evidence_path": "gcp.compute.image[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute image_vulnerability_scan implementation",
    "title": "Compute Image Vulnerability Scan Check",
    "description": "Ensure compute implements security best practices for image_vulnerability_scanning",
    "remediation": "Configure compute with security best practices for image_vulnerability_scanning",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.instanceGroup.instance_group_secure_config",
    "assertion_id": "cluster_management_plane.capacity_management.instance_group_secure_config",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.instanceGroup",
    "adapter": "gcp.compute.instance_group_configuration",
    "adapter_evidence_type": "gcp.compute.instanceGroup[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Secure instance group configuration prevents security misconfigurations.",
    "adapter_spec": {
      "function": "gcp.compute.instance_group_configuration",
      "evidence_path": "gcp.compute.instanceGroup[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute instance_group_configuration implementation",
    "title": "Compute Instance Group Configuration Check",
    "description": "Ensure compute implements security best practices for instance_group_secure_config",
    "remediation": "Configure compute with security best practices for instance_group_secure_config",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.firewall.security_group_least_privilege",
    "assertion_id": "network_segmentation.microsegmentation.security_group_least_privilege",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.firewall",
    "adapter": "gcp.compute.firewall_rules",
    "adapter_evidence_type": "gcp.compute.firewall[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Least privilege security group rules minimize attack surface.",
    "adapter_spec": {
      "function": "gcp.compute.firewall_rules",
      "evidence_path": "gcp.compute.firewall[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute firewall_rules implementation",
    "title": "Compute Firewall Rules Check",
    "description": "Ensure compute implements security best practices for security_group_least_privilege",
    "remediation": "Configure compute with security best practices for security_group_least_privilege",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.compute.route.route_tables_secure_routing",
    "assertion_id": "network_segmentation.network_segmentation.route_tables_secure_routing",
    "provider": "gcp",
    "service": "compute",
    "resource_type": "gcp.compute.route",
    "adapter": "gcp.compute.route_rules",
    "adapter_evidence_type": "gcp.compute.route[]",
    "params": {
      "validation_required": true,
      "compliance_level": "medium"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "medium",
    "coverage_tier": "core",
    "rationale": "Secure routing prevents traffic from bypassing security controls.",
    "adapter_spec": {
      "function": "gcp.compute.route_rules",
      "evidence_path": "gcp.compute.route[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate compute route_rules implementation",
    "title": "Compute Route Rules Check",
    "description": "Ensure compute implements security best practices for route_tables_secure_routing",
    "remediation": "Configure compute with security best practices for route_tables_secure_routing",
    "implementation_priority": "medium",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.container.cluster.cluster_encryption_enabled",
    "assertion_id": "containers_kubernetes.cluster_hardening.cluster_encryption_enabled",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.cluster",
    "adapter": "gcp.container.cluster_encryption",
    "adapter_evidence_type": "gcp.container.cluster[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Cluster encryption protects etcd and API server data.",
    "adapter_spec": {
      "function": "gcp.container.cluster_encryption",
      "evidence_path": "gcp.container.cluster[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container cluster_encryption implementation",
    "title": "Container Cluster Encryption Check",
    "description": "Ensure container implements security best practices for cluster_encryption_enabled",
    "remediation": "Configure container with security best practices for cluster_encryption_enabled",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.container.nodePool.node_pool_security_configured",
    "assertion_id": "containers_kubernetes.cluster_hardening.node_pool_security_configured",
    "provider": "gcp",
    "service": "container",
    "resource_type": "gcp.container.nodePool",
    "adapter": "gcp.container.node_pool_security",
    "adapter_evidence_type": "gcp.container.nodePool[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Node pool security ensures consistent hardening across worker nodes.",
    "adapter_spec": {
      "function": "gcp.container.node_pool_security",
      "evidence_path": "gcp.container.nodePool[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate container node_pool_security implementation",
    "title": "Container Node Pool Security Check",
    "description": "Ensure container implements security best practices for node_pool_security_configured",
    "remediation": "Configure container with security best practices for node_pool_security_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.repository.access_controls_configured",
    "assertion_id": "supply_chain_registries.registry_policy.access_controls_configured",
    "provider": "gcp",
    "service": "artifactregistry",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.repository_policy",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Registry policies control access to container images and artifacts.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.repository_policy",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate artifactregistry repository_policy implementation",
    "title": "Artifact Registry Repository Policy Check",
    "description": "Ensure artifactregistry implements security best practices for access_controls_configured",
    "remediation": "Configure artifactregistry with security best practices for access_controls_configured",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  },
  {
    "rule_id": "gcp.artifactregistry.repository.vulnerability_scanning_enforced",
    "assertion_id": "supply_chain_registries.registry_policy.vulnerability_scanning_enforced",
    "provider": "gcp",
    "service": "artifactregistry",
    "resource_type": "gcp.artifactregistry.repository",
    "adapter": "gcp.artifactregistry.vulnerability_scanning",
    "adapter_evidence_type": "gcp.artifactregistry.repository[]",
    "params": {
      "validation_required": true,
      "compliance_level": "high"
    },
    "pass_condition": "resource.compliant == true",
    "severity": "high",
    "coverage_tier": "core",
    "rationale": "Automated scanning prevents vulnerable images from entering the registry.",
    "adapter_spec": {
      "function": "gcp.artifactregistry.vulnerability_scanning",
      "evidence_path": "gcp.artifactregistry.repository[]",
      "validation": {
        "type": "generic_check",
        "field": "data",
        "operator": "exists",
        "threshold": null,
        "aggregate": "per_item"
      },
      "returns": {
        "compliant": "boolean",
        "total_checked": "integer",
        "compliant_count": "integer",
        "violations": "array"
      }
    },
    "notes": "Validate artifactregistry vulnerability_scanning implementation",
    "title": "Artifact Registry Vulnerability Scanning Check",
    "description": "Ensure artifactregistry implements security best practices for vulnerability_scanning_enforced",
    "remediation": "Configure artifactregistry with security best practices for vulnerability_scanning_enforced",
    "implementation_priority": "high",
    "check_frequency": "continuous"
  }
]