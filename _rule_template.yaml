# YAML Rule Template (AWS Compliance Engine)
# Replace <placeholders> with concrete values. Comments explain purpose and usage for AI tools.

# Component/service identifiers
component: <component>  # e.g., ec2, s3, iam (lowercase service slug)
service: <service>      # usually same as component; sets default AWS service context for actions

# Scope (cloud/provider targeting)
applies:
  providers: [<provider>]  # e.g., aws (list allowed)

# Discovery phase
# - One or more discovery pipelines fetch resources and extract fields into per-item snapshots.
# - Each "fields" entry binds a variable accessible later as item.<var> in checks.
discovery:
- discovery_id: <discovery_id>  # unique label referenced by checks.for_each
  calls:
  - action: <action>            # registry-defined action name (e.g., list_snapshots, describe_volumes, identity)
    params: {}                  # optional input for the action; keep key present (empty object if none)
    fields:
    - path: <path>              # dot-path into action response; supports list wildcard '[]' (e.g., 'Items[].Encrypted')
      var: <var>                # variable name to bind (e.g., snapshot_id); later referenced as item.<var>
    # Add more fields as needed

# Checks phase
# - Evaluates assertions for each discovered item from for_each.
# - "calls" may be 'identity' (evaluate fields directly) or another action that uses the item context.
checks:
- check_id: <check_id>              # globally-unique rule identifier
  name: <name>                      # human-readable name
  severity: <LOW|MEDIUM|HIGH|CRITICAL>  # compliance severity
  for_each: <discovery_id>          # iterate over results from the discovery block above
  param: <param_name>               # variable name injected into action params (default typically 'item')
  calls:
  - action: <action>                # typically 'identity'; can be a service action that uses {<param_name>: item}
    params: {}                      # merged with the action context; include keys if needed
    fields:
    - path: <path>                  # evaluate against action payload; common form is item.<var>
      operator: <equals|not_equals|contains|not_contains|exists|not_exists|gt|gte|lt|lte|in|not_in|regex>
      expected: <expected>          # omit for exists/not_exists; for contains on dicts, acts as subset
    # Add more fields as needed
  logic: <AND|OR>                   # how to combine multiple field assertions within this check
  errors_as_fail: []                # error identifiers that should cause FAIL instead of ERROR (empty for none)
  # pass_when_empty: <true|false>   # optional; if true and for_each yields no items, mark PASS

# Operator semantics (must match evaluator):
# - equals/not_equals: strict equality vs inequality
# - contains/not_contains: list/string membership; for dicts, expected is a subset that must be present
# - exists/not_exists: checks key presence and non-null vs absence/null (no expected value)
# - gt/gte/lt/lte: numeric comparisons
# - in/not_in: membership of actual in expected list
# - regex: Python-style regex match applied to string actual

# Path resolution rules (ActionRegistry.resolve_path):
# - Use dot notation, e.g., 'a.b.c'
# - List wildcard '[]' maps over lists, e.g., 'Items[].Encrypted'
# - Numeric indices allowed for lists, e.g., 'Items.0.Name'
# - Underscore and dash are treated equivalently for keys ('foo_bar' â†” 'foo-bar')

# Notes for tool-generated actions:
# - Ensure action names exist in the registry for the target service or provide mocks.
# - Keep 'component' aligned with the service to route default clients.
# - Maintain 1:1 mapping between discovery fields (var bindings) and check expressions using item.<var>. 