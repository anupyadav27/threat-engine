You are working inside my repo that generates per-service dependency artifacts for a C7N-style engine.

PROVIDER: alicloud

ASSUMPTION
AliCloud service JSON specs have the SAME structure as my AWS/Azure/GCP enriched specs:
- operations list with:
  - operation (name)
  - python_method (optional)
  - required_params (list)
  - optional_params (list)
  - output_fields (object)
  - main_output_field (string or null)
  - item_fields (object or list)  // when main_output_field is list-like

GOAL (ALL services under alicloud/**/)
For every AliCloud service folder, produce FINAL artifacts:
1) operation_registry.json (FINAL)
2) adjacency.json (FINAL)
3) validation_report.json (FINAL)
4) direct_vars.json (FINAL)
5) overrides.json (FINAL, merged + applied)
6) manual_review.json (ONLY remaining unresolved/conflicts after auto-fix)
7) fixes_applied.json (audit of auto-applied suggestions)
Optional global summary:
8) manual_review_global_summary.json

IMPORTANT MODELING RULES
A) Treat BOTH as “producers”:
   - output_fields keys
   - item_fields keys (these are actual emitted values too)

B) Treat required_params as “consumers”.

C) Many-to-many supported:
   - one operation produces multiple entities
   - one operation consumes multiple entities
   - an entity can be produced by multiple operations

--------------------------------------------------------------------
DELIVERABLE 1: Operation Registry schema (operation_registry.json)
--------------------------------------------------------------------
Per operation store:
- operation_id: "alicloud.<service>.<operation>"
- operation: original name
- python_method: if present else null
- kind: one of [read_list, read_get, write_create, write_update, write_delete, write_other]
- required_params, optional_params
- produces: list of produced key paths (output_fields + item_fields, include list paths like Items[].Id)
- consumes: list of required param names
- produced_entities: mapping { produced_key_path -> canonical_entity }
- consumed_entities: mapping { required_param -> canonical_entity }
- entity_aliases_used: mapping { alias -> canonical } used during normalization
- notes/confidence: mark ambiguous mappings

--------------------------------------------------------------------
DELIVERABLE 2: Adjacency (adjacency.json)
--------------------------------------------------------------------
Edges connect producer operation -> consumer operation when producer emits an entity that satisfies consumer required param:
Edge:
- from_operation_id
- to_operation_id
- entity (canonical)
- from_key (produced key path)
- to_param (required param)
- edge_type: "satisfies_required_param"
- confidence + reason

Also include:
- independent_ops (required_params empty)
- root_seeds (ops that can start discovery chains)

--------------------------------------------------------------------
DELIVERABLE 3: Validation Report (validation_report.json)
--------------------------------------------------------------------
Include:
- total_ops, total_edges
- satisfiable_ops_percent
- unresolved_consumers (required params with no producers)
- ambiguous_entities (evidence keys with >1 possible entity)
- generic_token_hits (id/name/status/etc without resource scoping)
- suspicious_paths_count
- overrides_applied_count
- aliases_applied_count
- cycles list (if any)

--------------------------------------------------------------------
KIND AUTO-ASSIGN (AliCloud-aware, deterministic)
--------------------------------------------------------------------
Assign kind from operation name (case-insensitive) using FIRST matching rule:

write_delete if starts with:
  Delete, Remove, Unbind, Detach, Release, Revoke, Cancel, UnTag, Disable
write_update if starts with:
  Update, Modify, Set, Change, Attach, Bind, Add, Put, Patch, Enable
write_create if starts with:
  Create, Allocate, Start, Open, Activate, Register, Authorize, Grant, Purchase
read_list if starts with:
  List, Describe, Query, Get (plural outputs or list main_output_field)
read_get if starts with:
  Get, Describe (single-object outputs)
else:
  read_other

If both patterns match, prefer write_* over read_*.

--------------------------------------------------------------------
ENTITY NORMALIZATION + ALIAS HANDLING (GLOBAL, NOT PER-SERVICE)
--------------------------------------------------------------------
Problem: tokens like Id/Name/Status appear everywhere. We must namespace them.

1) Canonical entity format:
   "alicloud.<service>.<resource>.<field>"
Examples:
  alicloud.ecs.instance.instance_id
  alicloud.ecs.instance.status
  alicloud.oss.bucket.name

2) Global identity exceptions (DO NOT service-prefix these):
Map these ALWAYS to global entities:
- RegionId / region_id => alicloud.region_id
- AccountId / account_id => alicloud.account_id
- ZoneId / zone_id => alicloud.zone_id
- VpcId / vpc_id => alicloud.vpc_id  (optional global if you want cross-service linking)
- VSwitchId / vswitch_id => alicloud.vswitch_id (optional global)
- NextToken / PageNumber / PageSize => alicloud.pagination_token (not a resource identity)

3) Derive <resource> (in this order):
a) Use main_output_field/item_fields parent name when list-like:
   - Items[] / Instances[] / Buckets[] -> instance/bucket
b) Else use operation name stripped of verbs (List/Get/Describe/Create/Update/Delete/Modify/Set):
   remaining noun tokens => resource
c) Else fallback: "resource"

4) Mapping rules:
4.1 CONSUMES (required_params):
- If param is a global identity -> map using section 2
- If param endswith "Id" or equals "Id":
    map to alicloud.<service>.<resource>.<resource>_id
- If param endswith "Name" or equals "Name":
    map to alicloud.<service>.<resource>.name
- If param is generic (id/name/status/arn/uid/key):
    ALWAYS namespace to resource scope as above
- If param indicates a parent resource (e.g., InstanceId, BucketName):
    set resource accordingly (instance/bucket) even if operation name is generic

4.2 PRODUCES (output_fields + item_fields):
- Include both output_fields and item_fields.
- If produced key is generic Id/Name/Status:
   infer resource from the parent path:
   Example: Instances[].InstanceId => alicloud.ecs.instance.instance_id
            Buckets[].Name => alicloud.oss.bucket.name
- Never leave entity as alicloud.<service>.id or alicloud.<service>.name without a resource noun.
- Canonicalize all entities through entity_aliases at the end.

5) Alias layers (must implement BOTH):
- entity_aliases: alias_entity -> canonical_entity
- overrides.param_aliases: evidence_key -> canonical_entity

Evidence key format (stable):
- Params: "<operation>:param:<param_name>"
- Outputs: "<operation>:out:<output_path>"

Resolution priority:
i) overrides.param_aliases if present
ii) inferred mapping rules
iii) canonicalize through entity_aliases

--------------------------------------------------------------------
OVERRIDES + SUGGESTED_OVERRIDES (Auto apply)
--------------------------------------------------------------------
Each service folder may contain manual_review.json with suggested_overrides like:
{
  "suggested_overrides": [
    {
      "operation": "...",
      "type": "produces"|"consumes",
      "key": "OutputPathOrParam",
      "suggested_entity": "...",
      "confidence": "HIGH|MEDIUM|LOW",
      "reason": "..."
    }
  ]
}

Implement a two-pass workflow:

PASS 1:
- generate registry+adjacency+validation+manual_review with candidates

AUTO-APPLY:
- Accept HIGH always -> write into overrides.json
- Accept MEDIUM only if it reduces:
    generic_token_hits OR ambiguous_entities OR unresolved_consumers
  and does NOT increase unsatisfiable ops
- LOW never auto-applied
- Write audit to fixes_applied.json:
  accepted[], rejected[], conflicts[]

PASS 2:
- regenerate artifacts using overrides.json + entity_aliases applied everywhere
- manual_review.json must be updated and SHRINK:
  remove resolved items by evidence_key match
  keep only conflicts/unresolved

IMPORTANT BUG FIX:
If fixes are recorded, remove corresponding unresolved_items from manual_review.
Do not keep “already fixed” items.

--------------------------------------------------------------------
FINAL OUTPUT HYGIENE
--------------------------------------------------------------------
In each service folder keep ONLY final artifacts:
- operation_registry.json
- adjacency.json
- validation_report.json
- direct_vars.json
- overrides.json
- manual_review.json (empty or minimal)
- fixes_applied.json
Remove or archive intermediate files (optional).

GLOBAL RUNNER
Create a CLI that processes all AliCloud services under a root:
- python tools/finalize_all_services.py alicloud/
Outputs manual_review_global_summary.json with:
- services_with_conflicts
- services_with_remaining_unresolved
- top recurring ambiguous tokens
- overall satisfiable_ops_percent

SAFETY
- Write .bak before overwriting outputs
- Stable sorted pretty JSON for clean diffs

Now implement/refactor generator + fixer so a single run produces final outputs for all AliCloud services.
Prefer deterministic logic; log reasons for heuristics.
